This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
cli/
  help.zig
  parser.zig
config/
  cli.zig
  config_struct.zig
  network.zig
  security.zig
  timeout.zig
  tls.zig
  types.zig
  validator.zig
io/
  hexdump/
    formatter.zig
    output.zig
  tls_transfer/
    cleanup.zig
    errors.zig
    test_utils.zig
    tests.zig
    transfer.zig
  hexdump.zig
  linecodec.zig
  output.zig
  tls_transfer.zig
  transfer.zig
main/
  modes/
    broker.zig
    server.zig
    unix.zig
  app.zig
  common.zig
net/
  allowlist/
    dns_cache.zig
    ip_filter.zig
    rule_parser.zig
  proxy/
    http_connect.zig
    mod.zig
    socks4.zig
    socks5.zig
  unixsock/
    client.zig
    server.zig
    utils.zig
  allowlist.zig
  connection.zig
  sctp.zig
  socket.zig
  tcp.zig
  udp.zig
  unixsock.zig
protocol/
  telnet_connection.zig
  telnet_options.zig
  telnet_processor.zig
  telnet.zig
server/
  broker/
    client_manager.zig
    message_handler.zig
    protocols.zig
  broker.zig
  buffer_pool.zig
  chat.zig
  exec_session.zig
  exec_threaded.zig
  exec_types.zig
  exec.zig
  flow_control.zig
  listen.zig
  performance_monitor.zig
  relay.zig
tls/
  README.md
  tls_iface.zig
  tls_metrics.zig
  tls_openssl.zig
  tls_state.zig
  tls.zig
util/
  io_ring_buffer.zig
  iocp_windows.zig
  logging.zig
  path_safety.zig
  platform.zig
  poll_wrapper.zig
  portscan.zig
  security.zig
  timeout_tracker.zig
cli.zig
client.zig
config.zig
main.zig
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="cli/help.zig">
//! Help and version display functions for zigcat CLI.
//!
//! This module provides user-facing output for:
//! - Usage information (printHelp)
//! - Basic version info (printVersion)
//! - Detailed version info (printVersionAll)

const std = @import("std");

/// Print usage information and exit.
///
/// Displays comprehensive help text including:
/// - Basic usage patterns
/// - All supported flags organized by category
/// - Example commands for common use cases
pub fn printHelp() void {
    std.debug.print(
        \\zigcat - Zig implementation of netcat
        \\
        \\USAGE:
        \\  zigcat [options] [host] [port]
        \\  zigcat -l [options] [port]
        \\
        \\CONNECT MODE (default):
        \\  zigcat <host> <port>          Connect to host:port
        \\
        \\LISTEN MODE:
        \\  -l, --listen                  Listen mode
        \\  -k, --keep-open               Keep listening after disconnect
        \\  -m, --max-conns <n>           Maximum concurrent connections
        \\
        \\BROKER/CHAT MODE:
        \\  --broker                      Broker mode (relay data between clients)
        \\  --chat                        Chat mode (line-oriented with nicknames)
        \\  --max-clients <n>             Maximum clients for broker/chat mode (default: 50)
        \\
        \\PROTOCOL OPTIONS:
        \\  -u, --udp                     UDP mode
        \\  --sctp                        SCTP mode
        \\  -U, --unixsock <path>         Unix domain socket (local IPC)
        \\  -4                            IPv4 only
        \\  -6                            IPv6 only
        \\
        \\TIMING OPTIONS:
        \\  -w, --wait <secs>             Connect timeout
        \\  -i, --idle-timeout <secs>     Idle timeout
        \\  -q, --close-on-eof            Close connection on EOF from stdin
        \\
        \\TRANSFER OPTIONS:
        \\  --send-only                   Only send data (close read)
        \\  --recv-only                   Only receive data (close write)
        \\  -C, --crlf                    Convert LF to CRLF
        \\  -t, --telnet                  Telnet protocol mode (process IAC sequences)
        \\  --no-shutdown                 Keep socket write-half open after stdin EOF
        \\  -d, --delay <ms>              Traffic shaping delay in milliseconds
        \\
        \\SSL/TLS OPTIONS:
        \\  --ssl                         Enable SSL/TLS
        \\  --ssl-verify                  Enable certificate verification (default)
        \\  --no-ssl-verify               Disable certificate verification (INSECURE!)
        \\  --ssl-cert <file>             SSL certificate file (server mode)
        \\  --ssl-key <file>              SSL private key file (server mode)
        \\  --ssl-trustfile <file>        SSL CA certificate bundle
        \\  --ssl-crl <file>              Certificate Revocation List (CRL) file
        \\  --ssl-ciphers <ciphers>       SSL cipher suite list
        \\  --ssl-servername <name>       SNI server name (for virtual hosting)
        \\  --ssl-alpn <protocols>        ALPN protocol list (e.g., "h2,http/1.1")
        \\
        \\PROXY OPTIONS:
        \\  --proxy <url>                 Proxy URL (http://host:port, socks5://host:port)
        \\  --proxy-type <type>           Proxy type (http, socks4, socks5)
        \\  --proxy-auth <user:pass>      Proxy authentication credentials
        \\                                WARNING: Credentials sent in Base64 (NOT encrypted).
        \\                                Only use with HTTPS proxy URLs to protect credentials.
        \\                                Plain HTTP connections expose username/password to
        \\                                network attackers who can easily decode Base64.
        \\  --proxy-dns <mode>            DNS resolution mode (local, remote, both)
        \\
        \\EXECUTION OPTIONS:
        \\  -e, --exec <cmd> [args...]    Execute command with arguments
        \\                                Use -- to pass args with hyphens:
        \\                                  zigcat -l -e -- grep -v 'pattern'
        \\  -c, --sh-exec <cmd>           Execute command via shell
        \\  --allow                       Allow dangerous operations
        \\
        \\OUTPUT OPTIONS:
        \\  -v, --verbose                 Verbose mode (connection details and stats)
        \\  -vv                           Debug mode (protocol details and hex dumps)
        \\  -vvv                          Trace mode (all internal state tracing)
        \\  -q, --quiet                   Quiet mode (errors only, suppresses all logging)
        \\  -o, --output <file>           Write received data to file
        \\  --append                      Append to output file instead of truncating
        \\  -x, --hex-dump [file]         Display data in hex format (optionally to file)
        \\  --append-output               Append to hex dump file instead of truncating
        \\
        \\VERBOSITY LEVELS:
        \\  quiet  (0): Silent except for errors
        \\  normal (1): Connection events and warnings (default)
        \\  verbose (2): -v enables detailed connection info and transfer stats
        \\  debug  (3): -vv enables protocol-level details and hex dumps
        \\  trace  (4): -vvv enables all internal state and function tracing
        \\
        \\ACCESS CONTROL:
        \\  --allow-ip <ips>              Allow specific IPs/CIDRs/hostnames (comma-separated)
        \\                                Examples: 192.168.1.0/24,10.0.0.1,example.com
        \\  --deny-ip <ips>               Deny specific IPs/CIDRs/hostnames (comma-separated)
        \\  --allow-file <file>           Read allow rules from file (one per line)
        \\  --deny-file <file>            Read deny rules from file (one per line)
        \\  --drop-user <user>            Drop privileges to user after bind (Unix only)
        \\
        \\  WARNING: Hostname rules use DNS which can be manipulated by attackers.
        \\           Prefer IP-based rules for production security. Hostnames add
        \\           10-100ms latency per connection due to DNS lookups.
        \\
        \\PORT SCANNING OPTIONS:
        \\  -z, --zero-io                 Zero-I/O mode (port scanning)
        \\  --scan-parallel               Enable parallel port scanning (10-100x faster)
        \\  --scan-workers <n>            Number of worker threads for parallel scanning (default: 10)
        \\                                Recommended: 10-50 workers depending on network bandwidth
        \\                                Higher values = faster scans but more aggressive
        \\
        \\OTHER OPTIONS:
        \\  --keep-source-port            Bind to specific source port before connect
        \\  --                            End of options (all following args are positional)
        \\  -h, --help                    Show this help
        \\  --version                     Show version
        \\  --version-all                 Show detailed version info (platform, features)
        \\
        \\EXAMPLES:
        \\  Basic usage:
        \\    zigcat google.com 80          Connect to Google on port 80
        \\    zigcat -l 8080                Listen on port 8080
        \\    zigcat -l -k 8080             Listen on port 8080, keep open
        \\    zigcat -u 192.168.1.1 53      UDP connection to DNS server
        \\
        \\  Verbosity control:
        \\    zigcat -v host 80             Verbose: show connection details
        \\    zigcat -vv host 80            Debug: show protocol details
        \\    zigcat -vvv host 80           Trace: show all internal state
        \\    zigcat -q host 80             Quiet: suppress all output except errors
        \\
        \\  I/O control:
        \\    zigcat --send-only host 80    Only send data to host:80
        \\    zigcat --recv-only host 80    Only receive data from host:80
        \\    zigcat -o output.txt host 80  Save received data to file
        \\    zigcat -x host 80             Display data in hex format
        \\    zigcat -x dump.hex host 80    Save hex dump to file
        \\
        \\  Advanced modes:
        \\    zigcat -l --broker 8080       Broker mode on port 8080
        \\    zigcat -l --chat 8080         Chat mode on port 8080
        \\    zigcat -l --broker --max-clients 100 8080  Broker with 100 max clients
        \\    zigcat -U /tmp/socket         Connect to Unix socket
        \\    zigcat -l -U /tmp/socket      Listen on Unix socket
        \\
        \\  Command execution:
        \\    zigcat -l -e grep foo         Execute grep (args without hyphens)
        \\    zigcat -l -e -- grep -v foo   Execute grep with -v flag (using --)
        \\
        \\  Port scanning:
        \\    zigcat -z localhost 80         Test if port 80 is open (sequential)
        \\    zigcat -z --scan-parallel localhost 80  Test port 80 (parallel mode)
        \\    zigcat -z --scan-parallel --scan-workers 20 example.com 1-1024
        \\                                  Scan ports 1-1024 with 20 workers (fast!)
        \\    zigcat -z -w 0.5 --scan-parallel --scan-workers 50 192.168.1.1 1-65535
        \\                                  Scan all ports with 50 workers and 500ms timeout
        \\
    , .{});
}

/// Print version information and exit.
pub fn printVersion() void {
    const build_options = @import("build_options");
    std.debug.print("zigcat {s}\nZig implementation of netcat\n", .{build_options.version});
}

/// Print detailed version information including dependencies.
pub fn printVersionAll() void {
    const build_options = @import("build_options");
    const builtin = @import("builtin");
    std.debug.print("zigcat {s}\n", .{build_options.version});
    std.debug.print("Zig {s}\n", .{builtin.zig_version_string});
    std.debug.print("Platform: {s}-{s}\n", .{ @tagName(builtin.os.tag), @tagName(builtin.cpu.arch) });
    std.debug.print("Build mode: {s}\n", .{@tagName(builtin.mode)});

    // Detect TLS availability at compile time
    const tls_available = @hasDecl(@import("../tls/tls.zig"), "TlsConnection");
    std.debug.print("Features: TLS={s}, UnixSock={s}\n", .{
        if (tls_available) "enabled" else "disabled",
        if (@import("../config.zig").UnixSocketSupport.available) "available" else "unavailable",
    });
}
</file>

<file path="cli/parser.zig">
//! Command-line argument parser for zigcat.
//!
//! This module handles parsing command-line arguments into a Config structure.
//! Features:
//! - Long and short flag support (e.g., -v / --verbose)
//! - Value flags with validation (e.g., -w 30, --port 8080)
//! - Comma-separated list parsing (--allow-ip 10.0.0.1,192.168.1.0/24)
//! - Positional argument handling (host port)
//! - Early validation of conflicting flags
//!
//! Timeout conversion:
//! - All timeout flags (-w, -i) accept seconds
//! - Internally converted to milliseconds (* 1000)
//! - Stored in Config as u32 milliseconds
//!
//! Exec mode argument parsing:
//! - -e flag collects all following args until next flag
//! - Arguments stored in cfg.exec_args ArrayList
//! - Must be freed by Config.deinit()

const std = @import("std");
const config = @import("../config.zig");
const logging = @import("../util/logging.zig");
const path_safety = @import("../util/path_safety.zig");

/// Errors that can occur during command-line argument parsing.
pub const CliError = error{
    /// Both --send-only and --recv-only specified
    ConflictingIOModes,
    /// Conflicting options specified
    ConflictingOptions,
    /// Output file path is invalid or empty
    InvalidOutputPath,
    /// Flag requires a value but none provided
    MissingValue,
    /// Unknown command-line flag
    UnknownOption,
    /// User requested help (-h/--help)
    ShowHelp,
    /// User requested version (--version)
    ShowVersion,
};

/// Parse command-line arguments into a Config structure.
///
/// Parsing rules:
/// 1. Skip program name (args[0])
/// 2. Process flags in order, handling both short (-x) and long (--xxx) forms
/// 3. Flags with values consume the next argument
/// 4. Non-flag arguments are collected as positional args
/// 5. Validate for conflicts (e.g., --send-only + --recv-only)
///
/// Special behaviors:
/// - Help/version requests return specific errors for early exit
/// - Timeout values converted from seconds to milliseconds
/// - Comma-separated lists (--allow-ip) split and stored individually
/// - Exec args (-e) consume all following non-flag arguments
///
/// Parameters:
///   allocator: For dynamic allocations (lists, strings)
///   args: Command-line arguments including program name
///
/// Returns: Populated Config structure or CliError
pub fn parseArgs(allocator: std.mem.Allocator, args: []const [:0]const u8) !config.Config {
    var cfg = config.Config.init(allocator);
    var positional = std.ArrayList([]const u8){};
    defer positional.deinit(allocator);

    const is_test = @import("builtin").is_test;

    var i: usize = 1; // Skip program name
    var end_of_options = false; // Track if we've seen --
    var verbose_count: u8 = 0; // Track number of -v flags

    while (i < args.len) : (i += 1) {
        const arg = args[i];

        // Detect -- separator (end of options)
        if (std.mem.eql(u8, arg, "--")) {
            end_of_options = true;
            continue;
        }

        // After --, treat everything as positional args (no flag processing)
        if (end_of_options or !std.mem.startsWith(u8, arg, "-")) {
            // Positional argument
            try positional.append(allocator, arg);
            continue;
        }

        // Handle flags
        if (std.mem.eql(u8, arg, "-h") or std.mem.eql(u8, arg, "--help")) {
            return CliError.ShowHelp;
        } else if (std.mem.eql(u8, arg, "--version")) {
            return CliError.ShowVersion;
        } else if (std.mem.eql(u8, arg, "--version-all")) {
            cfg.version_info = "all";
            return CliError.ShowVersion;
        } else if (std.mem.eql(u8, arg, "-l") or std.mem.eql(u8, arg, "--listen")) {
            cfg.listen_mode = true;
        } else if (std.mem.eql(u8, arg, "-u") or std.mem.eql(u8, arg, "--udp")) {
            cfg.udp_mode = true;
        } else if (std.mem.eql(u8, arg, "-v") or std.mem.eql(u8, arg, "--verbose") or
            std.mem.eql(u8, arg, "-vv") or std.mem.eql(u8, arg, "-vvv") or
            std.mem.eql(u8, arg, "-vvvv"))
        {
            // Count number of 'v' characters in the flag
            if (std.mem.startsWith(u8, arg, "-v")) {
                const v_count = arg.len - 1; // Subtract the leading '-'
                verbose_count += @as(u8, @intCast(v_count));
                cfg.verbose = true; // Backward compatibility
            } else {
                // --verbose counts as 1
                verbose_count += 1;
                cfg.verbose = true;
            }
        } else if (std.mem.eql(u8, arg, "-q") or std.mem.eql(u8, arg, "--quiet")) {
            cfg.verbosity = .quiet;
        } else if (std.mem.eql(u8, arg, "-k") or std.mem.eql(u8, arg, "--keep-open")) {
            cfg.keep_listening = true;
        } else if (std.mem.eql(u8, arg, "-4")) {
            cfg.ipv4_only = true;
        } else if (std.mem.eql(u8, arg, "-6")) {
            cfg.ipv6_only = true;
        } else if (std.mem.eql(u8, arg, "-C") or std.mem.eql(u8, arg, "--crlf")) {
            cfg.crlf = true;
        } else if (std.mem.eql(u8, arg, "-n") or std.mem.eql(u8, arg, "--nodns")) {
            cfg.no_dns = true;
        } else if (std.mem.eql(u8, arg, "--send-only")) {
            cfg.send_only = true;
        } else if (std.mem.eql(u8, arg, "--recv-only")) {
            cfg.recv_only = true;
        } else if (std.mem.eql(u8, arg, "--broker")) {
            cfg.broker_mode = true;
        } else if (std.mem.eql(u8, arg, "--chat")) {
            cfg.chat_mode = true;
        } else if (std.mem.eql(u8, arg, "--ssl")) {
            cfg.ssl = true;
        } else if (std.mem.eql(u8, arg, "-t") or std.mem.eql(u8, arg, "--telnet")) {
            cfg.telnet = true;
        } else if (std.mem.eql(u8, arg, "--append")) {
            cfg.append_output = true;
        } else if (std.mem.eql(u8, arg, "--append-output")) {
            cfg.hex_dump_append = true;
        } else if (std.mem.eql(u8, arg, "--no-shutdown")) {
            cfg.no_shutdown = true;
        } else if (std.mem.eql(u8, arg, "--keep-source-port")) {
            cfg.keep_source_port = true;
        } else if (std.mem.eql(u8, arg, "--allow")) {
            cfg.allow_dangerous = true;
        } else if (std.mem.eql(u8, arg, "--sctp")) {
            cfg.sctp_mode = true;
        } else if (std.mem.eql(u8, arg, "--no-stdin")) {
            cfg.exec_redirect_stdin = false;
        } else if (std.mem.eql(u8, arg, "--no-stdout")) {
            cfg.exec_redirect_stdout = false;
        } else if (std.mem.eql(u8, arg, "--no-stderr")) {
            cfg.exec_redirect_stderr = false;
        } else if (std.mem.eql(u8, arg, "-q") or std.mem.eql(u8, arg, "--close-on-eof")) {
            cfg.close_on_eof = true;
        } else if (std.mem.eql(u8, arg, "-z") or std.mem.eql(u8, arg, "--zero-io")) {
            cfg.zero_io = true;
        } else if (std.mem.eql(u8, arg, "--scan-parallel")) {
            cfg.scan_parallel = true;
        } else if (std.mem.eql(u8, arg, "--scan-randomize")) {
            cfg.scan_randomize = true;
        }
        // Flags with values
        else if (std.mem.eql(u8, arg, "-s") or std.mem.eql(u8, arg, "--source")) {
            i += 1;
            if (i >= args.len) return CliError.MissingValue;
            cfg.source_addr = args[i];
        } else if (std.mem.eql(u8, arg, "-p") or std.mem.eql(u8, arg, "--source-port")) {
            i += 1;
            if (i >= args.len) return CliError.MissingValue;
            cfg.source_port = try std.fmt.parseInt(u16, args[i], 10);
        } else if (std.mem.eql(u8, arg, "-w") or std.mem.eql(u8, arg, "--wait")) {
            i += 1;
            if (i >= args.len) return CliError.MissingValue;
            cfg.wait_time = try std.fmt.parseInt(u32, args[i], 10) * 1000;
        } else if (std.mem.eql(u8, arg, "-i") or std.mem.eql(u8, arg, "--idle-timeout")) {
            i += 1;
            if (i >= args.len) return CliError.MissingValue;
            cfg.idle_timeout = try std.fmt.parseInt(u32, args[i], 10) * 1000;
        } else if (std.mem.eql(u8, arg, "-o") or std.mem.eql(u8, arg, "--output")) {
            i += 1;
            if (i >= args.len) return CliError.MissingValue;
            cfg.output_file = args[i];
        } else if (std.mem.eql(u8, arg, "-e") or std.mem.eql(u8, arg, "--exec")) {
            i += 1;
            if (i >= args.len) return CliError.MissingValue;
            cfg.exec_command = args[i];
            // Collect all remaining args until next flag or end
            i += 1;
            while (i < args.len) : (i += 1) {
                const current_arg = args[i];

                // If we see --, enable end_of_options and continue collecting
                if (std.mem.eql(u8, current_arg, "--")) {
                    end_of_options = true;
                    continue;
                }

                // Stop at next flag ONLY if we haven't seen --
                if (!end_of_options and std.mem.startsWith(u8, current_arg, "-")) {
                    break;
                }

                // Collect this argument for exec
                const arg_copy = try allocator.dupe(u8, current_arg);
                try cfg.exec_args.append(allocator, arg_copy);
            }
            i -= 1; // Back up one since the main loop will increment
        } else if (std.mem.eql(u8, arg, "-c") or std.mem.eql(u8, arg, "--sh-exec")) {
            i += 1;
            if (i >= args.len) return CliError.MissingValue;
            cfg.shell_command = args[i];
        } else if (std.mem.eql(u8, arg, "-m") or std.mem.eql(u8, arg, "--max-conns")) {
            i += 1;
            if (i >= args.len) return CliError.MissingValue;
            cfg.max_conns = try std.fmt.parseInt(u32, args[i], 10);
        } else if (std.mem.eql(u8, arg, "--max-clients")) {
            i += 1;
            if (i >= args.len) return CliError.MissingValue;
            cfg.max_clients = try std.fmt.parseInt(u32, args[i], 10);
        } else if (std.mem.eql(u8, arg, "--ssl-cert")) {
            i += 1;
            if (i >= args.len) return CliError.MissingValue;
            cfg.ssl_cert = args[i];
        } else if (std.mem.eql(u8, arg, "--ssl-key")) {
            i += 1;
            if (i >= args.len) return CliError.MissingValue;
            cfg.ssl_key = args[i];
        } else if (std.mem.eql(u8, arg, "--ssl-trustfile")) {
            i += 1;
            if (i >= args.len) return CliError.MissingValue;
            cfg.ssl_trustfile = args[i];
        } else if (std.mem.eql(u8, arg, "--ssl-ciphers")) {
            i += 1;
            if (i >= args.len) return CliError.MissingValue;
            cfg.ssl_ciphers = args[i];
        } else if (std.mem.eql(u8, arg, "--ssl-servername")) {
            i += 1;
            if (i >= args.len) return CliError.MissingValue;
            cfg.ssl_servername = args[i];
        } else if (std.mem.eql(u8, arg, "--ssl-alpn")) {
            i += 1;
            if (i >= args.len) return CliError.MissingValue;
            cfg.ssl_alpn = args[i];
        } else if (std.mem.eql(u8, arg, "--ssl-verify")) {
            cfg.ssl_verify = true;
        } else if (std.mem.eql(u8, arg, "--no-ssl-verify") or std.mem.eql(u8, arg, "--ssl-verify=false")) {
            cfg.ssl_verify = false;
        } else if (std.mem.eql(u8, arg, "--ssl-crl")) {
            i += 1;
            if (i >= args.len) return CliError.MissingValue;
            cfg.ssl_crl = args[i];
        } else if (std.mem.eql(u8, arg, "--proxy")) {
            i += 1;
            if (i >= args.len) return CliError.MissingValue;
            cfg.proxy = args[i];
        } else if (std.mem.eql(u8, arg, "--proxy-type")) {
            i += 1;
            if (i >= args.len) return CliError.MissingValue;
            cfg.proxy_type = try parseProxyType(args[i]);
        } else if (std.mem.eql(u8, arg, "--proxy-auth")) {
            i += 1;
            if (i >= args.len) return CliError.MissingValue;
            cfg.proxy_auth = args[i];
        } else if (std.mem.eql(u8, arg, "--proxy-dns")) {
            i += 1;
            if (i >= args.len) return CliError.MissingValue;
            cfg.proxy_dns = try parseProxyDns(args[i]);
        } else if (std.mem.eql(u8, arg, "-d") or std.mem.eql(u8, arg, "--delay")) {
            i += 1;
            if (i >= args.len) return CliError.MissingValue;
            cfg.delay_ms = try std.fmt.parseInt(u32, args[i], 10);
        } else if (std.mem.eql(u8, arg, "--deny-file")) {
            i += 1;
            if (i >= args.len) return CliError.MissingValue;
            cfg.deny_file = args[i];
        } else if (std.mem.eql(u8, arg, "--allow-file")) {
            i += 1;
            if (i >= args.len) return CliError.MissingValue;
            cfg.allow_file = args[i];
        } else if (std.mem.eql(u8, arg, "--allow-ip")) {
            i += 1;
            if (i >= args.len) return CliError.MissingValue;
            // Support comma-separated values: --allow-ip 192.168.1.0/24,10.0.0.1
            try parseCommaSeparatedList(allocator, args[i], &cfg.allow_list);
        } else if (std.mem.eql(u8, arg, "--deny-ip")) {
            i += 1;
            if (i >= args.len) return CliError.MissingValue;
            // Support comma-separated values: --deny-ip 0.0.0.0/0
            try parseCommaSeparatedList(allocator, args[i], &cfg.deny_list);
        } else if (std.mem.eql(u8, arg, "--drop-user")) {
            i += 1;
            if (i >= args.len) return CliError.MissingValue;
            cfg.drop_privileges_user = args[i];
        } else if (std.mem.eql(u8, arg, "-U") or std.mem.eql(u8, arg, "--unixsock")) {
            i += 1;
            if (i >= args.len) return CliError.MissingValue;
            cfg.unix_socket_path = args[i];
        } else if (std.mem.eql(u8, arg, "-x") or std.mem.eql(u8, arg, "--hex-dump")) {
            cfg.hex_dump = true;
            // Check if next argument is a file path (not a flag)
            if (i + 1 < args.len and !std.mem.startsWith(u8, args[i + 1], "-")) {
                i += 1;
                cfg.hex_dump_file = args[i];
            }
        } else if (std.mem.eql(u8, arg, "--scan-workers")) {
            i += 1;
            if (i >= args.len) return CliError.MissingValue;
            cfg.scan_workers = try std.fmt.parseInt(usize, args[i], 10);
        } else if (std.mem.eql(u8, arg, "--scan-delay")) {
            i += 1;
            if (i >= args.len) return CliError.MissingValue;
            cfg.scan_delay_ms = try std.fmt.parseInt(u32, args[i], 10);
        } else {
            logging.logError(error.UnknownOption, "Unknown option");
            logging.logWarning("  Option: {s}\n", .{arg});
            return CliError.UnknownOption;
        }
    }

    cfg.positional_args = try positional.toOwnedSlice(allocator);
    errdefer allocator.free(cfg.positional_args);

    // Map verbose count to verbosity level (only if not explicitly set to quiet)
    if (cfg.verbosity != .quiet and verbose_count > 0) {
        cfg.verbosity = switch (verbose_count) {
            1 => .verbose,
            2 => .debug,
            else => .trace, // 3 or more -> trace
        };
        cfg.verbose_level = @intFromEnum(cfg.verbosity); // Backward compatibility
    }

    // Validate I/O control flags
    if (cfg.send_only and cfg.recv_only) {
        if (!is_test) logging.logError(error.ConflictingIOModes, "--send-only and --recv-only are mutually exclusive");
        return CliError.ConflictingIOModes;
    }

    // Validate broker/chat mode flags
    if (cfg.broker_mode and cfg.chat_mode) {
        if (!is_test) logging.logError(error.ConflictingIOModes, "--broker and --chat are mutually exclusive");
        return CliError.ConflictingIOModes; // Reuse existing error for simplicity
    }

    // Validate output file path if specified
    if (cfg.output_file) |path| {
        try ensureCliPathSafe(path, "Output file", is_test);
    }

    // Validate hex dump file path if specified
    if (cfg.hex_dump_file) |path| {
        try ensureCliPathSafe(path, "Hex dump file", is_test);
    }

    if (cfg.ssl_cert) |path| {
        try ensureCliPathSafe(path, "TLS certificate", is_test);
    }

    if (cfg.ssl_key) |path| {
        try ensureCliPathSafe(path, "TLS key", is_test);
    }

    if (cfg.ssl_trustfile) |path| {
        try ensureCliPathSafe(path, "TLS trust store", is_test);
    }

    if (cfg.ssl_crl) |path| {
        try ensureCliPathSafe(path, "TLS CRL", is_test);
    }

    if (cfg.allow_file) |path| {
        try ensureCliPathSafe(path, "Allow rule file", is_test);
    }

    if (cfg.deny_file) |path| {
        try ensureCliPathSafe(path, "Deny rule file", is_test);
    }

    // Validate Unix socket configuration if specified
    if (cfg.unix_socket_path != null) {
        config.validateUnixSocket(&cfg) catch |err| switch (err) {
            config.UnixSocketError.UnixSocketsNotSupported, config.UnixSocketError.PlatformNotSupported => {
                if (!is_test) logging.logError(err, "Unix domain sockets not supported on this platform");
                return CliError.UnknownOption; // Reuse existing error for simplicity
            },
            config.UnixSocketError.InvalidUnixSocketPath => {
                if (!is_test) logging.logError(err, "Unix socket path cannot be empty");
                return CliError.InvalidOutputPath;
            },
            config.UnixSocketError.UnixSocketPathTooLong => {
                if (!is_test) logging.logError(err, "Unix socket path is too long (max 107 characters)");
                return CliError.InvalidOutputPath;
            },
            config.UnixSocketError.UnixSocketPathContainsNull => {
                if (!is_test) logging.logError(err, "Unix socket path contains null bytes");
                return CliError.InvalidOutputPath;
            },
            config.UnixSocketError.InvalidUnixSocketPathCharacters => {
                if (!is_test) logging.logError(err, "Unix socket path contains invalid characters");
                return CliError.InvalidOutputPath;
            },
            config.UnixSocketError.UnixSocketDirectoryNotFound => {
                if (!is_test) logging.logError(err, "Parent directory for Unix socket does not exist");
                return CliError.InvalidOutputPath;
            },
            config.UnixSocketError.UnixSocketPermissionDenied => {
                if (!is_test) logging.logError(err, "Permission denied for Unix socket path");
                return CliError.InvalidOutputPath;
            },
            config.UnixSocketError.FeatureNotAvailable => {
                if (!is_test) logging.logError(err, "Unix socket feature not available");
                return CliError.UnknownOption;
            },
            config.UnixSocketError.ConflictingUnixSocketAndProxy => {
                if (!is_test) logging.logError(err, "Unix sockets cannot be used with proxy settings");
                return CliError.ConflictingOptions;
            },
            config.UnixSocketError.ConflictingUnixSocketAndBroker => {
                if (!is_test) logging.logError(err, "Unix sockets cannot be used with broker/chat mode");
                return CliError.ConflictingOptions;
            },
            config.UnixSocketError.ConflictingUnixSocketAndExec => {
                if (!is_test) logging.logError(err, "Unix sockets with exec mode require special configuration");
                return CliError.ConflictingOptions;
            },
            config.UnixSocketError.UnixSocketResourceExhausted => {
                if (!is_test) logging.logError(err, "System resources exhausted for Unix socket");
                return CliError.UnknownOption;
            },
            config.UnixSocketError.UnixSocketSystemError => {
                if (!is_test) logging.logError(err, "System error with Unix socket configuration");
                return CliError.UnknownOption;
            },
            config.UnixSocketError.UnixSocketConfigurationError => {
                if (!is_test) logging.logError(err, "Invalid Unix socket configuration");
                return CliError.InvalidOutputPath;
            },
            config.UnixSocketError.ConflictingUnixSocketAndTCP => {
                if (!is_test) logging.logError(err, "Unix socket (-U) cannot be used with host/port arguments");
                return CliError.ConflictingIOModes;
            },
            config.UnixSocketError.ConflictingUnixSocketAndUDP => {
                if (!is_test) logging.logError(err, "Unix socket (-U) cannot be used with UDP mode (-u)");
                return CliError.ConflictingIOModes;
            },
            config.UnixSocketError.ConflictingUnixSocketAndTLS => {
                if (!is_test) logging.logError(err, "Unix socket (-U) cannot be used with TLS mode (--ssl)");
                return CliError.ConflictingIOModes;
            },
        };
    }

    return cfg;
}

/// Parse proxy type string into ProxyType enum.
///
/// Supported values:
/// - "http": HTTP CONNECT proxy
/// - "socks4": SOCKS4 proxy
/// - "socks5": SOCKS5 proxy
///
/// Returns: ProxyType enum or InvalidProxyType error
fn parseProxyType(s: []const u8) !config.ProxyType {
    if (std.mem.eql(u8, s, "http")) return .http;
    if (std.mem.eql(u8, s, "socks4")) return .socks4;
    if (std.mem.eql(u8, s, "socks5")) return .socks5;
    return error.InvalidProxyType;
}

/// Parse proxy DNS string into ProxyDns enum.
///
/// Supported values:
/// - "local": Resolve DNS locally before sending to proxy
/// - "remote": Send hostname to proxy for remote resolution
/// - "both": Support both local and remote resolution
///
/// Returns: ProxyDns enum or InvalidProxyDns error
fn parseProxyDns(s: []const u8) !config.ProxyDns {
    if (std.mem.eql(u8, s, "local")) return .local;
    if (std.mem.eql(u8, s, "remote")) return .remote;
    if (std.mem.eql(u8, s, "both")) return .both;
    return error.InvalidProxyDns;
}

/// Parse comma-separated list and add to ArrayList.
///
/// Splits input string on commas and trims whitespace from each item.
/// Empty items after trimming are skipped.
///
/// Example input: "192.168.1.0/24, 10.0.0.1, 2001:db8::/32"
/// Results in 3 list items (whitespace trimmed).
///
/// Parameters:
///   allocator: For duplicating strings (caller must free)
///   input: Comma-separated string
///   list: ArrayList to append items to
fn parseCommaSeparatedList(
    allocator: std.mem.Allocator,
    input: []const u8,
    list: *std.ArrayList([]const u8),
) !void {
    var it = std.mem.splitScalar(u8, input, ',');
    while (it.next()) |item| {
        const trimmed = std.mem.trim(u8, item, " \t");
        if (trimmed.len > 0) {
            const owned = try allocator.dupe(u8, trimmed);
            try list.append(allocator, owned);
        }
    }
}

fn ensureCliPathSafe(path: []const u8, context: []const u8, is_test: bool) CliError!void {
    if (path.len == 0) {
        if (!is_test) logging.logError(error.InvalidOutputPath, "{s} path cannot be empty", .{context});
        return CliError.InvalidOutputPath;
    }

    if (std.mem.indexOf(u8, path, "\x00") != null) {
        if (!is_test) logging.logError(error.InvalidOutputPath, "{s} path contains null bytes", .{context});
        return CliError.InvalidOutputPath;
    }

    if (!path_safety.isSafePath(path)) {
        if (!is_test) logging.logError(error.InvalidOutputPath, "{s} path contains invalid traversal sequences", .{context});
        return CliError.InvalidOutputPath;
    }
}
</file>

<file path="config/cli.zig">
//! CLI-related configuration validation.
//!
//! This module handles validation of options that are primarily
//! controlled via command-line flags, such as output redirection
//! and I/O mode toggles.

const std = @import("std");
const builtin = @import("builtin");
const path_safety = @import("../util/path_safety.zig");

const config_struct = @import("config_struct.zig");
const Config = config_struct.Config;

/// Errors related to I/O control configuration validation.
pub const IOControlError = error{
    /// Both --send-only and --recv-only flags specified
    ConflictingIOModes,
    /// Failed to create output file for logging
    OutputFileCreateFailed,
    /// Failed to write to output file
    OutputFileWriteFailed,
    /// Failed to create hex dump file
    HexDumpFileCreateFailed,
    /// Failed to write to hex dump file
    HexDumpFileWriteFailed,
    /// Output file path is invalid (empty or malformed)
    InvalidOutputPath,
    /// File path contains invalid characters or sequences
    InvalidPathCharacters,
    /// File path is too long for the filesystem
    PathTooLong,
    /// Insufficient permissions to create or write to file
    InsufficientPermissions,
    /// Directory in file path does not exist
    DirectoryNotFound,
    /// Disk full or insufficient space for file operations
    DiskFull,
    /// File is locked by another process
    FileLocked,
    /// File path points to a directory instead of a file
    IsDirectory,
    /// File system error during operation
    FileSystemError,
    /// File path contains parent directory traversal (e.g. ../)
    PathTraversalDetected,
};

/// Validate I/O control configuration for conflicts and path issues.
/// Checks mutually exclusive I/O modes and validates file paths.
pub fn validateIOControl(cfg: *const Config) IOControlError!void {
    // Check for conflicting I/O modes
    if (cfg.send_only and cfg.recv_only) {
        return IOControlError.ConflictingIOModes;
    }

    // Validate output file path if specified
    if (cfg.output_file) |path| {
        try validateFilePath(path, "output file");
    }

    // Validate hex dump file path if specified
    if (cfg.hex_dump_file) |path| {
        try validateFilePath(path, "hex dump file");
    }
}

/// Validate a file path for common issues and accessibility.
fn validateFilePath(path: []const u8, context: []const u8) IOControlError!void {
    _ = context;
    if (path.len == 0) {
        return IOControlError.InvalidOutputPath;
    }

    const MAX_PATH_LENGTH = 4096;
    if (path.len > MAX_PATH_LENGTH) {
        return IOControlError.PathTooLong;
    }

    for (path) |byte| {
        if (byte == 0) {
            return IOControlError.InvalidPathCharacters;
        }
        if (byte < 32 and byte != '\t') {
            return IOControlError.InvalidPathCharacters;
        }
    }

    if (builtin.os.tag == .windows) {
        try validateWindowsPath(path);
    } else {
        try validateUnixPath(path);
    }

    if (!path_safety.isSafePath(path)) {
        return IOControlError.PathTraversalDetected;
    }

    if (std.fs.path.dirname(path)) |parent_dir| {
        std.fs.cwd().access(parent_dir, .{}) catch |err| switch (err) {
            error.FileNotFound => return IOControlError.DirectoryNotFound,
            error.AccessDenied => return IOControlError.InsufficientPermissions,
            else => {},
        };
    }
}

/// Validate Windows-specific path requirements.
fn validateWindowsPath(path: []const u8) IOControlError!void {
    const reserved_names = [_][]const u8{
        "CON",  "PRN",  "AUX",  "NUL",
        "COM1", "COM2", "COM3", "COM4",
        "COM5", "COM6", "COM7", "COM8",
        "COM9", "LPT1", "LPT2", "LPT3",
        "LPT4", "LPT5", "LPT6", "LPT7",
        "LPT8", "LPT9",
    };

    const filename = std.fs.path.basename(path);
    const name_without_ext = if (std.mem.lastIndexOfScalar(u8, filename, '.')) |dot_index|
        filename[0..dot_index]
    else
        filename;

    for (reserved_names) |reserved| {
        if (std.ascii.eqlIgnoreCase(name_without_ext, reserved)) {
            return IOControlError.InvalidPathCharacters;
        }
    }

    // Check for invalid Windows characters
    // Note: ':' is allowed only for drive letters (e.g., C:\)
    const invalid_chars = [_]u8{ '<', '>', ':', '"', '/', '\\', '|', '?', '*' };
    for (invalid_chars) |ch| {
        if (std.mem.indexOfScalar(u8, path, ch) != null) {
            return IOControlError.InvalidPathCharacters;
        }
    }

    // Check for trailing spaces or dots
    if (path.len > 0) {
        const last_char = path[path.len - 1];
        if (last_char == ' ' or last_char == '.') {
            return IOControlError.InvalidPathCharacters;
        }
    }

    // Check for trailing spaces/dots in components
    var it = std.mem.splitScalar(u8, path, '\\');
    while (it.next()) |component| {
        if (component.len == 0) continue;
        const last_char = component[component.len - 1];
        if (last_char == ' ' or last_char == '.') {
            return IOControlError.InvalidPathCharacters;
        }
    }
}

/// Validate Unix-specific path requirements.
fn validateUnixPath(path: []const u8) IOControlError!void {
    // Check for extremely long path components
    var it = std.mem.splitScalar(u8, path, '/');
    while (it.next()) |component| {
        if (component.len > 255) {
            return IOControlError.PathTooLong;
        }
    }
}

test "validateIOControl catches conflicting I/O modes" {
    const testing = std.testing;

    var cfg = Config.init(testing.allocator);
    defer cfg.deinit(testing.allocator);

    cfg.send_only = true;
    cfg.recv_only = true;

    try testing.expectError(IOControlError.ConflictingIOModes, validateIOControl(&cfg));
}

test "validateIOControl accepts compatible modes and paths" {
    const testing = std.testing;

    var cfg = Config.init(testing.allocator);
    defer cfg.deinit(testing.allocator);

    cfg.send_only = true;
    try validateIOControl(&cfg);

    cfg.send_only = false;
    cfg.recv_only = true;
    try validateIOControl(&cfg);

    cfg.recv_only = false;
    cfg.output_file = "/tmp/output.txt";
    cfg.hex_dump_file = "/tmp/hexdump.txt";
    try validateIOControl(&cfg);
}

test "validateFilePath rejects malformed paths" {
    const testing = std.testing;

    try testing.expectError(IOControlError.InvalidOutputPath, validateFilePath("", "test"));

    const long_path = "a" ** 5000;
    try testing.expectError(IOControlError.PathTooLong, validateFilePath(long_path, "test"));

    try testing.expectError(IOControlError.InvalidPathCharacters, validateFilePath("bad\x00path", "test"));
    try testing.expectError(IOControlError.InvalidPathCharacters, validateFilePath("bad\x01path", "test"));

    try testing.expectError(IOControlError.PathTraversalDetected, validateFilePath("../etc/passwd", "test"));
    try testing.expectError(IOControlError.PathTraversalDetected, validateFilePath("..\\windows\\system.ini", "test"));
}
</file>

<file path="config/config_struct.zig">
//! Core configuration structure for zigcat.
//!
//! This module owns the central `Config` type that aggregates
//! runtime options parsed from the CLI. Behaviour-specific
//! validation lives in sibling modules (`cli.zig`, `network.zig`,
//! `tls.zig`, `security.zig`).

const std = @import("std");
const exec = @import("../server/exec.zig");
const types = @import("types.zig");

/// Central configuration structure for all zigcat runtime options.
///
/// Memory management: ArrayLists must be freed via `deinit()` before deallocation.
pub const Config = struct {
    // Connection mode flags
    listen_mode: bool = false,
    udp_mode: bool = false,
    sctp_mode: bool = false,

    // Network options
    source_addr: ?[]const u8 = null,
    source_port: ?u16 = null,
    interface: ?[]const u8 = null,
    ipv4_only: bool = false,
    ipv6_only: bool = false,

    // Timing (all values in milliseconds)
    connect_timeout: u32 = 30000,
    accept_timeout: u32 = 0,
    idle_timeout: u32 = 0,
    wait_time: u32 = 0,

    // Transfer options
    send_only: bool = false,
    recv_only: bool = false,
    close_on_eof: bool = false,
    crlf: bool = false,
    telnet: bool = false,

    // Server options
    keep_listening: bool = false,
    max_conns: u32 = 0,
    exec_command: ?[]const u8 = null,
    exec_args: std.ArrayList([]const u8),
    shell_command: ?[]const u8 = null,
    exec_redirect_stdin: bool = true,
    exec_redirect_stdout: bool = true,
    exec_redirect_stderr: bool = true,
    exec_mode: exec.ExecMode = .direct,
    /// Buffer size for client input forwarded to child stdin
    exec_stdin_buffer_size: usize = 32 * 1024,
    /// Buffer size for child stdout forwarded to client
    exec_stdout_buffer_size: usize = 64 * 1024,
    /// Buffer size for child stderr forwarded to client
    exec_stderr_buffer_size: usize = 32 * 1024,
    /// Maximum aggregate buffered bytes across exec I/O channels (0 = auto)
    exec_max_buffer_bytes: usize = 256 * 1024,
    /// Flow control pause threshold as percentage of max buffer usage
    exec_flow_pause_percent: f32 = 0.85,
    /// Flow control resume threshold as percentage of max buffer usage
    exec_flow_resume_percent: f32 = 0.60,
    /// Maximum execution duration in milliseconds (0 = unlimited)
    exec_execution_timeout_ms: u32 = 0,
    /// Idle timeout in milliseconds for exec sessions (0 = unlimited)
    exec_idle_timeout_ms: u32 = 0,
    /// Connection timeout in milliseconds for initial exec activity (0 = unlimited)
    exec_connection_timeout_ms: u32 = 0,
    bind_addr: ?[]const u8 = null,

    // Broker/Chat Mode
    broker_mode: bool = false,
    chat_mode: bool = false,
    max_clients: u32 = 50,
    chat_max_nickname_len: usize = 32,
    chat_max_message_len: usize = 1024,

    // SSL/TLS
    ssl: bool = false,
    ssl_cert: ?[]const u8 = null,
    ssl_key: ?[]const u8 = null,
    ssl_verify: bool = true,
    ssl_trustfile: ?[]const u8 = null,
    ssl_crl: ?[]const u8 = null,
    ssl_ciphers: ?[]const u8 = null,
    ssl_servername: ?[]const u8 = null,
    ssl_alpn: ?[]const u8 = null,

    // Proxy
    proxy: ?[]const u8 = null,
    proxy_type: types.ProxyType = .http,
    proxy_auth: ?[]const u8 = null,
    proxy_dns: types.ProxyDns = .none,

    // Connection control
    no_shutdown: bool = false,
    keep_source_port: bool = false,

    // Traffic shaping
    delay_ms: u32 = 0,

    // Output options
    verbose: bool = false, // Deprecated: use verbosity instead
    verbose_level: u8 = 0, // Deprecated: use verbosity instead
    verbosity: types.VerbosityLevel = .normal,
    hex_dump: bool = false,
    hex_dump_file: ?[]const u8 = null,
    hex_dump_append: bool = false,
    append_output: bool = false,
    output_file: ?[]const u8 = null,

    // Zero-I/O mode
    zero_io: bool = false,
    scan_parallel: bool = false,    // Enable parallel port scanning
    scan_workers: usize = 10,       // Number of worker threads for parallel scanning
    scan_randomize: bool = false,   // Randomize port scanning order (stealth mode)
    scan_delay_ms: u32 = 0,         // Delay between port scans in milliseconds (stealth mode)

    // Security options
    allow_dangerous: bool = false,
    require_allow_with_exec: bool = true,
    drop_privileges_user: ?[]const u8 = null,
    deny_file: ?[]const u8 = null,
    allow_file: ?[]const u8 = null,
    allow_list: std.ArrayList([]const u8),
    deny_list: std.ArrayList([]const u8),

    // Unix Domain Sockets
    unix_socket_path: ?[]const u8 = null,

    // Misc
    no_dns: bool = false,
    telemetry: bool = false,
    version_info: ?[]const u8 = null,

    // Positional arguments
    positional_args: [][]const u8 = &[_][]const u8{},

    /// Initialize a default configuration with empty ArrayLists.
    pub fn init(_: std.mem.Allocator) Config {
        return .{
            .allow_list = std.ArrayList([]const u8){},
            .deny_list = std.ArrayList([]const u8){},
            .exec_args = std.ArrayList([]const u8){},
            .positional_args = &[_][]const u8{},
        };
    }

    /// Free all dynamically allocated memory in the configuration.
    /// Must be called before Config is freed to prevent memory leaks.
    pub fn deinit(self: *Config, allocator: std.mem.Allocator) void {
        for (self.allow_list.items) |item| {
            allocator.free(item);
        }
        for (self.deny_list.items) |item| {
            allocator.free(item);
        }
        for (self.exec_args.items) |item| {
            allocator.free(item);
        }
        self.allow_list.deinit(allocator);
        self.deny_list.deinit(allocator);
        self.exec_args.deinit(allocator);
        allocator.free(self.positional_args);
    }
};

/// Build exec session runtime configuration from Config.
pub fn buildExecSessionConfig(cfg: *const Config) exec.ExecSessionConfig {
    return .{
        .buffers = .{
            .stdin_capacity = cfg.exec_stdin_buffer_size,
            .stdout_capacity = cfg.exec_stdout_buffer_size,
            .stderr_capacity = cfg.exec_stderr_buffer_size,
        },
        .timeouts = .{
            .execution_ms = cfg.exec_execution_timeout_ms,
            .idle_ms = cfg.exec_idle_timeout_ms,
            .connection_ms = cfg.exec_connection_timeout_ms,
        },
        .flow = .{
            .max_total_buffer_bytes = cfg.exec_max_buffer_bytes,
            .pause_threshold_percent = cfg.exec_flow_pause_percent,
            .resume_threshold_percent = cfg.exec_flow_resume_percent,
        },
    };
}
</file>

<file path="config/network.zig">
//! Network-related configuration validation.
//!
//! Contains helpers for proxy settings and Unix domain socket
//! validation that previously lived in the monolithic `config.zig`.

const std = @import("std");
const builtin = @import("builtin");

const config_struct = @import("config_struct.zig");
const Config = config_struct.Config;

/// Platform compatibility for Unix domain sockets.
pub const UnixSocketSupport = struct {
    pub const available = switch (builtin.os.tag) {
        .linux, .macos, .freebsd, .openbsd, .netbsd, .dragonfly => true,
        .windows => false,
        else => false,
    };

    pub fn checkSupport() UnixSocketError!void {
        if (!available) {
            return UnixSocketError.UnixSocketsNotSupported;
        }
    }
};

/// Comprehensive errors related to Unix socket configuration validation.
pub const UnixSocketError = error{
    // Path validation errors
    InvalidUnixSocketPath,
    UnixSocketPathTooLong,
    InvalidUnixSocketPathCharacters,
    UnixSocketPathContainsNull,
    UnixSocketDirectoryNotFound,
    UnixSocketPermissionDenied,

    // Platform support errors
    UnixSocketsNotSupported,
    PlatformNotSupported,
    FeatureNotAvailable,

    // Configuration conflict errors
    ConflictingUnixSocketAndTCP,
    ConflictingUnixSocketAndUDP,
    ConflictingUnixSocketAndTLS,
    ConflictingUnixSocketAndProxy,
    ConflictingUnixSocketAndBroker,
    ConflictingUnixSocketAndExec,

    // Resource and system errors
    UnixSocketResourceExhausted,
    UnixSocketSystemError,
    UnixSocketConfigurationError,
};

/// Comprehensive Unix socket configuration validation with detailed conflict detection.
pub fn validateUnixSocket(cfg: *const Config) UnixSocketError!void {
    const unix_path = cfg.unix_socket_path orelse return;

    try UnixSocketSupport.checkSupport();
    try validateUnixSocketPath(unix_path);
    try validateUnixSocketConflicts(cfg);
    try validateUnixSocketResources(cfg, unix_path);
}

/// Validate Unix socket path for length, characters, and accessibility.
fn validateUnixSocketPath(path: []const u8) UnixSocketError!void {
    if (path.len == 0) {
        return UnixSocketError.InvalidUnixSocketPath;
    }

    if (std.mem.indexOf(u8, path, "\x00") != null) {
        return UnixSocketError.UnixSocketPathContainsNull;
    }

    const MAX_UNIX_SOCKET_PATH = 107;
    if (path.len > MAX_UNIX_SOCKET_PATH) {
        return UnixSocketError.UnixSocketPathTooLong;
    }

    for (path) |byte| {
        if (byte < 32 and byte != '\t') {
            return UnixSocketError.InvalidUnixSocketPathCharacters;
        }
    }

    if (std.fs.path.dirname(path)) |parent_dir| {
        std.fs.cwd().access(parent_dir, .{}) catch |err| switch (err) {
            error.FileNotFound => return UnixSocketError.UnixSocketDirectoryNotFound,
            error.AccessDenied => return UnixSocketError.UnixSocketPermissionDenied,
            error.SystemResources => return UnixSocketError.UnixSocketResourceExhausted,
            else => return UnixSocketError.UnixSocketSystemError,
        };
    }
}

/// Validate Unix socket configuration conflicts with other features.
fn validateUnixSocketConflicts(cfg: *const Config) UnixSocketError!void {
    if (cfg.positional_args.len > 0) {
        return UnixSocketError.ConflictingUnixSocketAndTCP;
    }

    if (cfg.udp_mode) {
        return UnixSocketError.ConflictingUnixSocketAndUDP;
    }

    if (cfg.ssl) {
        return UnixSocketError.ConflictingUnixSocketAndTLS;
    }

    if (cfg.proxy != null) {
        return UnixSocketError.ConflictingUnixSocketAndProxy;
    }

    if (cfg.broker_mode or cfg.chat_mode) {
        return UnixSocketError.ConflictingUnixSocketAndBroker;
    }

    if ((cfg.exec_command != null or cfg.shell_command != null) and cfg.listen_mode) {
        try validateUnixSocketExecSecurity(cfg);
    }
}

/// Validate Unix socket resource requirements and system limits.
fn validateUnixSocketResources(cfg: *const Config, path: []const u8) UnixSocketError!void {
    _ = cfg;
    _ = path;
}

/// Validate security considerations for Unix sockets with exec mode.
fn validateUnixSocketExecSecurity(cfg: *const Config) UnixSocketError!void {
    _ = cfg;
}

test "validateUnixSocket accepts valid configurations" {
    const testing = std.testing;

    var cfg = Config.init(testing.allocator);
    defer cfg.deinit(testing.allocator);

    cfg.unix_socket_path = "/tmp/test.sock";
    if (UnixSocketSupport.available) {
        try validateUnixSocket(&cfg);
    } else {
        try testing.expectError(UnixSocketError.UnixSocketsNotSupported, validateUnixSocket(&cfg));
    }
}

test "validateUnixSocket rejects malformed paths" {
    const testing = std.testing;

    var cfg = Config.init(testing.allocator);
    defer cfg.deinit(testing.allocator);

    if (!UnixSocketSupport.available) return;

    cfg.unix_socket_path = "";
    try testing.expectError(UnixSocketError.InvalidUnixSocketPath, validateUnixSocket(&cfg));

    cfg.unix_socket_path = "/tmp/test\x00.sock";
    try testing.expectError(UnixSocketError.UnixSocketPathContainsNull, validateUnixSocket(&cfg));
}

test "validateUnixSocket identifies conflicting modes" {
    const testing = std.testing;

    var cfg = Config.init(testing.allocator);
    defer cfg.deinit(testing.allocator);

    if (!UnixSocketSupport.available) return;

    cfg.unix_socket_path = "/tmp/test.sock";

    var args = [_][]const u8{ "example.com", "80" };
    cfg.positional_args = args[0..];
    try testing.expectError(UnixSocketError.ConflictingUnixSocketAndTCP, validateUnixSocket(&cfg));
}

test "UnixSocketSupport reports platform availability" {
    const testing = std.testing;

    const expected = switch (builtin.os.tag) {
        .linux, .macos, .freebsd, .openbsd, .netbsd, .dragonfly => true,
        .windows => false,
        else => false,
    };

    try testing.expectEqual(expected, UnixSocketSupport.available);
}
</file>

<file path="config/security.zig">
//! Security-oriented configuration validation.

const std = @import("std");
const builtin = @import("builtin");

const config_struct = @import("config_struct.zig");
const Config = config_struct.Config;

/// Errors related to broker/chat mode configuration validation.
pub const BrokerChatError = error{
    /// Both --broker and --chat flags specified
    ConflictingBrokerChatModes,
    /// Broker/chat mode requires listen mode (-l flag)
    RequiresListenMode,
    /// Broker/chat mode is incompatible with exec mode (-e/-c flags)
    IncompatibleWithExecMode,
    /// Broker/chat mode is incompatible with I/O control modes (--send-only/--recv-only)
    IncompatibleWithIOControl,
    /// Maximum client limit is invalid (zero or too large)
    InvalidMaxClients,
    /// Chat nickname length limit is invalid
    InvalidNicknameLength,
    /// Chat message length limit is invalid
    InvalidMessageLength,
};

/// Validate broker/chat mode configuration for conflicts and requirements.
pub fn validateBrokerChat(cfg: *const Config) BrokerChatError!void {
    if (cfg.broker_mode and cfg.chat_mode) {
        return BrokerChatError.ConflictingBrokerChatModes;
    }

    if (!cfg.broker_mode and !cfg.chat_mode) {
        return;
    }

    if (!cfg.listen_mode) {
        return BrokerChatError.RequiresListenMode;
    }

    if (cfg.exec_command != null or cfg.shell_command != null) {
        return BrokerChatError.IncompatibleWithExecMode;
    }

    if (cfg.send_only or cfg.recv_only) {
        return BrokerChatError.IncompatibleWithIOControl;
    }

    if (cfg.max_clients == 0 or cfg.max_clients > 1000) {
        return BrokerChatError.InvalidMaxClients;
    }

    // SECURITY: Windows select() backend has FD_SETSIZE limitation (~64 on Windows)
    // Each client requires ~3 fd_set entries (read/write/error sets) plus 1 for listen socket
    // Safe limit: (FD_SETSIZE - 1) / 3  21 clients with select() backend
    // The WSAPoll backend (Windows Vista+) has no such limitation
    if (builtin.os.tag == .windows) {
        // Conservative safe limit for select() backend
        // This will be relaxed when WSAPoll backend is the default
        const windows_select_safe_limit = 20;

        if (cfg.max_clients > windows_select_safe_limit) {
            std.debug.print(
                "\n" ++
                "\n" ++
                " WARNING: Windows Connection Limit Exceeded                     \n" ++
                "\n" ++
                " Configured max_clients: {d: >3}                                   \n" ++
                " Safe limit (select):    {d: >3}                                   \n" ++
                "\n" ++
                " The Windows select() backend is limited by FD_SETSIZE (64).   \n" ++
                " Exceeding this limit may cause:                               \n" ++
                "    Silent connection failures                                 \n" ++
                "    Denial of Service conditions                              \n" ++
                "    Server instability                                         \n" ++
                "\n" ++
                " Recommendations:                                               \n" ++
                "   1. Use --max-clients {d} or less                              \n" ++
                "   2. Wait for WSAPoll backend (removes limitation)             \n" ++
                "\n" ++
                "\n",
                .{cfg.max_clients, windows_select_safe_limit, windows_select_safe_limit}
            );

            // For now, we issue a warning but don't fail
            // In a future version, we should enforce this limit or auto-switch to WSAPoll
            // Uncomment to enforce: return BrokerChatError.InvalidMaxClients;
        }
    }

    if (cfg.chat_mode) {
        if (cfg.chat_max_nickname_len == 0 or cfg.chat_max_nickname_len > 255) {
            return BrokerChatError.InvalidNicknameLength;
        }

        if (cfg.chat_max_message_len == 0 or cfg.chat_max_message_len > 65536) {
            return BrokerChatError.InvalidMessageLength;
        }
    }
}

test "validateBrokerChat enforces listen mode requirement" {
    const testing = std.testing;

    var cfg = Config.init(testing.allocator);
    defer cfg.deinit(testing.allocator);

    cfg.broker_mode = true;
    cfg.listen_mode = false;

    try testing.expectError(BrokerChatError.RequiresListenMode, validateBrokerChat(&cfg));
}

test "validateBrokerChat passes valid chat configuration" {
    const testing = std.testing;

    var cfg = Config.init(testing.allocator);
    defer cfg.deinit(testing.allocator);

    cfg.chat_mode = true;
    cfg.listen_mode = true;
    cfg.max_clients = 50;
    cfg.chat_max_nickname_len = 32;
    cfg.chat_max_message_len = 1024;

    try validateBrokerChat(&cfg);
}
</file>

<file path="config/timeout.zig">
//! Unified timeout selection for consistent behavior across all server modes.
//!
//! This module provides centralized timeout logic that respects the priority:
//! 1. Explicit user configuration (--idle-timeout flag)
//! 2. Server mode defaults (protocol-specific)
//! 3. TTY detection (interactive vs automated)
//! 4. Platform fallback (Windows always 30s, POSIX TTY-dependent)

const std = @import("std");
const posix = std.posix;
const Config = @import("config_struct.zig").Config;

/// Context for timeout selection - determines which defaults to use.
pub const TimeoutContext = enum {
    /// Client mode: wait indefinitely for server
    client_mode,
    /// TCP server: TTY-aware (infinite for interactive, 30s for automated)
    tcp_server,
    /// UDP server: 30s default (stateless protocol, short-lived connections)
    udp_server,
    /// Unix socket server: TTY-aware (same as TCP)
    unix_server,
};

/// Get timeout for bidirectional I/O based on configuration and context.
///
/// This function implements a unified timeout selection strategy that respects
/// user intent while providing sensible defaults for different server modes.
///
/// **Priority** (highest to lowest):
/// 1. **Explicit user configuration**: cfg.idle_timeout > 0 (ALWAYS honored)
/// 2. **Server mode defaults**: Protocol-specific defaults (UDP=30s, TCP/Unix=TTY-aware)
/// 3. **TTY detection**: Interactive (-1) vs automated (30s)
/// 4. **Platform fallback**: Windows always 30s (no TTY detection)
///
/// **Return Values**:
/// - `-1`: Infinite timeout (wait indefinitely)
/// - `0+`: Finite timeout in milliseconds
///
/// **Examples**:
/// ```zig
/// // Explicit timeout ALWAYS wins:
/// cfg.idle_timeout = 5000;
/// const timeout = getConnectionTimeout(cfg, .tcp_server, stdin.handle);
/// // Result: 5000 (user specified 5 seconds)
///
/// // TCP server with TTY (no explicit timeout):
/// cfg.idle_timeout = 0;
/// const timeout = getConnectionTimeout(cfg, .tcp_server, tty_handle);
/// // Result: -1 (infinite for interactive use)
///
/// // TCP server without TTY (automated):
/// cfg.idle_timeout = 0;
/// const timeout = getConnectionTimeout(cfg, .tcp_server, pipe_handle);
/// // Result: 30000 (30s deadlock prevention)
///
/// // UDP server (no explicit timeout):
/// cfg.idle_timeout = 0;
/// const timeout = getConnectionTimeout(cfg, .udp_server, null);
/// // Result: 30000 (30s for stateless protocol)
/// ```
///
/// Parameters:
/// - cfg: Configuration with idle_timeout field
/// - context: Server/client mode context (determines defaults)
/// - stdin_handle: Optional stdin handle for TTY detection (server modes only)
///
/// Returns: Timeout in milliseconds (-1 for infinite, 0+ for finite)
pub fn getConnectionTimeout(
    cfg: *const Config,
    context: TimeoutContext,
    stdin_handle: ?posix.fd_t,
) i32 {
    // Priority 1: Explicit user configuration ALWAYS wins
    // If user specifies --idle-timeout, use it regardless of mode/TTY
    if (cfg.idle_timeout > 0) {
        return @intCast(cfg.idle_timeout);
    }

    // Priority 2: Mode-specific defaults
    return switch (context) {
        // Client mode: wait indefinitely for server response
        .client_mode => -1,

        // TCP server: TTY-aware (interactive vs automated)
        .tcp_server => getTtyBasedTimeout(stdin_handle),

        // UDP server: 30s default (stateless, short-lived)
        // Changed from 1s to match TCP behavior
        .udp_server => 30000,

        // Unix socket server: TTY-aware (same as TCP)
        .unix_server => getTtyBasedTimeout(stdin_handle),
    };
}

/// Get TTY-aware timeout for server modes.
///
/// This function implements the TTY detection heuristic:
/// - **TTY (interactive)**: Infinite timeout (-1) for better UX
/// - **Non-TTY (automated)**: 30s timeout for deadlock prevention
///
/// **Rationale**:
/// - Interactive terminals: Users expect to type commands and wait indefinitely
/// - Automated scripts: Risk of deadlock if peer stops sending, cap at 30s
/// - Windows: No reliable TTY detection, always use 30s (safer default)
///
/// Parameters:
/// - stdin_handle: Optional stdin file descriptor for isatty() check
///
/// Returns: -1 for TTY (infinite), 30000 for non-TTY (30 seconds)
fn getTtyBasedTimeout(stdin_handle: ?posix.fd_t) i32 {
    if (stdin_handle) |fd| {
        const is_tty = switch (@import("builtin").os.tag) {
            .linux, .macos => posix.isatty(fd),
            .windows => false, // Windows: always treat as non-TTY (safer)
            else => false, // Other platforms: conservative default
        };
        return if (is_tty) -1 else 30000;
    }
    // No stdin handle provided: assume non-interactive
    return 30000;
}

// ============================================================================
// Tests
// ============================================================================

test "getConnectionTimeout respects explicit cfg.idle_timeout" {
    const testing = std.testing;

    var cfg = Config.init(testing.allocator);
    defer cfg.deinit(testing.allocator);

    // User specifies 5 second timeout
    cfg.idle_timeout = 5000;

    // Should use explicit value regardless of context or TTY
    try testing.expectEqual(@as(i32, 5000), getConnectionTimeout(&cfg, .client_mode, null));
    try testing.expectEqual(@as(i32, 5000), getConnectionTimeout(&cfg, .tcp_server, null));
    try testing.expectEqual(@as(i32, 5000), getConnectionTimeout(&cfg, .udp_server, null));
    try testing.expectEqual(@as(i32, 5000), getConnectionTimeout(&cfg, .unix_server, null));
}

test "getConnectionTimeout uses mode-specific defaults" {
    const testing = std.testing;

    var cfg = Config.init(testing.allocator);
    defer cfg.deinit(testing.allocator);

    // No explicit timeout set
    cfg.idle_timeout = 0;

    // Client mode: infinite
    try testing.expectEqual(@as(i32, -1), getConnectionTimeout(&cfg, .client_mode, null));

    // UDP server: 30s (changed from 1s)
    try testing.expectEqual(@as(i32, 30000), getConnectionTimeout(&cfg, .udp_server, null));

    // TCP/Unix server with no stdin: 30s
    try testing.expectEqual(@as(i32, 30000), getConnectionTimeout(&cfg, .tcp_server, null));
    try testing.expectEqual(@as(i32, 30000), getConnectionTimeout(&cfg, .unix_server, null));
}

test "getTtyBasedTimeout returns correct values" {
    const testing = std.testing;

    // No stdin handle: assume non-interactive
    try testing.expectEqual(@as(i32, 30000), getTtyBasedTimeout(null));

    // With stdin handle: depends on platform
    // On POSIX, real TTY detection would run
    // On Windows, always returns 30000
    const stdin = std.fs.File.stdin();
    const timeout = getTtyBasedTimeout(stdin.handle);

    // Timeout should be either -1 (TTY) or 30000 (non-TTY)
    try testing.expect(timeout == -1 or timeout == 30000);
}
</file>

<file path="config/tls.zig">
//! TLS configuration validation.

const std = @import("std");
const logging = @import("../util/logging.zig");
const path_safety = @import("../util/path_safety.zig");

const config_struct = @import("config_struct.zig");
const Config = config_struct.Config;

/// Errors related to TLS transfer configuration validation.
pub const TLSConfigError = error{
    // TLS configuration errors
    TlsNotEnabled,
    InvalidTlsConfiguration,
    TlsCertificateRequired,
    TlsKeyRequired,
    TlsCertificateNotFound,
    TlsKeyNotFound,
    TlsCertificateInvalid,
    TlsKeyInvalid,
    TlsCertificateKeyMismatch,

    // TLS feature conflicts
    ConflictingTlsAndUnixSocket,
    ConflictingTlsAndUdp,
    ConflictingTlsOptions,

    // TLS version and cipher errors
    UnsupportedTlsVersion,
    UnsupportedCipherSuite,
    IncompatibleTlsSettings,

    // TLS certificate validation errors
    InvalidCertificateChain,
    UntrustedCertificate,
    CertificateExpired,
    CertificateRevoked,
    PathTraversalDetected,
};

/// Comprehensive TLS configuration validation with detailed error detection.
pub fn validateTlsConfiguration(cfg: *const Config) TLSConfigError!void {
    if (!cfg.ssl) return;

    const tls = @import("../tls/tls.zig");
    if (!tls.isTlsEnabled()) {
        tls.displayTlsNotAvailableError();
        return TLSConfigError.TlsNotEnabled;
    }

    try validateTlsConflicts(cfg);
    try validateTlsCertificates(cfg);
    try validateTlsProtocolSettings(cfg);
}

/// Validate TLS configuration conflicts with other features.
fn validateTlsConflicts(cfg: *const Config) TLSConfigError!void {
    if (cfg.unix_socket_path != null) {
        return TLSConfigError.ConflictingTlsAndUnixSocket;
    }

    if (cfg.udp_mode) {
        return TLSConfigError.ConflictingTlsAndUdp;
    }

    if (cfg.ssl_verify and cfg.ssl_trustfile == null and cfg.ssl_cert == null) {
        if (!cfg.listen_mode) {
            // Allow TLS library to decide when system CA store is available.
        }
    }
}

/// Display user-friendly error messages for TLS configuration errors.
fn displayTlsConfigurationError(err: TLSConfigError, file_path: []const u8) void {
    std.debug.print("\n", .{});
    std.debug.print("\n", .{});
    std.debug.print("    TLS CONFIGURATION ERROR                             \n", .{});
    std.debug.print("                                                           \n", .{});

    switch (err) {
        TLSConfigError.TlsCertificateNotFound => {
            std.debug.print("  Certificate file not found:                             \n", .{});
            std.debug.print("  {s:<57} \n", .{file_path});
            std.debug.print("                                                           \n", .{});
            std.debug.print("  Solutions:                                               \n", .{});
            std.debug.print("   Check the file path is correct                        \n", .{});
            std.debug.print("   Use absolute path if relative path fails              \n", .{});
            std.debug.print("   Generate self-signed cert:                            \n", .{});
            std.debug.print("    openssl req -x509 -newkey rsa:2048 -keyout key.pem    \n", .{});
            std.debug.print("    -out cert.pem -days 365 -nodes                        \n", .{});
        },
        TLSConfigError.TlsKeyNotFound => {
            std.debug.print("  Private key file not found:                             \n", .{});
            std.debug.print("  {s:<57} \n", .{file_path});
            std.debug.print("                                                           \n", .{});
            std.debug.print("  Solutions:                                               \n", .{});
            std.debug.print("   Check the file path is correct                        \n", .{});
            std.debug.print("   Use absolute path if relative path fails              \n", .{});
            std.debug.print("   Ensure the key file matches the certificate           \n", .{});
        },
        TLSConfigError.TlsCertificateInvalid => {
            std.debug.print("  Certificate file access denied:                         \n", .{});
            std.debug.print("  {s:<57} \n", .{file_path});
            std.debug.print("                                                           \n", .{});
            std.debug.print("  Solutions:                                               \n", .{});
            std.debug.print("   Check file permissions (should be readable)           \n", .{});
            std.debug.print("   Run: chmod 644 {s:<35} \n", .{file_path});
        },
        TLSConfigError.TlsKeyInvalid => {
            std.debug.print("  Private key file access denied:                         \n", .{});
            std.debug.print("  {s:<57} \n", .{file_path});
            std.debug.print("                                                           \n", .{});
            std.debug.print("  Solutions:                                               \n", .{});
            std.debug.print("   Check file permissions (should be readable)           \n", .{});
            std.debug.print("   Run: chmod 600 {s:<35} \n", .{file_path});
            std.debug.print("   Ensure only owner can read private keys               \n", .{});
        },
        TLSConfigError.PathTraversalDetected => {
            std.debug.print("  Unsafe TLS file path detected:                          \n", .{});
            std.debug.print("  {s:<57} \n", .{file_path});
            std.debug.print("                                                           \n", .{});
            std.debug.print("  Solutions:                                               \n", .{});
            std.debug.print("   Remove any '../' components from the path             \n", .{});
            std.debug.print("   Use a path within the current working directory       \n", .{});
            std.debug.print("   Specify an absolute path you trust explicitly         \n", .{});
        },
        else => {
            std.debug.print("  TLS configuration error: {any}                          \n", .{err});
            std.debug.print("  File: {s:<50} \n", .{file_path});
        },
    }

    std.debug.print("\n", .{});
    std.debug.print("\n", .{});
}

/// Validate TLS certificate and key configuration.
fn validateTlsCertificates(cfg: *const Config) TLSConfigError!void {
    if (cfg.listen_mode) {
        if (cfg.ssl_cert == null) {
            return TLSConfigError.TlsCertificateRequired;
        }
        if (cfg.ssl_key == null) {
            return TLSConfigError.TlsKeyRequired;
        }

        if (cfg.ssl_cert) |cert_path| {
            ensureSafeTlsPath(cert_path) catch {
                displayTlsConfigurationError(TLSConfigError.PathTraversalDetected, cert_path);
                return TLSConfigError.PathTraversalDetected;
            };
            std.fs.cwd().access(cert_path, .{ .mode = .read_only }) catch |err| switch (err) {
                error.FileNotFound => {
                    displayTlsConfigurationError(TLSConfigError.TlsCertificateNotFound, cert_path);
                    return TLSConfigError.TlsCertificateNotFound;
                },
                error.AccessDenied => {
                    displayTlsConfigurationError(TLSConfigError.TlsCertificateInvalid, cert_path);
                    return TLSConfigError.TlsCertificateInvalid;
                },
                else => return TLSConfigError.InvalidTlsConfiguration,
            };
        }

        if (cfg.ssl_key) |key_path| {
            ensureSafeTlsPath(key_path) catch {
                displayTlsConfigurationError(TLSConfigError.PathTraversalDetected, key_path);
                return TLSConfigError.PathTraversalDetected;
            };
            std.fs.cwd().access(key_path, .{ .mode = .read_only }) catch |err| switch (err) {
                error.FileNotFound => {
                    displayTlsConfigurationError(TLSConfigError.TlsKeyNotFound, key_path);
                    return TLSConfigError.TlsKeyNotFound;
                },
                error.AccessDenied => {
                    displayTlsConfigurationError(TLSConfigError.TlsKeyInvalid, key_path);
                    return TLSConfigError.TlsKeyInvalid;
                },
                else => return TLSConfigError.InvalidTlsConfiguration,
            };
        }
    }

    if (cfg.ssl_trustfile) |trust_path| {
        ensureSafeTlsPath(trust_path) catch {
            displayTlsConfigurationError(TLSConfigError.PathTraversalDetected, trust_path);
            return TLSConfigError.PathTraversalDetected;
        };
        std.fs.cwd().access(trust_path, .{ .mode = .read_only }) catch |err| switch (err) {
            error.FileNotFound => return TLSConfigError.UntrustedCertificate,
            error.AccessDenied => return TLSConfigError.InvalidTlsConfiguration,
            else => return TLSConfigError.InvalidTlsConfiguration,
        };
    }

    if (cfg.ssl_crl) |crl_path| {
        ensureSafeTlsPath(crl_path) catch {
            displayTlsConfigurationError(TLSConfigError.PathTraversalDetected, crl_path);
            return TLSConfigError.PathTraversalDetected;
        };
    }
}

/// Validate TLS protocol version and cipher suite settings.
fn validateTlsProtocolSettings(cfg: *const Config) TLSConfigError!void {
    if (cfg.ssl_ciphers) |ciphers| {
        if (ciphers.len == 0) {
            return TLSConfigError.UnsupportedCipherSuite;
        }
    }

    if (cfg.ssl_alpn) |alpn| {
        if (alpn.len == 0) {
            return TLSConfigError.IncompatibleTlsSettings;
        }
    }

    if (!cfg.listen_mode and cfg.ssl_servername != null) {
        if (cfg.ssl_servername.?.len == 0) {
            return TLSConfigError.InvalidTlsConfiguration;
        }
    }
}

fn ensureSafeTlsPath(path: []const u8) TLSConfigError!void {
    if (!path_safety.isSafePath(path)) {
        return TLSConfigError.PathTraversalDetected;
    }
}

test "validateTlsConfiguration no-op when TLS disabled" {
    const testing = std.testing;

    var cfg = Config.init(testing.allocator);
    defer cfg.deinit(testing.allocator);

    cfg.ssl = false;
    try validateTlsConfiguration(&cfg);
}

test "validateTlsProtocolSettings detects invalid inputs" {
    const testing = std.testing;

    var cfg = Config.init(testing.allocator);
    defer cfg.deinit(testing.allocator);

    cfg.ssl = true;
    cfg.ssl_ciphers = "";
    try testing.expectError(TLSConfigError.UnsupportedCipherSuite, validateTlsProtocolSettings(&cfg));
}
</file>

<file path="config/types.zig">
//! Shared configuration types for zigcat.
//!
//! This module defines enums that are used across multiple
//! configuration domains (network, TLS, CLI, etc).

/// Verbosity levels for controlling output detail.
///
/// Usage:
/// - quiet: No output except errors (equivalent to -q)
/// - normal: Default output (connections, warnings)
/// - verbose: Connection details, transfer stats (equivalent to -v)
/// - debug: Protocol details, hex dumps (equivalent to -vv)
/// - trace: All internal state, detailed tracing (equivalent to -vvv)
pub const VerbosityLevel = enum(u8) {
    quiet = 0, // No output except errors
    normal = 1, // Default (connections, warnings)
    verbose = 2, // -v (connection details)
    debug = 3, // -vv (protocol details)
    trace = 4, // -vvv (all internal state)
};

/// Proxy protocol types supported by zigcat.
pub const ProxyType = enum {
    /// HTTP CONNECT proxy (most common)
    http,
    /// SOCKS4 proxy protocol
    socks4,
    /// SOCKS5 proxy protocol
    socks5,
};

/// DNS resolution modes for proxy connections.
pub const ProxyDns = enum {
    /// No DNS resolution through proxy
    none,
    /// Resolve DNS locally before connecting to proxy
    local,
    /// Resolve DNS remotely via proxy
    remote,
    /// Support both local and remote resolution
    both,
};
</file>

<file path="config/validator.zig">
//! Top-level configuration validation orchestration.

const std = @import("std");

const config_struct = @import("config_struct.zig");
const Config = config_struct.Config;

const cli = @import("cli.zig");
const network = @import("network.zig");
const tls = @import("tls.zig");
const security_cfg = @import("security.zig");

/// Comprehensive configuration validation including I/O, TLS, Unix sockets,
/// exec mode checks, broker/chat enforcement, and basic conflict detection.
pub fn validate(cfg: *const Config) !void {
    const security = @import("../util/security.zig");

    try cli.validateIOControl(cfg);
    try security_cfg.validateBrokerChat(cfg);
    try network.validateUnixSocket(cfg);
    try tls.validateTlsConfiguration(cfg);

    if (cfg.ssl) {
        if (cfg.listen_mode and cfg.ssl_cert == null) {
            return error.SslCertRequired;
        }
    }

    if (cfg.exec_command != null or cfg.shell_command != null) {
        const exec_prog = cfg.exec_command orelse cfg.shell_command.?;

        security.displayExecWarning(exec_prog, cfg.allow_list.items.len);

        const is_unix_socket = cfg.unix_socket_path != null;

        if (cfg.listen_mode and cfg.require_allow_with_exec and !is_unix_socket) {
            try security.validateExecSecurity(
                exec_prog,
                cfg.allow_list.items.len,
                cfg.require_allow_with_exec,
            );
        }

        if (cfg.listen_mode and !cfg.allow_dangerous and !is_unix_socket) {
            std.debug.print("Warning: -e/-c with -l is dangerous. Use --allow to permit.\n", .{});
            return error.DangerousOperation;
        }
    }

    if (cfg.udp_mode and cfg.sctp_mode) {
        return error.ConflictingModes;
    }

    if (cfg.ipv4_only and cfg.ipv6_only) {
        return error.ConflictingAddressFamilies;
    }
}
</file>

<file path="io/hexdump/formatter.zig">
//! Hex dump formatting logic
//!
//! Provides formatting functions for converting binary data into
//! traditional hexdump format with offset, hex bytes, and ASCII sidebar.

const std = @import("std");

/// Format a single line of hex dump output.
///
/// Internal function that formats up to 16 bytes of data in hex dump format:
/// - 8-digit hex offset
/// - 16 hex bytes (in two groups of 8)
/// - ASCII sidebar with printable characters
///
/// Format: "00000000  48 65 6c 6c 6f 20 57 6f  72 6c 64 21 0a 00 00 00  |Hello World!....|"
///
/// Parameters:
///   - data: Up to 16 bytes of data to format
///   - offset: Byte offset to display for this line
///   - buffer: Fixed-size buffer to write formatted line into
///
/// Returns:
///   Slice of the buffer containing the formatted line
pub fn formatHexLine(data: []const u8, offset: u64, buffer: []u8) ![]const u8 {
    var stream = std.io.fixedBufferStream(buffer);
    const writer = stream.writer();

    // Write offset (8 hex digits)
    try writer.print("{x:0>8}  ", .{offset});

    // Write hex bytes (16 bytes max, 2 groups of 8)
    var i: usize = 0;
    while (i < 16) {
        if (i < data.len) {
            try writer.print("{x:0>2} ", .{data[i]});
        } else {
            try writer.print("   ", .{});
        }

        // Add extra space after 8th byte
        if (i == 7) {
            try writer.print(" ", .{});
        }
        i += 1;
    }

    // Write ASCII representation
    try writer.print(" |", .{});
    for (data) |byte| {
        const ascii_char = if (std.ascii.isPrint(byte)) byte else '.';
        try writer.print("{c}", .{ascii_char});
    }

    // Pad ASCII section if needed
    i = data.len;
    while (i < 16) {
        try writer.print(" ", .{});
        i += 1;
    }

    try writer.print("|\n", .{});

    return stream.getWritten();
}
</file>

<file path="io/hexdump/output.zig">
//! Hex dump output operations
//!
//! Handles writing formatted hex dump data to stdout and files,
//! including error handling and file management.

const std = @import("std");
const config = @import("../../config.zig");

/// Map filesystem errors to specific IOControlError types for hex dump operations.
///
/// This function provides detailed error classification and logging for hex dump file operations,
/// helping users understand what went wrong and how to fix it.
///
/// Parameters:
///   err: The original filesystem error
///   path: File path that caused the error (for logging)
///   operation: Description of the operation that failed
///
/// Returns: Appropriate IOControlError based on the original error
pub fn mapHexDumpFileError(err: anyerror, path: []const u8, operation: []const u8) config.IOControlError {
    // Suppress debug output during tests to avoid contaminating test output
    const is_test = @import("builtin").is_test;

    switch (err) {
        error.AccessDenied => {
            if (!is_test) {
                std.debug.print("Error: Permission denied to {s} hex dump file '{s}'\n", .{ operation, path });
                std.debug.print("  Try: chmod +w '{s}' or run with appropriate permissions\n", .{path});
            }
            return config.IOControlError.InsufficientPermissions;
        },
        error.FileNotFound => {
            if (!is_test) {
                std.debug.print("Error: Directory not found for hex dump file '{s}'\n", .{path});
                std.debug.print("  Try: mkdir -p '{s}'\n", .{std.fs.path.dirname(path) orelse "."});
            }
            return config.IOControlError.DirectoryNotFound;
        },
        error.IsDir => {
            if (!is_test) {
                std.debug.print("Error: Hex dump path '{s}' is a directory, not a file\n", .{path});
            }
            return config.IOControlError.IsDirectory;
        },
        error.NoSpaceLeft => {
            if (!is_test) {
                std.debug.print("Error: No space left on device for hex dump file '{s}'\n", .{path});
                std.debug.print("  Try: Free up disk space or choose a different location\n", .{});
            }
            return config.IOControlError.DiskFull;
        },
        error.FileBusy, error.ResourceBusy => {
            if (!is_test) {
                std.debug.print("Error: Hex dump file '{s}' is locked by another process\n", .{path});
                std.debug.print("  Try: Close other applications using this file\n", .{});
            }
            return config.IOControlError.FileLocked;
        },
        error.NameTooLong => {
            if (!is_test) {
                std.debug.print("Error: Hex dump file path '{s}' is too long\n", .{path});
            }
            return config.IOControlError.PathTooLong;
        },
        error.InvalidUtf8, error.BadPathName => {
            if (!is_test) {
                std.debug.print("Error: Hex dump file path '{s}' contains invalid characters\n", .{path});
            }
            return config.IOControlError.InvalidPathCharacters;
        },
        error.NotDir => {
            if (!is_test) {
                std.debug.print("Error: Parent directory in path '{s}' is not a directory\n", .{path});
            }
            return config.IOControlError.DirectoryNotFound;
        },
        error.DeviceBusy, error.SystemResources => {
            if (!is_test) {
                std.debug.print("Error: System resources unavailable for hex dump file '{s}'\n", .{path});
            }
            return config.IOControlError.FileSystemError;
        },
        else => {
            if (!is_test) {
                std.debug.print("Error: Failed to {s} hex dump file '{s}': {any}\n", .{ operation, path, err });
            }
            return config.IOControlError.HexDumpFileCreateFailed;
        },
    }
}

/// Write formatted hex dump line to stdout and optional file.
///
/// Outputs a formatted hex dump line to both stdout (unless testing)
/// and to a file if one is provided.
///
/// Parameters:
///   - formatted_line: Formatted hex dump line to output
///   - file: Optional file to write to
///   - path: Optional file path (for error reporting)
///
/// Errors:
///   - Various IOControlErrors if file write fails
pub fn writeHexLine(formatted_line: []const u8, file: ?std.fs.File, path: ?[]const u8) !void {
    // Suppress stdout during tests to avoid contaminating test output
    const is_test = @import("builtin").is_test;
    if (!is_test) {
        // Write to stdout
        std.debug.print("{s}", .{formatted_line});
    }

    // Write to file if configured
    if (file) |f| {
        f.writeAll(formatted_line) catch |err| {
            if (path) |p| {
                return mapHexDumpFileError(err, p, "write");
            } else {
                return config.IOControlError.HexDumpFileWriteFailed;
            }
        };
    }
}

/// Open a file for hex dump output.
///
/// Creates a new file (truncating if it exists) for hex dump output.
///
/// Parameters:
///   - path: File path to create
///
/// Returns:
///   Opened file handle
///
/// Errors:
///   - InvalidOutputPath: Empty path string
///   - Various IOControlErrors from mapHexDumpFileError()
pub fn openHexDumpFile(path: []const u8) !std.fs.File {
    // Validate path is not empty
    if (path.len == 0) {
        return config.IOControlError.InvalidOutputPath;
    }

    // Create the hex dump file, truncating if it exists
    const file = std.fs.cwd().createFile(path, .{
        .read = false,
        .truncate = true,
        .exclusive = false,
    }) catch |err| {
        return mapHexDumpFileError(err, path, "create");
    };

    return file;
}

/// Flush file buffers to disk.
///
/// Forces all buffered hex dump data to be written to disk using `file.sync()`.
///
/// Parameters:
///   - file: File to flush
///   - path: File path (for error reporting)
///
/// Errors:
///   - Various IOControlErrors from mapHexDumpFileError() if sync fails
pub fn flushHexDumpFile(file: std.fs.File, path: []const u8) !void {
    file.sync() catch |err| {
        return mapHexDumpFileError(err, path, "flush");
    };
}
</file>

<file path="io/tls_transfer/cleanup.zig">
//! Resource cleanup helpers for TLS transfers.

const std = @import("std");

const config = @import("../../config.zig");
const tls = @import("../../tls/tls.zig");
const output = @import("../output.zig");
const hexdump = @import("../hexdump.zig");
const logging = @import("../../util/logging.zig");

/// Comprehensive resource cleanup for TLS transfer operations.
pub fn cleanupTlsTransferResources(
    tls_conn: ?*tls.TlsConnection,
    output_logger: ?*output.OutputLogger,
    hex_dumper: ?*hexdump.HexDumper,
    cfg: *const config.Config,
) void {
    flushOutputs(output_logger, hex_dumper, cfg);

    if (tls_conn) |conn| {
        cleanupTlsConnection(conn, cfg);
    }
}

fn cleanupTlsConnection(tls_conn: *tls.TlsConnection, cfg: *const config.Config) void {
    tls_conn.close();

    if (cfg.verbose) {
        logging.logVerbose(cfg, "TLS connection closed gracefully\n", .{});
    }

    tls_conn.deinit();
}

fn flushOutputs(
    output_logger: ?*output.OutputLogger,
    hex_dumper: ?*hexdump.HexDumper,
    cfg: *const config.Config,
) void {
    if (output_logger) |logger| {
        flushOutputLogger(logger, cfg);
    }

    if (hex_dumper) |dumper| {
        flushHexDumper(dumper, cfg);
    }
}

fn flushOutputLogger(logger: *output.OutputLogger, cfg: *const config.Config) void {
    var retry_count: u8 = 0;
    const max_retries: u8 = 3;

    while (retry_count < max_retries) {
        logger.flush() catch |err| {
            retry_count += 1;
            switch (err) {
                config.IOControlError.DiskFull => {
                    logging.log(1, "Critical: Output file flush failed - disk full. Data may be lost.\n", .{});
                    return;
                },
                config.IOControlError.InsufficientPermissions => {
                    logging.log(1, "Critical: Output file flush failed - permission denied. Data may be lost.\n", .{});
                    return;
                },
                config.IOControlError.FileLocked => {
                    if (retry_count < max_retries) {
                        if (cfg.verbose) {
                            logging.logVerbose(cfg, "Warning: Output file locked, retrying flush ({any}/{any})\n", .{ retry_count, max_retries });
                        }
                        std.Thread.sleep(100_000_000);
                        continue;
                    } else {
                        logging.log(1, "Critical: Output file flush failed - file locked after {any} retries\n", .{max_retries});
                        return;
                    }
                },
                else => {
                    if (cfg.verbose) {
                        logging.logVerbose(cfg, "Warning: Failed to flush output file (attempt {any}/{any}): {any}\n", .{ retry_count, max_retries, err });
                    }
                    if (retry_count < max_retries) {
                        std.Thread.sleep(50_000_000);
                        continue;
                    } else {
                        logging.log(1, "Warning: Output file flush failed after {any} retries\n", .{max_retries});
                        return;
                    }
                },
            }
        };

        return;
    }
}

fn flushHexDumper(dumper: *hexdump.HexDumper, cfg: *const config.Config) void {
    var retry_count: u8 = 0;
    const max_retries: u8 = 3;

    while (retry_count < max_retries) {
        dumper.flush() catch |err| {
            retry_count += 1;
            switch (err) {
                config.IOControlError.DiskFull => {
                    logging.log(1, "Critical: Hex dump file flush failed - disk full. Data may be lost.\n", .{});
                    return;
                },
                config.IOControlError.InsufficientPermissions => {
                    logging.log(1, "Critical: Hex dump file flush failed - permission denied. Data may be lost.\n", .{});
                    return;
                },
                config.IOControlError.FileLocked => {
                    if (retry_count < max_retries) {
                        if (cfg.verbose) {
                            logging.logVerbose(cfg, "Warning: Hex dump file locked, retrying flush ({any}/{any})\n", .{ retry_count, max_retries });
                        }
                        std.Thread.sleep(100_000_000);
                        continue;
                    } else {
                        logging.log(1, "Critical: Hex dump file flush failed - file locked after {any} retries\n", .{max_retries});
                        return;
                    }
                },
                else => {
                    if (cfg.verbose) {
                        logging.logVerbose(cfg, "Warning: Failed to flush hex dump file (attempt {any}/{any}): {any}\n", .{ retry_count, max_retries, err });
                    }
                    if (retry_count < max_retries) {
                        std.Thread.sleep(50_000_000);
                        continue;
                    } else {
                        logging.log(1, "Warning: Hex dump file flush failed after {any} retries\n", .{max_retries});
                        return;
                    }
                },
            }
        };

        return;
    }
}

// -----------------------------------------------------------------------------+
// Tests                                                                         |
// -----------------------------------------------------------------------------+

test "cleanup handles null resources" {
    var cfg = config.Config.init(std.testing.allocator);
    defer cfg.deinit(std.testing.allocator);
    cfg.verbose = true;

    cleanupTlsTransferResources(null, null, null, &cfg);

    cfg.verbose = false;
    cleanupTlsTransferResources(null, null, null, &cfg);
}
</file>

<file path="io/tls_transfer/errors.zig">
//! TLS transfer error mapping, messaging, and logging helpers.

const std = @import("std");

const config = @import("../../config.zig");
const logging = @import("../../util/logging.zig");

/// Comprehensive error set for TLS transfer operations.
pub const TLSTransferError = error{
    // Protocol errors
    AlertReceived,
    InvalidState,
    HandshakeFailed,
    HandshakeIncomplete,
    ProtocolVersionMismatch,
    CipherSuiteNegotiationFailed,
    UnexpectedMessage,
    InvalidRecord,
    RecordTooLarge,

    // Certificate errors
    CertificateVerificationFailed,
    UntrustedCertificate,
    CertificateExpired,
    CertificateRevoked,
    InvalidCertificate,
    CertificateChainTooLong,
    UnknownCA,

    // Buffer/memory errors
    BufferTooSmall,
    OutOfMemory,
    InsufficientBuffer,

    // Network errors
    ConnectionClosed,
    ConnectionReset,
    ConnectionAborted,
    NetworkTimeout,
    WouldBlock,

    // Configuration errors
    TlsNotEnabled,
    InvalidConfiguration,
    UnsupportedFeature,
    IncompatibleVersion,

    // Resource errors
    ResourceExhausted,
    TooManyConnections,
    SystemError,
};

/// Map backend errors to transfer error classification.
pub fn mapTlsError(err: anyerror) TLSTransferError {
    return switch (err) {
        error.AlertReceived => TLSTransferError.AlertReceived,
        error.InvalidState => TLSTransferError.InvalidState,
        error.HandshakeFailed => TLSTransferError.HandshakeFailed,
        error.CertificateVerificationFailed => TLSTransferError.CertificateVerificationFailed,
        error.BufferTooSmall => TLSTransferError.BufferTooSmall,
        error.TlsNotEnabled => TLSTransferError.TlsNotEnabled,
        error.WouldBlock => TLSTransferError.WouldBlock,
        error.ProtocolVersionMismatch => TLSTransferError.ProtocolVersionMismatch,
        error.CipherSuiteNegotiationFailed => TLSTransferError.CipherSuiteNegotiationFailed,
        error.UnexpectedMessage => TLSTransferError.UnexpectedMessage,
        error.InvalidStateTransition => TLSTransferError.InvalidState,
        error.InvalidRecord => TLSTransferError.InvalidRecord,
        error.RecordOverflow => TLSTransferError.RecordTooLarge,
        error.CertificateExpired => TLSTransferError.CertificateExpired,
        error.CertificateRevoked => TLSTransferError.CertificateRevoked,
        error.InvalidCertificate => TLSTransferError.InvalidCertificate,
        error.CertificateChainTooLong => TLSTransferError.CertificateChainTooLong,
        error.UnknownIssuer => TLSTransferError.UnknownCA,
        error.ConnectionResetByPeer => TLSTransferError.ConnectionReset,
        error.ConnectionAborted => TLSTransferError.ConnectionAborted,
        error.BrokenPipe => TLSTransferError.ConnectionClosed,
        error.Timeout => TLSTransferError.NetworkTimeout,
        error.OutOfMemory => TLSTransferError.OutOfMemory,
        error.OutOfRange => TLSTransferError.InvalidConfiguration,
        error.UnsupportedFeature => TLSTransferError.UnsupportedFeature,
        error.UnsupportedVersion => TLSTransferError.IncompatibleVersion,
        error.SystemResources => TLSTransferError.ResourceExhausted,
        error.ProcessFdQuotaExceeded, error.SystemFdQuotaExceeded => TLSTransferError.TooManyConnections,
        else => TLSTransferError.SystemError,
    };
}

/// Provide user-friendly messages for TLS transfer errors.
pub fn getTlsErrorMessage(err: TLSTransferError, operation: []const u8) []const u8 {
    _ = operation;
    return switch (err) {
        TLSTransferError.AlertReceived => "TLS alert received from peer - connection terminated",
        TLSTransferError.InvalidState => "TLS connection in invalid state - handshake may be incomplete",
        TLSTransferError.HandshakeFailed => "TLS handshake failed - certificate or protocol issue",
        TLSTransferError.HandshakeIncomplete => "TLS handshake not yet complete",
        TLSTransferError.ProtocolVersionMismatch => "TLS protocol version mismatch",
        TLSTransferError.CipherSuiteNegotiationFailed => "Failed to negotiate TLS cipher suite",
        TLSTransferError.UnexpectedMessage => "Received unexpected TLS message",
        TLSTransferError.InvalidRecord => "Invalid TLS record format",
        TLSTransferError.RecordTooLarge => "TLS record exceeds maximum size",

        TLSTransferError.CertificateVerificationFailed => "TLS certificate verification failed",
        TLSTransferError.UntrustedCertificate => "TLS certificate is not trusted",
        TLSTransferError.CertificateExpired => "TLS certificate has expired",
        TLSTransferError.CertificateRevoked => "TLS certificate has been revoked",
        TLSTransferError.InvalidCertificate => "TLS certificate is invalid or malformed",
        TLSTransferError.CertificateChainTooLong => "TLS certificate chain is too long",
        TLSTransferError.UnknownCA => "TLS certificate signed by unknown CA",

        TLSTransferError.BufferTooSmall => "Buffer too small for TLS record",
        TLSTransferError.OutOfMemory => "Out of memory during TLS operation",
        TLSTransferError.InsufficientBuffer => "Insufficient buffer space for TLS data",

        TLSTransferError.ConnectionClosed => "TLS connection closed by peer",
        TLSTransferError.ConnectionReset => "TLS connection reset by peer",
        TLSTransferError.ConnectionAborted => "TLS connection aborted",
        TLSTransferError.NetworkTimeout => "TLS operation timed out",
        TLSTransferError.WouldBlock => "TLS operation would block",

        TLSTransferError.TlsNotEnabled => "TLS support not enabled at build time",
        TLSTransferError.InvalidConfiguration => "Invalid TLS configuration",
        TLSTransferError.UnsupportedFeature => "TLS feature not supported",
        TLSTransferError.IncompatibleVersion => "Incompatible TLS version",

        TLSTransferError.ResourceExhausted => "System resources exhausted for TLS",
        TLSTransferError.TooManyConnections => "Too many TLS connections",
        TLSTransferError.SystemError => "System error during TLS operation",
    };
}

/// Identify which TLS errors can be retried.
pub fn isTlsErrorRecoverable(err: TLSTransferError) bool {
    return switch (err) {
        TLSTransferError.WouldBlock => true,
        TLSTransferError.BufferTooSmall => true,
        TLSTransferError.NetworkTimeout => true,
        else => false,
    };
}

/// Handle TLS errors: log context and return classification.
pub fn handleTlsError(err: anyerror, operation: []const u8, cfg: *const config.Config) TLSTransferError {
    const tls_err = mapTlsError(err);
    const error_msg = getTlsErrorMessage(tls_err, operation);
    const recoverable = isTlsErrorRecoverable(tls_err);

    if (!@import("builtin").is_test) {
        if (cfg.verbose) {
            logging.logVerbose(cfg, "TLS {s} error: {s}\n", .{ operation, error_msg });
            switch (tls_err) {
                TLSTransferError.HandshakeFailed => {
                    logging.logVerbose(cfg, "Suggestion: Check certificate validity, cipher suite compatibility, and TLS version support\n", .{});
                },
                TLSTransferError.CertificateVerificationFailed => {
                    logging.logVerbose(cfg, "Suggestion: Verify certificate chain, check system time, or use --ssl-verify=false for testing\n", .{});
                },
                TLSTransferError.InvalidState => {
                    logging.logVerbose(cfg, "Suggestion: Ensure TLS handshake completed before attempting data transfer\n", .{});
                },
                TLSTransferError.BufferTooSmall => {
                    logging.logVerbose(cfg, "Suggestion: This is usually handled automatically - may indicate memory constraints\n", .{});
                },
                TLSTransferError.TlsNotEnabled => {
                    logging.logVerbose(cfg, "Suggestion: Rebuild with TLS support enabled or use plain TCP connection\n", .{});
                },
                TLSTransferError.NetworkTimeout => {
                    logging.logVerbose(cfg, "Suggestion: Check network connectivity or increase timeout values\n", .{});
                },
                TLSTransferError.ConnectionReset, TLSTransferError.ConnectionClosed => {
                    logging.logVerbose(cfg, "Suggestion: Peer closed connection - this may be normal or indicate protocol mismatch\n", .{});
                },
                else => {},
            }

            if (recoverable) {
                logging.logVerbose(cfg, "Note: This error is recoverable - operation will be retried\n", .{});
            } else {
                logging.logVerbose(cfg, "Note: This error requires connection termination\n", .{});
            }
        } else {
            if (recoverable) {
                logging.logWarning("TLS {s} warning: {s} (retrying)\n", .{ operation, error_msg });
            } else {
                logging.log(1, "TLS {s} error: {s}\n", .{ operation, error_msg });
            }
        }
    }

    return tls_err;
}

/// Handle output file errors with appropriate logging and recovery suggestions.
pub fn handleOutputError(err: anyerror, cfg: *const config.Config, operation: []const u8) void {
    if (@import("builtin").is_test) return;

    switch (err) {
        config.IOControlError.DiskFull => {
            logging.log(1, "Error: Disk full - stopping {s} to prevent data loss\n", .{operation});
        },
        config.IOControlError.InsufficientPermissions => {
            logging.log(1, "Error: Permission denied - stopping {s}\n", .{operation});
        },
        else => {
            if (cfg.verbose) {
                logging.logVerbose(cfg, "Warning: {s} failed: {any}\n", .{ operation, err });
            }
        },
    }
}

/// Print data as hex dump to stdout with ASCII sidebar.
pub fn printHexDump(data: []const u8) void {
    if (@import("builtin").is_test) return;

    var i: usize = 0;
    while (i < data.len) : (i += 16) {
        logging.log(1, "{x:0>8}: ", .{i});

        var j: usize = 0;
        while (j < 16) : (j += 1) {
            if (i + j < data.len) {
                logging.log(1, "{x:0>2} ", .{data[i + j]});
            } else {
                logging.log(1, "   ", .{});
            }
        }

        logging.log(1, " |", .{});

        j = 0;
        while (j < 16 and i + j < data.len) : (j += 1) {
            const c = data[i + j];
            if (c >= 32 and c <= 126) {
                logging.log(1, "{c}", .{c});
            } else {
                logging.log(1, ".", .{});
            }
        }

        logging.log(1, "|\n", .{});
    }
}

// -----------------------------------------------------------------------------+
// Tests                                                                         |
// -----------------------------------------------------------------------------+

test "TLS error mapping and recoverability" {
    const mapped_err = mapTlsError(error.AlertReceived);
    try std.testing.expectEqual(TLSTransferError.AlertReceived, mapped_err);

    const network_err = mapTlsError(error.ConnectionResetByPeer);
    try std.testing.expectEqual(TLSTransferError.ConnectionReset, network_err);

    const memory_err = mapTlsError(error.OutOfMemory);
    try std.testing.expectEqual(TLSTransferError.OutOfMemory, memory_err);

    try std.testing.expect(isTlsErrorRecoverable(TLSTransferError.WouldBlock));
    try std.testing.expect(isTlsErrorRecoverable(TLSTransferError.BufferTooSmall));
    try std.testing.expect(!isTlsErrorRecoverable(TLSTransferError.HandshakeFailed));
}

test "TLS error messaging" {
    const alert_msg = getTlsErrorMessage(TLSTransferError.AlertReceived, "read");
    try std.testing.expect(alert_msg.len > 0);

    const handshake_msg = getTlsErrorMessage(TLSTransferError.HandshakeFailed, "write");
    try std.testing.expect(handshake_msg.len > 0);

    const cert_msg = getTlsErrorMessage(TLSTransferError.CertificateVerificationFailed, "connect");
    try std.testing.expect(cert_msg.len > 0);
}

test "handleTlsError returns mapped error" {
    var cfg = config.Config.init(std.testing.allocator);
    defer cfg.deinit(std.testing.allocator);
    cfg.verbose = false;

    const alert_err = handleTlsError(error.AlertReceived, "test", &cfg);
    try std.testing.expect(alert_err == TLSTransferError.AlertReceived);

    const invalid_err = handleTlsError(error.InvalidState, "test", &cfg);
    try std.testing.expect(invalid_err == TLSTransferError.InvalidState);
}

test "handleOutputError tolerates errors" {
    var cfg = config.Config.init(std.testing.allocator);
    defer cfg.deinit(std.testing.allocator);
    cfg.verbose = true;

    handleOutputError(config.IOControlError.DiskFull, &cfg, "test operation");
    handleOutputError(error.OutOfMemory, &cfg, "test operation");
}

test "printHexDump handles sample data" {
    printHexDump("Hello, World!\x00\x01\x02");
    printHexDump("");
}
</file>

<file path="io/tls_transfer/test_utils.zig">
//! Testing utilities for TLS transfer modules.

const std = @import("std");

const errors = @import("errors.zig");

pub const MockTlsConnection = struct {
    allocator: std.mem.Allocator,
    behavior: Behavior,
    read_data: std.ArrayList(u8),
    write_data: std.ArrayList(u8),
    read_position: usize,
    error_on_operation: ?ErrorTrigger,
    call_count: CallCount,
    state: ConnectionState,

    pub const Behavior = enum {
        normal,
        slow_read,
        slow_write,
        error_on_read,
        error_on_write,
        would_block_then_success,
        alert_received,
        invalid_state,
        handshake_incomplete,
        connection_closed,
    };

    pub const ErrorTrigger = struct {
        operation: enum { read, write, close, deinit },
        after_calls: u32,
        error_type: errors.TLSTransferError,
    };

    pub const CallCount = struct {
        read: u32 = 0,
        write: u32 = 0,
        close: u32 = 0,
        deinit: u32 = 0,
    };

    pub const ConnectionState = enum {
        connected,
        closed,
        error_state,
    };

    pub fn init(allocator: std.mem.Allocator, behavior: Behavior) !*MockTlsConnection {
        const mock = try allocator.create(MockTlsConnection);
        mock.* = .{
            .allocator = allocator,
            .behavior = behavior,
            .read_data = try std.ArrayList(u8).initCapacity(allocator, 0),
            .write_data = try std.ArrayList(u8).initCapacity(allocator, 0),
            .read_position = 0,
            .error_on_operation = null,
            .call_count = .{},
            .state = .connected,
        };
        return mock;
    }

    pub fn deinit(self: *MockTlsConnection) void {
        self.call_count.deinit += 1;

        if (self.error_on_operation) |trigger| {
            if (trigger.operation == .deinit and self.call_count.deinit >= trigger.after_calls) {
                self.state = .error_state;
                return;
            }
        }

        self.read_data.deinit(self.allocator);
        self.write_data.deinit(self.allocator);
        self.allocator.destroy(self);
    }

    pub fn setReadData(self: *MockTlsConnection, data: []const u8) !void {
        try self.read_data.appendSlice(self.allocator, data);
    }

    pub fn getWrittenData(self: *const MockTlsConnection) []const u8 {
        return self.write_data.items;
    }

    pub fn setErrorTrigger(self: *MockTlsConnection, trigger: ErrorTrigger) void {
        self.error_on_operation = trigger;
    }

    pub fn read(self: *MockTlsConnection, buffer: []u8) !usize {
        self.call_count.read += 1;

        if (self.error_on_operation) |trigger| {
            if (trigger.operation == .read and self.call_count.read >= trigger.after_calls) {
                self.state = .error_state;
                return mapTlsTransferErrorToTlsError(trigger.error_type);
            }
        }

        if (self.state != .connected) {
            return error.InvalidState;
        }

        return switch (self.behavior) {
            .normal => self.normalRead(buffer),
            .slow_read => blk: {
                std.Thread.sleep(10 * std.time.ns_per_ms);
                break :blk self.normalRead(buffer);
            },
            .error_on_read => error.AlertReceived,
            .would_block_then_success => if (self.call_count.read == 1)
                error.WouldBlock
            else
                self.normalRead(buffer),
            .alert_received => error.AlertReceived,
            .invalid_state => error.InvalidState,
            .handshake_incomplete => error.HandshakeFailed,
            .connection_closed => {
                self.state = .closed;
                return 0;
            },
            .slow_write, .error_on_write => self.normalRead(buffer),
        };
    }

    fn normalRead(self: *MockTlsConnection, buffer: []u8) !usize {
        if (self.read_position >= self.read_data.items.len) {
            return 0;
        }

        const available = self.read_data.items.len - self.read_position;
        const to_read = @min(buffer.len, available);

        @memcpy(buffer[0..to_read], self.read_data.items[self.read_position .. self.read_position + to_read]);
        self.read_position += to_read;

        return to_read;
    }

    pub fn write(self: *MockTlsConnection, data: []const u8) !usize {
        self.call_count.write += 1;

        if (self.error_on_operation) |trigger| {
            if (trigger.operation == .write and self.call_count.write >= trigger.after_calls) {
                self.state = .error_state;
                return mapTlsTransferErrorToTlsError(trigger.error_type);
            }
        }

        if (self.state != .connected) {
            return error.InvalidState;
        }

        switch (self.behavior) {
            .normal => {
                try self.write_data.appendSlice(self.allocator, data);
                return data.len;
            },
            .slow_write => {
                std.Thread.sleep(10 * std.time.ns_per_ms);
                try self.write_data.appendSlice(self.allocator, data);
                return data.len;
            },
            .error_on_write => return error.AlertReceived,
            .would_block_then_success => {
                if (self.call_count.write == 1) {
                    return error.WouldBlock;
                } else {
                    try self.write_data.appendSlice(self.allocator, data);
                    return data.len;
                }
            },
            .alert_received => return error.AlertReceived,
            .invalid_state => return error.InvalidState,
            .handshake_incomplete => return error.HandshakeFailed,
            else => {
                try self.write_data.appendSlice(self.allocator, data);
                return data.len;
            },
        }
    }

    pub fn close(self: *MockTlsConnection) void {
        self.call_count.close += 1;

        if (self.error_on_operation) |trigger| {
            if (trigger.operation == .close and self.call_count.close >= trigger.after_calls) {
                self.state = .error_state;
                return;
            }
        }

        self.state = .closed;
    }

    fn mapTlsTransferErrorToTlsError(tls_err: errors.TLSTransferError) anyerror {
        return switch (tls_err) {
            errors.TLSTransferError.AlertReceived => error.AlertReceived,
            errors.TLSTransferError.InvalidState => error.InvalidState,
            errors.TLSTransferError.HandshakeFailed => error.HandshakeFailed,
            errors.TLSTransferError.CertificateVerificationFailed => error.CertificateVerificationFailed,
            errors.TLSTransferError.BufferTooSmall => error.BufferTooSmall,
            errors.TLSTransferError.TlsNotEnabled => error.TlsNotEnabled,
            errors.TLSTransferError.WouldBlock => error.WouldBlock,
            errors.TLSTransferError.ConnectionClosed => error.BrokenPipe,
            errors.TLSTransferError.ConnectionReset => error.ConnectionResetByPeer,
            errors.TLSTransferError.NetworkTimeout => error.Timeout,
            errors.TLSTransferError.OutOfMemory => error.OutOfMemory,
            else => error.SystemError,
        };
    }
};

/// Wrapper to make MockTlsConnection compatible with the TlsConnection interface.
pub const MockTlsConnectionWrapper = struct {
    mock: *MockTlsConnection,

    pub fn read(self: *MockTlsConnectionWrapper, buffer: []u8) !usize {
        return self.mock.read(buffer);
    }

    pub fn write(self: *MockTlsConnectionWrapper, data: []const u8) !usize {
        return self.mock.write(data);
    }

    pub fn close(self: *MockTlsConnectionWrapper) void {
        self.mock.close();
    }

    pub fn deinit(self: *MockTlsConnectionWrapper) void {
        self.mock.deinit();
    }
};
</file>

<file path="io/tls_transfer/tests.zig">
//! Consolidated tests for TLS transfer modules.

const std = @import("std");
const testing = std.testing;

const config = @import("../../config.zig");
const tls = @import("../../tls/tls.zig");
const output = @import("../output.zig");
const hexdump = @import("../hexdump.zig");

const transfer = @import("transfer.zig");
const errors = @import("errors.zig");
const test_utils = @import("test_utils.zig");

test "TLS transfer buffer size is non-zero" {
    try testing.expect(transfer.BUFFER_SIZE > 0);
}

test "tlsBidirectionalTransfer handles disabled TLS gracefully" {
    const allocator = testing.allocator;

    var tls_conn = tls.TlsConnection{
        .allocator = allocator,
        .backend = .{ .disabled = {} },
    };

    var cfg = config.Config.init(allocator);
    defer cfg.deinit(allocator);

    const read_result = tls_conn.read(&[_]u8{});
    try testing.expectError(error.TlsNotEnabled, read_result);

    const write_result = tls_conn.write(&[_]u8{});
    try testing.expectError(error.TlsNotEnabled, write_result);
}

test "TLS transfer - basic mock connection functionality" {
    const allocator = testing.allocator;

    var mock = try test_utils.MockTlsConnection.init(allocator, .normal);
    defer mock.deinit();

    const test_input = "Hello, TLS World!";
    try mock.setReadData(test_input);

    var wrapper = test_utils.MockTlsConnectionWrapper{ .mock = mock };

    var read_buffer: [1024]u8 = undefined;
    const bytes_read = try wrapper.read(&read_buffer);
    try testing.expectEqual(test_input.len, bytes_read);
    try testing.expectEqualStrings(test_input, read_buffer[0..bytes_read]);

    const test_output = "Response from client";
    const bytes_written = try wrapper.write(test_output);
    try testing.expectEqual(test_output.len, bytes_written);
    try testing.expectEqualStrings(test_output, mock.getWrittenData());
}

test "TLS transfer - AlertReceived error handling" {
    const allocator = testing.allocator;

    var mock = try test_utils.MockTlsConnection.init(allocator, .alert_received);
    defer mock.deinit();

    var wrapper = test_utils.MockTlsConnectionWrapper{ .mock = mock };

    var buffer: [1024]u8 = undefined;
    const result = wrapper.read(&buffer);
    try testing.expectError(error.AlertReceived, result);

    const tls_err = errors.mapTlsError(error.AlertReceived);
    try testing.expectEqual(errors.TLSTransferError.AlertReceived, tls_err);
    try testing.expect(!errors.isTlsErrorRecoverable(tls_err));
}

test "TLS transfer - InvalidState error handling" {
    const allocator = testing.allocator;

    var mock = try test_utils.MockTlsConnection.init(allocator, .invalid_state);
    defer mock.deinit();

    var wrapper = test_utils.MockTlsConnectionWrapper{ .mock = mock };

    const test_data = "test data";
    const result = wrapper.write(test_data);
    try testing.expectError(error.InvalidState, result);

    const tls_err = errors.mapTlsError(error.InvalidState);
    try testing.expectEqual(errors.TLSTransferError.InvalidState, tls_err);
    try testing.expect(!errors.isTlsErrorRecoverable(tls_err));
}

test "TLS transfer - WouldBlock error recovery" {
    const allocator = testing.allocator;

    var mock = try test_utils.MockTlsConnection.init(allocator, .would_block_then_success);
    defer mock.deinit();

    const test_data = "Success after WouldBlock";
    try mock.setReadData(test_data);

    var wrapper = test_utils.MockTlsConnectionWrapper{ .mock = mock };

    var buffer: [1024]u8 = undefined;
    const first_result = wrapper.read(&buffer);
    try testing.expectError(error.WouldBlock, first_result);

    const would_block_err = errors.mapTlsError(error.WouldBlock);
    try testing.expect(errors.isTlsErrorRecoverable(would_block_err));

    const second_result = try wrapper.read(&buffer);
    try testing.expectEqual(test_data.len, second_result);
    try testing.expectEqualStrings(test_data, buffer[0..second_result]);
}

test "TLS transfer - HandshakeFailed error handling" {
    const allocator = testing.allocator;

    var mock = try test_utils.MockTlsConnection.init(allocator, .handshake_incomplete);
    defer mock.deinit();

    var wrapper = test_utils.MockTlsConnectionWrapper{ .mock = mock };

    var buffer: [1024]u8 = undefined;
    const result = wrapper.read(&buffer);
    try testing.expectError(error.HandshakeFailed, result);

    const tls_err = errors.mapTlsError(error.HandshakeFailed);
    try testing.expectEqual(errors.TLSTransferError.HandshakeFailed, tls_err);
    try testing.expect(!errors.isTlsErrorRecoverable(tls_err));
}

test "TLS transfer - connection closed detection" {
    const allocator = testing.allocator;

    var mock = try test_utils.MockTlsConnection.init(allocator, .connection_closed);
    defer mock.deinit();

    var wrapper = test_utils.MockTlsConnectionWrapper{ .mock = mock };

    var buffer: [1024]u8 = undefined;
    const bytes_read = try wrapper.read(&buffer);
    try testing.expectEqual(@as(usize, 0), bytes_read);
}

test "TLS transfer - I/O control mode validation" {
    const allocator = testing.allocator;

    {
        var cfg = config.Config.init(allocator);
        defer cfg.deinit(allocator);
        cfg.send_only = true;
        cfg.recv_only = false;
        try config.validateIOControl(&cfg);
        try testing.expect(cfg.send_only);
        try testing.expect(!cfg.recv_only);
    }

    {
        var cfg = config.Config.init(allocator);
        defer cfg.deinit(allocator);
        cfg.send_only = false;
        cfg.recv_only = true;
        try config.validateIOControl(&cfg);
        try testing.expect(!cfg.send_only);
        try testing.expect(cfg.recv_only);
    }

    {
        var cfg = config.Config.init(allocator);
        defer cfg.deinit(allocator);
        cfg.send_only = true;
        cfg.recv_only = true;
        try testing.expectError(config.IOControlError.ConflictingIOModes, config.validateIOControl(&cfg));
    }
}

test "TLS transfer - timeout configuration and cleanup" {
    const allocator = testing.allocator;

    var mock = try test_utils.MockTlsConnection.init(allocator, .normal);
    defer mock.deinit();

    var wrapper = test_utils.MockTlsConnectionWrapper{ .mock = mock };

    var cfg = config.Config.init(allocator);
    defer cfg.deinit(allocator);
    cfg.idle_timeout = 5000;

    try testing.expectEqual(@as(u32, 5000), cfg.idle_timeout);

    wrapper.close();
    try testing.expectEqual(@as(u32, 1), mock.call_count.close);
    try testing.expectEqual(test_utils.MockTlsConnection.ConnectionState.closed, mock.state);
}

test "TLS transfer - comprehensive error recoverability" {
    const recoverable = [_]errors.TLSTransferError{
        errors.TLSTransferError.WouldBlock,
        errors.TLSTransferError.BufferTooSmall,
        errors.TLSTransferError.NetworkTimeout,
    };

    const fatal = [_]errors.TLSTransferError{
        errors.TLSTransferError.AlertReceived,
        errors.TLSTransferError.InvalidState,
        errors.TLSTransferError.HandshakeFailed,
        errors.TLSTransferError.CertificateVerificationFailed,
        errors.TLSTransferError.ConnectionClosed,
        errors.TLSTransferError.ConnectionReset,
        errors.TLSTransferError.TlsNotEnabled,
    };

    for (recoverable) |err| {
        try testing.expect(errors.isTlsErrorRecoverable(err));
    }

    for (fatal) |err| {
        try testing.expect(!errors.isTlsErrorRecoverable(err));
    }
}

test "TLS transfer - error message generation coverage" {
    const cases = [_]struct {
        err: errors.TLSTransferError,
        tokens: []const []const u8,
    }{
        .{ .err = errors.TLSTransferError.AlertReceived, .tokens = &[_][]const u8{ "alert", "received" } },
        .{ .err = errors.TLSTransferError.InvalidState, .tokens = &[_][]const u8{ "invalid", "state" } },
        .{ .err = errors.TLSTransferError.HandshakeFailed, .tokens = &[_][]const u8{ "handshake", "failed" } },
        .{ .err = errors.TLSTransferError.CertificateVerificationFailed, .tokens = &[_][]const u8{ "certificate", "verification" } },
        .{ .err = errors.TLSTransferError.WouldBlock, .tokens = &[_][]const u8{ "would", "block" } },
        .{ .err = errors.TLSTransferError.TlsNotEnabled, .tokens = &[_][]const u8{ "not", "enabled" } },
    };

    for (cases) |case_info| {
        const msg = errors.getTlsErrorMessage(case_info.err, "test");
        try testing.expect(msg.len > 0);

        for (case_info.tokens) |token| {
            var found = false;
            var i: usize = 0;
            while (i <= msg.len - token.len) : (i += 1) {
                if (std.ascii.eqlIgnoreCase(msg[i .. i + token.len], token)) {
                    found = true;
                    break;
                }
            }
            try testing.expect(found);
        }
    }
}

test "TLS transfer - large data handling simulation" {
    const allocator = testing.allocator;

    var mock = try test_utils.MockTlsConnection.init(allocator, .normal);
    defer mock.deinit();

    const test_size = 1024;
    const test_data = try allocator.alloc(u8, test_size);
    defer allocator.free(test_data);

    for (test_data, 0..) |*byte, i| {
        byte.* = @truncate(i & 0xFF);
    }

    try mock.setReadData(test_data);

    var wrapper = test_utils.MockTlsConnectionWrapper{ .mock = mock };

    var total_read: usize = 0;
    var buffer: [256]u8 = undefined;

    while (total_read < test_size) {
        const bytes_read = try wrapper.read(&buffer);
        if (bytes_read == 0) break;

        for (buffer[0..bytes_read], 0..) |byte, i| {
            const expected = @as(u8, @truncate((total_read + i) & 0xFF));
            try testing.expectEqual(expected, byte);
        }

        total_read += bytes_read;
    }

    try testing.expectEqual(test_size, total_read);
}

test "TLS transfer - connection state transitions" {
    const allocator = testing.allocator;

    var mock = try test_utils.MockTlsConnection.init(allocator, .normal);
    defer mock.deinit();

    var wrapper = test_utils.MockTlsConnectionWrapper{ .mock = mock };

    try testing.expectEqual(test_utils.MockTlsConnection.ConnectionState.connected, mock.state);

    const test_data = "state test";
    _ = try wrapper.write(test_data);
    try testing.expectEqual(test_utils.MockTlsConnection.ConnectionState.connected, mock.state);

    wrapper.close();
    try testing.expectEqual(test_utils.MockTlsConnection.ConnectionState.closed, mock.state);

    const result = wrapper.write("should fail");
    try testing.expectError(error.InvalidState, result);
}

test "TLS transfer - output integration with mock files" {
    const allocator = testing.allocator;

    const output_file = "test_tls_output.tmp";
    std.fs.cwd().deleteFile(output_file) catch {};
    defer std.fs.cwd().deleteFile(output_file) catch {};

    var output_logger = try output.OutputLogger.init(allocator, output_file, false);
    defer output_logger.deinit();

    const test_data = "TLS transfer test data";
    try output_logger.write(test_data);
    try output_logger.flush();

    const file = try std.fs.cwd().openFile(output_file, .{});
    defer file.close();

    const contents = try file.readToEndAlloc(allocator, 1024);
    defer allocator.free(contents);

    try testing.expectEqualStrings(test_data, contents);
}

test "TLS transfer - hex dump integration" {
    const allocator = testing.allocator;

    const hex_file = "test_tls_hexdump.tmp";
    std.fs.cwd().deleteFile(hex_file) catch {};
    defer std.fs.cwd().deleteFile(hex_file) catch {};

    var hex_dumper = try hexdump.HexDumper.init(allocator, hex_file);
    defer hex_dumper.deinit();

    const test_data = "TLS hex dump test";
    try hex_dumper.dump(test_data);
    try hex_dumper.flush();

    const file = try std.fs.cwd().openFile(hex_file, .{});
    defer file.close();

    const contents = try file.readToEndAlloc(allocator, 2048);
    defer allocator.free(contents);

    try testing.expect(contents.len > 0);
    try testing.expect(std.mem.indexOf(u8, contents, "00000000") != null);
    try testing.expect(std.mem.indexOf(u8, contents, test_data) != null);
}
</file>

<file path="io/tls_transfer/transfer.zig">
//! TLS-aware bidirectional transfer dispatcher and platform backends.
//!
//! This module focuses on the I/O orchestration logic for TLS connections.
//! Error mapping, logging helpers, and resource cleanup live in sibling
//! modules to keep responsibilities separated.

const std = @import("std");
const builtin = @import("builtin");
const posix = std.posix;

const config = @import("../../config.zig");
const tls = @import("../../tls/tls.zig");
const linecodec = @import("../linecodec.zig");
const output = @import("../output.zig");
const hexdump = @import("../hexdump.zig");
const poll_wrapper = @import("../../util/poll_wrapper.zig");
const logging = @import("../../util/logging.zig");

const errors = @import("errors.zig");
const cleanup = @import("cleanup.zig");

pub const BUFFER_SIZE = 8192;

/// TLS-aware bidirectional data transfer between stdin/stdout and TLS connection.
///
/// Dispatches to platform-specific implementations while preserving the public API.
pub fn tlsBidirectionalTransfer(
    allocator: std.mem.Allocator,
    tls_conn: *tls.TlsConnection,
    cfg: *const config.Config,
    output_logger: ?*output.OutputLogger,
    hex_dumper: ?*hexdump.HexDumper,
) !void {
    switch (builtin.os.tag) {
        .linux, .macos => {
            return tlsBidirectionalTransferPosix(allocator, tls_conn, cfg, output_logger, hex_dumper);
        },
        .windows => {
            return tlsBidirectionalTransferWindows(allocator, tls_conn, cfg, output_logger, hex_dumper);
        },
        else => {
            // Fallback for other OSes mirrors Windows behaviour (blocking loop).
            return tlsBidirectionalTransferWindows(allocator, tls_conn, cfg, output_logger, hex_dumper);
        },
    }
}

/// Windows implementation of TLS bidirectional transfer.
///
/// Uses blocking I/O with manual polling simulation since Windows lacks a
/// uniform `poll()` implementation for all handle types.
pub fn tlsBidirectionalTransferWindows(
    allocator: std.mem.Allocator,
    tls_conn: *tls.TlsConnection,
    cfg: *const config.Config,
    output_logger: ?*output.OutputLogger,
    hex_dumper: ?*hexdump.HexDumper,
) !void {
    var buffer1: [BUFFER_SIZE]u8 = undefined;
    var buffer2: [BUFFER_SIZE]u8 = undefined;

    const stdin = std.fs.File.stdin();
    const stdout = std.fs.File.stdout();

    const can_send = !cfg.recv_only;
    const can_recv = !cfg.send_only;

    var stdin_closed = false;
    var socket_closed = false;

    while (!stdin_closed or !socket_closed) {
        if (can_send and !stdin_closed) {
            const n = stdin.read(&buffer1) catch 0;
            if (n == 0) {
                stdin_closed = true;
                if (cfg.close_on_eof) {
                    break;
                }
            } else {
                const input_slice = buffer1[0..n];
                const data = if (cfg.crlf)
                    try linecodec.convertLfToCrlf(allocator, input_slice)
                else
                    input_slice;
                defer if (data.ptr != input_slice.ptr) allocator.free(data);

                _ = tls_conn.write(data) catch |err| {
                    logging.logError(err, "TLS write");
                    socket_closed = true;
                    continue;
                };

                if (cfg.verbose) {
                    logging.logVerbose(cfg, "Sent {any} bytes\n", .{data.len});
                }
            }
        }

        if (can_recv and !socket_closed) {
            const n = tls_conn.read(&buffer2) catch |err| {
                const tls_err = errors.handleTlsError(err, "read", cfg);
                if (errors.isTlsErrorRecoverable(tls_err)) {
                    continue;
                } else {
                    return errors.mapTlsError(err);
                }
            };

            if (n == 0) {
                socket_closed = true;
                if (cfg.verbose) {
                    logging.logVerbose(cfg, "TLS connection closed by peer\n", .{});
                }
            } else {
                const data = buffer2[0..n];

                if (!cfg.hex_dump) {
                    try stdout.writeAll(data);
                }

                if (output_logger) |logger| {
                    logger.write(data) catch |err| {
                        errors.handleOutputError(err, cfg, "output logging");
                    };
                }

                if (cfg.hex_dump) {
                    if (hex_dumper) |dumper| {
                        dumper.dump(data) catch |err| {
                            errors.handleOutputError(err, cfg, "hex dump file logging");
                            errors.printHexDump(data);
                        };
                    } else {
                        errors.printHexDump(data);
                    }
                }

                if (cfg.verbose) {
                    logging.logVerbose(cfg, "Received {any} bytes\n", .{n});
                }
            }
        }
    }

    cleanup.cleanupTlsTransferResources(null, output_logger, hex_dumper, cfg);
}

/// POSIX implementation of TLS bidirectional transfer using poll().
pub fn tlsBidirectionalTransferPosix(
    allocator: std.mem.Allocator,
    tls_conn: *tls.TlsConnection,
    cfg: *const config.Config,
    output_logger: ?*output.OutputLogger,
    hex_dumper: ?*hexdump.HexDumper,
) !void {
    var buffer1: [BUFFER_SIZE]u8 = undefined;
    var buffer2: [BUFFER_SIZE]u8 = undefined;

    const stdin = std.fs.File.stdin();
    const stdout = std.fs.File.stdout();

    const tls_socket = tls_conn.getSocket();
    var pollfds = [_]poll_wrapper.pollfd{
        .{ .fd = stdin.handle, .events = poll_wrapper.POLL.IN, .revents = 0 },
        .{ .fd = tls_socket, .events = poll_wrapper.POLL.IN, .revents = 0 },
    };

    const can_send = !cfg.recv_only;
    const can_recv = !cfg.send_only;

    var stdin_closed = false;
    var socket_closed = false;

    const stdin_is_tty = posix.isatty(stdin.handle);
    const timeout_ms: i32 = if (cfg.idle_timeout > 0)
        @intCast(cfg.idle_timeout)
    else if (!stdin_is_tty)
        30000
    else
        -1;

    while (!stdin_closed or !socket_closed) {
        pollfds[0].events = if (!stdin_closed and can_send) poll_wrapper.POLL.IN else 0;
        pollfds[1].events = if (!socket_closed and can_recv) poll_wrapper.POLL.IN else 0;

        const ready = poll_wrapper.poll(&pollfds, timeout_ms) catch |err| {
            logging.logError(err, "Poll");
            return err;
        };

        if (ready == 0) {
            if (cfg.verbose) {
                logging.logVerbose(cfg, "Idle timeout reached\n", .{});
            }
            break;
        }

        if (pollfds[1].revents & (poll_wrapper.POLL.ERR | poll_wrapper.POLL.HUP) != 0) {
            socket_closed = true;
            continue;
        }

        if (pollfds[0].revents & poll_wrapper.POLL.IN != 0) {
            const n = stdin.read(&buffer1) catch 0;

            if (n == 0) {
                stdin_closed = true;
                if (cfg.close_on_eof) {
                    break;
                }
            } else {
                const input_slice = buffer1[0..n];
                const data = if (cfg.crlf)
                    try linecodec.convertLfToCrlf(allocator, input_slice)
                else
                    input_slice;
                defer if (data.ptr != input_slice.ptr) allocator.free(data);

                _ = tls_conn.write(data) catch |err| {
                    const tls_err = errors.handleTlsError(err, "write", cfg);
                    if (!errors.isTlsErrorRecoverable(tls_err)) {
                        return errors.mapTlsError(err);
                    }
                    continue;
                };

                if (cfg.verbose) {
                    logging.logVerbose(cfg, "Sent {any} bytes\n", .{data.len});
                }
            }
        }

        if (can_recv and !socket_closed and (pollfds[1].revents & poll_wrapper.POLL.IN != 0)) {
            const n = tls_conn.read(&buffer2) catch |err| {
                const tls_err = errors.handleTlsError(err, "read", cfg);
                if (errors.isTlsErrorRecoverable(tls_err)) {
                    continue;
                } else {
                    return errors.mapTlsError(err);
                }
            };

            if (n == 0) {
                socket_closed = true;
                if (cfg.verbose) {
                    logging.logVerbose(cfg, "TLS connection closed by peer\n", .{});
                }
            } else {
                const data = buffer2[0..n];

                if (!cfg.hex_dump) {
                    try stdout.writeAll(data);
                }

                if (output_logger) |logger| {
                    logger.write(data) catch |err| {
                        errors.handleOutputError(err, cfg, "output logging");
                    };
                }

                if (cfg.hex_dump) {
                    if (hex_dumper) |dumper| {
                        dumper.dump(data) catch |err| {
                            errors.handleOutputError(err, cfg, "hex dump file logging");
                            errors.printHexDump(data);
                        };
                    } else {
                        errors.printHexDump(data);
                    }
                }

                if (cfg.verbose) {
                    logging.logVerbose(cfg, "Received {any} bytes\n", .{n});
                }
            }
        }
    }

    cleanup.cleanupTlsTransferResources(null, output_logger, hex_dumper, cfg);
}

test "tlsBidirectionalTransfer function is callable" {
    const func = tlsBidirectionalTransfer;
    _ = func;
}
</file>

<file path="io/hexdump.zig">
//! Hexadecimal dump formatting with ASCII sidebar and optional file output.
//!
//! This module provides the `HexDumper` type for formatting binary data in
//! traditional hexdump format with hexadecimal bytes on the left, ASCII
//! representation on the right, and byte offsets for each line.
//!
//! # Features
//!
//! - **Standard hex dump format**: 16 bytes per line with offset, hex, and ASCII
//! - **Dual output**: Display to stdout and optionally save to file
//! - **Offset tracking**: Maintains running offset across multiple dump operations
//! - **Non-printable handling**: Displays '.' for non-ASCII bytes in sidebar
//!
//! # Output Format
//!
//! ```
//! 00000000  48 65 6c 6c 6f 2c 20 57  6f 72 6c 64 21 0a 00 00  |Hello, World!...|
//! 00000010  54 65 73 74 20 64 61 74  61 20 68 65 72 65 2e 00  |Test data here..|
//! ```
//!
//! Format breakdown:
//! - Offset (8 hex digits): Byte position in stream
//! - Hex bytes (2 groups of 8): Hexadecimal representation
//! - ASCII sidebar (16 chars): Printable ASCII or '.' for non-printable
//!
//! # Usage Example
//!
//! ```zig
//! const allocator = std.heap.page_allocator;
//!
//! // Create hex dumper with file output
//! var dumper = try HexDumper.init(allocator, "dump.txt");
//! defer dumper.deinit();
//!
//! // Dump binary data
//! const data = [_]u8{0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x21};
//! try dumper.dump(&data);
//! try dumper.flush();
//!
//! // Dump more data (offset continues from previous)
//! try dumper.dump("More data");
//! // Output: 00000006  4d 6f 72 65 20 64 61 74  61 ...
//!
//! // Reset offset for new connection
//! dumper.resetOffset();
//! ```
//!
//! # Use Cases
//!
//! - **Network protocol debugging**: Inspect binary network traffic
//! - **Data validation**: Verify binary data transmission
//! - **Reverse engineering**: Analyze binary file formats
//! - **Security analysis**: Examine suspicious binary data
//!
//! # Performance Characteristics
//!
//! - O(n) time complexity for dumping n bytes
//! - Fixed 80-byte stack buffer per line (no heap allocation for formatting)
//! - File I/O overhead if file output enabled
//!
//! # Platform Compatibility
//!
//! Works on all platforms supported by Zig's standard library with cross-platform
//! file operations and output handling.

const std = @import("std");
const config = @import("../config.zig");

// Import submodules
const formatter = @import("hexdump/formatter.zig");
const output = @import("hexdump/output.zig");

// Re-export functions
pub const mapHexDumpFileError = output.mapHexDumpFileError;
pub const formatHexLine = formatter.formatHexLine;

/// HexDumper handles formatting binary data in hexadecimal format with ASCII sidebar
/// and optional file output support.
///
/// This type manages hex dump formatting for Zigcat, displaying binary data in the
/// traditional format with offsets, hex bytes, and an ASCII sidebar. Output is sent
/// to both stdout and optionally to a file for persistent logging.
///
/// The dumper maintains a running offset across multiple dump operations, which is
/// useful for streaming data where you want continuous offset tracking. The offset
/// can be reset for new connections or data streams.
pub const HexDumper = struct {
    file: ?std.fs.File = null,
    allocator: std.mem.Allocator,
    path: ?[]const u8 = null,
    offset: u64 = 0,

    /// Initialize HexDumper with optional file path for output.
    ///
    /// Creates a new HexDumper instance. If a file path is provided, the file
    /// will be created (truncated if it exists) for hex dump output. The offset
    /// is initialized to zero.
    ///
    /// Parameters:
    ///   - allocator: Memory allocator (stored for future use)
    ///   - path: Optional file path for saving hex dump (null for stdout-only)
    ///
    /// Returns:
    ///   Initialized HexDumper instance with offset at 0
    ///
    /// Errors:
    ///   - InvalidOutputPath: Empty path string
    ///   - Various IOControlErrors from mapHexDumpFileError()
    ///
    /// Example:
    /// ```zig
    /// var dumper = try HexDumper.init(allocator, "network.hex");
    /// defer dumper.deinit();
    /// ```
    pub fn init(allocator: std.mem.Allocator, path: ?[]const u8) !HexDumper {
        var dumper = HexDumper{
            .allocator = allocator,
            .path = path,
            .offset = 0,
        };

        if (path) |file_path| {
            dumper.file = try output.openHexDumpFile(file_path);
        }

        return dumper;
    }

    /// Clean up resources and close file if open.
    ///
    /// Closes the hex dump file (if one was opened) and releases resources.
    /// Safe to call multiple times. This method must be called to ensure
    /// the file is properly closed and buffers are flushed.
    ///
    /// Example:
    /// ```zig
    /// var dumper = try HexDumper.init(allocator, "data.hex");
    /// defer dumper.deinit(); // Ensures cleanup even on error
    /// ```
    pub fn deinit(self: *HexDumper) void {
        if (self.file) |file| {
            file.close();
            self.file = null;
        }
    }

    /// Dump data in hexadecimal format with ASCII sidebar.
    ///
    /// Formats the provided data in traditional hex dump format (16 bytes per line)
    /// and outputs to both stdout and the file (if configured). The offset is
    /// automatically incremented by the data length after dumping.
    ///
    /// If data is empty, this is a no-op that returns immediately.
    ///
    /// Parameters:
    ///   - data: Binary data to format and display
    ///
    /// Errors:
    ///   - Various IOControlErrors if file write fails
    ///
    /// Example:
    /// ```zig
    /// const packet = [_]u8{0x48, 0x65, 0x6c, 0x6c, 0x6f};
    /// try dumper.dump(&packet);
    /// // Output: 00000000  48 65 6c 6c 6f                                    |Hello|
    /// ```
    pub fn dump(self: *HexDumper, data: []const u8) !void {
        if (data.len == 0) return;

        var i: usize = 0;
        while (i < data.len) {
            const chunk_size = @min(16, data.len - i);
            const chunk = data[i .. i + chunk_size];

            try self.formatAndWriteLine(chunk, self.offset + i);
            i += chunk_size;
        }

        self.offset += data.len;
    }

    /// Format and write a single line of hex dump output.
    ///
    /// Internal function that formats up to 16 bytes of data and writes it
    /// to stdout and file (if configured).
    ///
    /// Parameters:
    ///   - data: Up to 16 bytes of data to format
    ///   - offset: Byte offset to display for this line
    ///
    /// Errors:
    ///   - Various IOControlErrors if file write fails
    fn formatAndWriteLine(self: *HexDumper, data: []const u8, offset: u64) !void {
        // Use a fixed-size buffer for the formatted line
        var line_buffer: [80]u8 = undefined;
        const formatted_line = try formatter.formatHexLine(data, offset, &line_buffer);

        // Write to stdout and file
        try output.writeHexLine(formatted_line, self.file, self.path);
    }

    /// Flush any buffered data to disk with error recovery.
    ///
    /// Forces all buffered hex dump data to be written to disk using `file.sync()`.
    /// If no file is configured, this is a no-op that returns immediately.
    ///
    /// Errors:
    ///   - Various IOControlErrors from mapHexDumpFileError() if sync fails
    ///
    /// Example:
    /// ```zig
    /// try dumper.dump(packet_data);
    /// try dumper.flush(); // Ensure hex dump is on disk
    /// ```
    pub fn flush(self: *HexDumper) !void {
        if (self.file) |file| {
            if (self.path) |path| {
                try output.flushHexDumpFile(file, path);
            }
        }
    }

    /// Check if dumper is configured to write to a file.
    ///
    /// Returns: true if a file was opened during init, false for stdout-only mode
    pub fn isFileEnabled(self: *const HexDumper) bool {
        return self.file != null;
    }

    /// Get the configured file path (may be null).
    ///
    /// Returns: File path string if configured, null for stdout-only mode
    pub fn getPath(self: *const HexDumper) ?[]const u8 {
        return self.path;
    }

    /// Get current offset for next dump operation.
    ///
    /// Returns: Current byte offset (incremented after each dump() call)
    pub fn getOffset(self: *const HexDumper) u64 {
        return self.offset;
    }

    /// Reset offset to zero (useful for new connections).
    ///
    /// Resets the running offset back to 0. This is useful when starting a new
    /// connection or data stream where you want offsets to restart from zero.
    ///
    /// Example:
    /// ```zig
    /// try dumper.dump(connection1_data);
    /// dumper.resetOffset(); // Start fresh for new connection
    /// try dumper.dump(connection2_data);
    /// // Output: 00000000  ... (offset restarted)
    /// ```
    pub fn resetOffset(self: *HexDumper) void {
        self.offset = 0;
    }
};

// Tests
test "HexDumper - init with no path" {
    const testing = std.testing;

    var dumper = try HexDumper.init(testing.allocator, null);
    defer dumper.deinit();

    try testing.expect(!dumper.isFileEnabled());
    try testing.expect(dumper.getPath() == null);
    try testing.expect(dumper.getOffset() == 0);
}

test "HexDumper - init with empty path" {
    const testing = std.testing;

    try testing.expectError(config.IOControlError.InvalidOutputPath, HexDumper.init(testing.allocator, ""));
}

test "HexDumper - offset tracking" {
    const testing = std.testing;

    var dumper = try HexDumper.init(testing.allocator, null);
    defer dumper.deinit();

    try testing.expect(dumper.getOffset() == 0);

    // Simulate dumping some data (we can't easily test the actual output)
    dumper.offset += 16;
    try testing.expect(dumper.getOffset() == 16);

    dumper.resetOffset();
    try testing.expect(dumper.getOffset() == 0);
}

test "HexDumper - flush with no file" {
    const testing = std.testing;

    var dumper = try HexDumper.init(testing.allocator, null);
    defer dumper.deinit();

    // Should not error when no file is configured
    try dumper.flush();
}

test "HexDumper - create and write to file" {
    const testing = std.testing;

    const test_file = "test_hexdump.tmp";

    // Clean up any existing test file
    std.fs.cwd().deleteFile(test_file) catch {};
    defer std.fs.cwd().deleteFile(test_file) catch {};

    {
        var dumper = try HexDumper.init(testing.allocator, test_file);
        defer dumper.deinit();

        try testing.expect(dumper.isFileEnabled());
        try testing.expectEqualStrings(test_file, dumper.getPath().?);

        // Test with some sample data
        const test_data = "Hello, World!";
        try dumper.dump(test_data);
        try dumper.flush();
    }

    // Verify file was created and has content
    {
        const file = try std.fs.cwd().openFile(test_file, .{});
        defer file.close();

        const contents = try file.readToEndAlloc(testing.allocator, 1024);
        defer testing.allocator.free(contents);

        // Should contain hex dump format
        try testing.expect(contents.len > 0);
        try testing.expect(std.mem.indexOf(u8, contents, "00000000") != null);
        try testing.expect(std.mem.indexOf(u8, contents, "Hello, World!") != null);
    }
}

test "HexDumper - empty data handling" {
    const testing = std.testing;

    var dumper = try HexDumper.init(testing.allocator, null);
    defer dumper.deinit();

    // Should handle empty data gracefully
    try dumper.dump("");
    try testing.expect(dumper.getOffset() == 0);
}

test "HexDumper - large data handling" {
    const testing = std.testing;

    var dumper = try HexDumper.init(testing.allocator, null);
    defer dumper.deinit();

    // Test with data larger than 16 bytes (multiple lines)
    const test_data = "This is a test string that is longer than 16 bytes to test multi-line hex dump formatting.";
    try dumper.dump(test_data);

    try testing.expect(dumper.getOffset() == test_data.len);
}

test "HexDumper - binary data with non-printable characters" {
    const testing = std.testing;

    var dumper = try HexDumper.init(testing.allocator, null);
    defer dumper.deinit();

    // Test with binary data including null bytes and control characters
    const test_data = [_]u8{ 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x48, 0x65, 0x6C, 0x6C, 0x6F };
    try dumper.dump(&test_data);

    try testing.expect(dumper.getOffset() == test_data.len);
}

test "HexDumper - error recovery and graceful handling" {
    const testing = std.testing;

    // Test initialization with invalid directory
    const invalid_path = "/nonexistent/directory/hexdump.txt";
    try testing.expectError(config.IOControlError.DirectoryNotFound, HexDumper.init(testing.allocator, invalid_path));
}

test "mapHexDumpFileError - comprehensive error mapping" {
    const testing = std.testing;

    // Test various error mappings
    const test_path = "test_hexdump.txt";

    // Test access denied mapping
    const access_err = mapHexDumpFileError(error.AccessDenied, test_path, "test");
    try testing.expectEqual(config.IOControlError.InsufficientPermissions, access_err);

    // Test file not found mapping
    const notfound_err = mapHexDumpFileError(error.FileNotFound, test_path, "test");
    try testing.expectEqual(config.IOControlError.DirectoryNotFound, notfound_err);

    // Test is directory mapping
    const isdir_err = mapHexDumpFileError(error.IsDir, test_path, "test");
    try testing.expectEqual(config.IOControlError.IsDirectory, isdir_err);

    // Test no space left mapping
    const nospace_err = mapHexDumpFileError(error.NoSpaceLeft, test_path, "test");
    try testing.expectEqual(config.IOControlError.DiskFull, nospace_err);

    // Test file busy mapping
    const busy_err = mapHexDumpFileError(error.FileBusy, test_path, "test");
    try testing.expectEqual(config.IOControlError.FileLocked, busy_err);

    // Test name too long mapping
    const toolong_err = mapHexDumpFileError(error.NameTooLong, test_path, "test");
    try testing.expectEqual(config.IOControlError.PathTooLong, toolong_err);

    // Test unknown error mapping
    const unknown_err = mapHexDumpFileError(error.Unexpected, test_path, "test");
    try testing.expectEqual(config.IOControlError.HexDumpFileCreateFailed, unknown_err);
}
// =============================================================================
// COMPREHENSIVE HEX DUMPER TESTS
// =============================================================================

test "HexDumper - comprehensive initialization and properties" {
    const testing = std.testing;

    // Test with no file path
    var dumper1 = try HexDumper.init(testing.allocator, null);
    defer dumper1.deinit();

    try testing.expect(!dumper1.isFileEnabled());
    try testing.expect(dumper1.getPath() == null);
    try testing.expectEqual(@as(u64, 0), dumper1.getOffset());

    // Test with file path
    const test_file = "test_hexdumper_comprehensive.tmp";
    std.fs.cwd().deleteFile(test_file) catch {};
    defer std.fs.cwd().deleteFile(test_file) catch {};

    var dumper2 = try HexDumper.init(testing.allocator, test_file);
    defer dumper2.deinit();

    try testing.expect(dumper2.isFileEnabled());
    try testing.expectEqualStrings(test_file, dumper2.getPath().?);
    try testing.expectEqual(@as(u64, 0), dumper2.getOffset());
}

test "HexDumper - comprehensive empty path validation" {
    const testing = std.testing;

    try testing.expectError(config.IOControlError.InvalidOutputPath, HexDumper.init(testing.allocator, ""));
}

test "HexDumper - comprehensive offset tracking" {
    const testing = std.testing;

    var dumper = try HexDumper.init(testing.allocator, null);
    defer dumper.deinit();

    try testing.expectEqual(@as(u64, 0), dumper.getOffset());

    // Simulate dumping various sizes of data
    const test_data1 = "Hello";
    try dumper.dump(test_data1);
    try testing.expectEqual(@as(u64, test_data1.len), dumper.getOffset());

    const test_data2 = ", World!";
    try dumper.dump(test_data2);
    try testing.expectEqual(@as(u64, test_data1.len + test_data2.len), dumper.getOffset());

    const test_data3 = " This is a longer string for testing.";
    try dumper.dump(test_data3);
    try testing.expectEqual(@as(u64, test_data1.len + test_data2.len + test_data3.len), dumper.getOffset());

    // Reset offset
    dumper.resetOffset();
    try testing.expectEqual(@as(u64, 0), dumper.getOffset());
}

test "HexDumper - comprehensive empty data handling" {
    const testing = std.testing;

    var dumper = try HexDumper.init(testing.allocator, null);
    defer dumper.deinit();

    // Should handle empty data gracefully
    try dumper.dump("");
    try testing.expectEqual(@as(u64, 0), dumper.getOffset());

    // Multiple empty dumps
    try dumper.dump("");
    try dumper.dump("");
    try dumper.dump("");
    try testing.expectEqual(@as(u64, 0), dumper.getOffset());
}

test "HexDumper - comprehensive file output functionality" {
    const testing = std.testing;

    const test_file = "test_hexdump_output_comprehensive.tmp";
    std.fs.cwd().deleteFile(test_file) catch {};
    defer std.fs.cwd().deleteFile(test_file) catch {};

    {
        var dumper = try HexDumper.init(testing.allocator, test_file);
        defer dumper.deinit();

        const test_data = "Hello, World!";
        try dumper.dump(test_data);
        try dumper.flush();
    }

    // Verify file was created and has hex dump content
    {
        const file = try std.fs.cwd().openFile(test_file, .{});
        defer file.close();

        const contents = try file.readToEndAlloc(testing.allocator, 1024);
        defer testing.allocator.free(contents);

        // Should contain hex dump format
        try testing.expect(contents.len > 0);
        try testing.expect(std.mem.indexOf(u8, contents, "00000000") != null);
        try testing.expect(std.mem.indexOf(u8, contents, "Hello, World!") != null);
        try testing.expect(std.mem.indexOf(u8, contents, "|") != null);
        try testing.expect(std.mem.indexOf(u8, contents, "48 65 6c 6c 6f") != null); // "Hello" in hex
    }
}

test "HexDumper - comprehensive formatting accuracy for various data sizes" {
    const testing = std.testing;

    const test_file = "test_hexdump_formatting.tmp";
    std.fs.cwd().deleteFile(test_file) catch {};
    defer std.fs.cwd().deleteFile(test_file) catch {};

    {
        var dumper = try HexDumper.init(testing.allocator, test_file);
        defer dumper.deinit();

        // Test with exactly 16 bytes
        const test_data_16 = "0123456789ABCDEF";
        try dumper.dump(test_data_16);

        // Test with less than 16 bytes
        dumper.resetOffset();
        const test_data_short = "Short";
        try dumper.dump(test_data_short);

        // Test with more than 16 bytes
        dumper.resetOffset();
        const test_data_long = "This is a test string that is definitely longer than 16 bytes for testing multi-line hex dump.";
        try dumper.dump(test_data_long);

        try dumper.flush();
    }

    // Verify hex dump format
    {
        const file = try std.fs.cwd().openFile(test_file, .{});
        defer file.close();

        const contents = try file.readToEndAlloc(testing.allocator, 4096);
        defer testing.allocator.free(contents);

        // Should have proper hex formatting for 16-byte line
        try testing.expect(std.mem.indexOf(u8, contents, "30 31 32 33 34 35 36 37") != null); // "01234567" in hex
        try testing.expect(std.mem.indexOf(u8, contents, "38 39 41 42 43 44 45 46") != null); // "89ABCDEF" in hex
        try testing.expect(std.mem.indexOf(u8, contents, "|0123456789ABCDEF|") != null);

        // Should have proper formatting for short data
        try testing.expect(std.mem.indexOf(u8, contents, "|Short           |") != null);

        // Should have multiple offset lines for long data
        try testing.expect(std.mem.indexOf(u8, contents, "00000000") != null);
        try testing.expect(std.mem.indexOf(u8, contents, "00000010") != null);
        try testing.expect(std.mem.indexOf(u8, contents, "00000020") != null);
    }
}

test "HexDumper - comprehensive binary data with non-printable characters" {
    const testing = std.testing;

    const test_file = "test_hexdump_binary_comprehensive.tmp";
    std.fs.cwd().deleteFile(test_file) catch {};
    defer std.fs.cwd().deleteFile(test_file) catch {};

    {
        var dumper = try HexDumper.init(testing.allocator, test_file);
        defer dumper.deinit();

        // Test with all possible byte values
        var all_bytes: [256]u8 = undefined;
        for (all_bytes, 0..) |_, i| {
            all_bytes[i] = @intCast(i);
        }
        try dumper.dump(&all_bytes);

        // Test with specific binary patterns
        dumper.resetOffset();
        const binary_pattern = [_]u8{ 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F };
        try dumper.dump(&binary_pattern);

        try dumper.flush();
    }

    // Verify binary hex dump format
    {
        const file = try std.fs.cwd().openFile(test_file, .{});
        defer file.close();

        const contents = try file.readToEndAlloc(testing.allocator, 8192);
        defer testing.allocator.free(contents);

        // Should have proper hex representation
        try testing.expect(std.mem.indexOf(u8, contents, "00 01 02 03 04 05 06 07") != null);
        try testing.expect(std.mem.indexOf(u8, contents, "08 09 0a 0b 0c 0d 0e 0f") != null);

        // Non-printable characters should be replaced with dots
        try testing.expect(std.mem.indexOf(u8, contents, "|................|") != null);

        // Should handle all byte values
        try testing.expect(std.mem.indexOf(u8, contents, "ff") != null); // 255 in hex
    }
}

test "HexDumper - comprehensive mixed printable and non-printable data" {
    const testing = std.testing;

    const test_file = "test_hexdump_mixed_comprehensive.tmp";
    std.fs.cwd().deleteFile(test_file) catch {};
    defer std.fs.cwd().deleteFile(test_file) catch {};

    {
        var dumper = try HexDumper.init(testing.allocator, test_file);
        defer dumper.deinit();

        // Mix of printable and non-printable characters
        const test_data1 = [_]u8{ 'H', 'e', 'l', 'l', 'o', 0x00, 0x01, 0x02, 'W', 'o', 'r', 'l', 'd', 0xFF, 0xFE, '!' };
        try dumper.dump(&test_data1);

        // Another mixed pattern
        const test_data2 = [_]u8{ 0x7F, 'A', 'B', 'C', 0x80, 0x90, 'X', 'Y', 'Z', 0x00, 0x0A, 0x0D, '1', '2', '3', 0xFF };
        try dumper.dump(&test_data2);

        try dumper.flush();
    }

    // Verify mixed data formatting
    {
        const file = try std.fs.cwd().openFile(test_file, .{});
        defer file.close();

        const contents = try file.readToEndAlloc(testing.allocator, 2048);
        defer testing.allocator.free(contents);

        // Should show printable characters as-is and non-printable as dots
        try testing.expect(std.mem.indexOf(u8, contents, "|Hello...World..!|") != null);
        try testing.expect(std.mem.indexOf(u8, contents, "48 65 6c 6c 6f 00 01 02") != null); // "Hello" + null bytes

        // Should handle the second pattern
        try testing.expect(std.mem.indexOf(u8, contents, "|.ABC..XYZ...123.|") != null);
    }
}

test "HexDumper - comprehensive flush operations" {
    const testing = std.testing;

    // Test flush without file
    var dumper1 = try HexDumper.init(testing.allocator, null);
    defer dumper1.deinit();

    try dumper1.flush(); // Should not error

    // Test flush with file
    const test_file = "test_hexdump_flush.tmp";
    std.fs.cwd().deleteFile(test_file) catch {};
    defer std.fs.cwd().deleteFile(test_file) catch {};

    var dumper2 = try HexDumper.init(testing.allocator, test_file);
    defer dumper2.deinit();

    try dumper2.dump("Test data");
    try dumper2.flush();
    try dumper2.dump("More data");
    try dumper2.flush();
}

test "HexDumper - comprehensive multiple dump operations with offset tracking" {
    const testing = std.testing;

    var dumper = try HexDumper.init(testing.allocator, null);
    defer dumper.deinit();

    // Multiple dumps with different sizes
    try dumper.dump("A");
    try testing.expectEqual(@as(u64, 1), dumper.getOffset());

    try dumper.dump("BC");
    try testing.expectEqual(@as(u64, 3), dumper.getOffset());

    try dumper.dump("DEFG");
    try testing.expectEqual(@as(u64, 7), dumper.getOffset());

    try dumper.dump("HIJKLMNOP");
    try testing.expectEqual(@as(u64, 16), dumper.getOffset());

    try dumper.dump("QRSTUVWXYZ");
    try testing.expectEqual(@as(u64, 26), dumper.getOffset());

    // Reset and verify
    dumper.resetOffset();
    try testing.expectEqual(@as(u64, 0), dumper.getOffset());

    // Continue dumping after reset
    try dumper.dump("New data after reset");
    try testing.expectEqual(@as(u64, 20), dumper.getOffset());
}

test "HexDumper - comprehensive error recovery scenarios" {
    const testing = std.testing;

    // Test initialization with invalid directory
    const invalid_path = "/nonexistent/directory/hexdump.txt";
    try testing.expectError(config.IOControlError.DirectoryNotFound, HexDumper.init(testing.allocator, invalid_path));
}

test "mapHexDumpFileError - comprehensive error mapping coverage" {
    const testing = std.testing;

    const test_path = "test_hexdump.txt";

    // Test all error mappings
    const access_err = mapHexDumpFileError(error.AccessDenied, test_path, "test");
    try testing.expectEqual(config.IOControlError.InsufficientPermissions, access_err);

    const notfound_err = mapHexDumpFileError(error.FileNotFound, test_path, "test");
    try testing.expectEqual(config.IOControlError.DirectoryNotFound, notfound_err);

    const isdir_err = mapHexDumpFileError(error.IsDir, test_path, "test");
    try testing.expectEqual(config.IOControlError.IsDirectory, isdir_err);

    const nospace_err = mapHexDumpFileError(error.NoSpaceLeft, test_path, "test");
    try testing.expectEqual(config.IOControlError.DiskFull, nospace_err);

    const busy_err = mapHexDumpFileError(error.FileBusy, test_path, "test");
    try testing.expectEqual(config.IOControlError.FileLocked, busy_err);

    const resource_busy_err = mapHexDumpFileError(error.ResourceBusy, test_path, "test");
    try testing.expectEqual(config.IOControlError.FileLocked, resource_busy_err);

    const toolong_err = mapHexDumpFileError(error.NameTooLong, test_path, "test");
    try testing.expectEqual(config.IOControlError.PathTooLong, toolong_err);

    const utf8_err = mapHexDumpFileError(error.InvalidUtf8, test_path, "test");
    try testing.expectEqual(config.IOControlError.InvalidPathCharacters, utf8_err);

    const badpath_err = mapHexDumpFileError(error.BadPathName, test_path, "test");
    try testing.expectEqual(config.IOControlError.InvalidPathCharacters, badpath_err);

    const notdir_err = mapHexDumpFileError(error.NotDir, test_path, "test");
    try testing.expectEqual(config.IOControlError.DirectoryNotFound, notdir_err);

    const device_busy_err = mapHexDumpFileError(error.DeviceBusy, test_path, "test");
    try testing.expectEqual(config.IOControlError.FileSystemError, device_busy_err);

    const system_resources_err = mapHexDumpFileError(error.SystemResources, test_path, "test");
    try testing.expectEqual(config.IOControlError.FileSystemError, system_resources_err);

    const unknown_err = mapHexDumpFileError(error.Unexpected, test_path, "test");
    try testing.expectEqual(config.IOControlError.HexDumpFileCreateFailed, unknown_err);
}

test "HexDumper - comprehensive edge cases and boundary conditions" {
    const testing = std.testing;

    var dumper = try HexDumper.init(testing.allocator, null);
    defer dumper.deinit();

    // Test with exactly 15 bytes (one less than full line)
    const data_15 = "123456789012345";
    try dumper.dump(data_15);
    try testing.expectEqual(@as(u64, 15), dumper.getOffset());

    // Reset and test with exactly 17 bytes (one more than full line)
    dumper.resetOffset();
    const data_17 = "12345678901234567";
    try dumper.dump(data_17);
    try testing.expectEqual(@as(u64, 17), dumper.getOffset());

    // Reset and test with exactly 32 bytes (two full lines)
    dumper.resetOffset();
    const data_32 = "12345678901234567890123456789012";
    try dumper.dump(data_32);
    try testing.expectEqual(@as(u64, 32), dumper.getOffset());

    // Test with single byte
    dumper.resetOffset();
    try dumper.dump("X");
    try testing.expectEqual(@as(u64, 1), dumper.getOffset());
}

test "HexDumper - comprehensive file truncation behavior" {
    const testing = std.testing;

    const test_file = "test_hexdump_truncation.tmp";
    std.fs.cwd().deleteFile(test_file) catch {};
    defer std.fs.cwd().deleteFile(test_file) catch {};

    // First write
    {
        var dumper = try HexDumper.init(testing.allocator, test_file);
        defer dumper.deinit();

        try dumper.dump("Original content");
        try dumper.flush();
    }

    // Second write (should truncate)
    {
        var dumper = try HexDumper.init(testing.allocator, test_file);
        defer dumper.deinit();

        try dumper.dump("New content");
        try dumper.flush();
    }

    // Verify only new content is present
    {
        const file = try std.fs.cwd().openFile(test_file, .{});
        defer file.close();

        const contents = try file.readToEndAlloc(testing.allocator, 1024);
        defer testing.allocator.free(contents);

        // Should only contain the new content, not the original
        try testing.expect(std.mem.indexOf(u8, contents, "New content") != null);
        try testing.expect(std.mem.indexOf(u8, contents, "Original content") == null);
    }
}
</file>

<file path="io/linecodec.zig">
//! Line ending codec for converting between LF and CRLF formats.
//!
//! This module provides utilities for converting line endings between Unix-style
//! LF (Line Feed, '\n') and Windows-style CRLF (Carriage Return + Line Feed, '\r\n').
//! These conversions are commonly needed when transferring text data between
//! systems with different line ending conventions.
//!
//! # Functions
//!
//! - `convertLfToCrlf()`: Convert LF to CRLF (allocates new buffer if conversion needed)
//! - `convertCrlfToLf()`: Convert CRLF to LF (in-place modification)
//!
//! # Usage Example
//!
//! ```zig
//! const allocator = std.heap.page_allocator;
//! const unix_data = "Hello\nWorld\n";
//!
//! // Convert to Windows format (requires allocation)
//! const windows_data = try convertLfToCrlf(allocator, unix_data);
//! defer if (windows_data.ptr != unix_data.ptr) allocator.free(windows_data);
//! // Result: "Hello\r\nWorld\r\n"
//!
//! // Convert back to Unix format (in-place)
//! var buffer = try allocator.dupe(u8, windows_data);
//! defer allocator.free(buffer);
//! const unix_result = convertCrlfToLf(buffer);
//! // Result: "Hello\nWorld\n"
//! ```
//!
//! # Performance Characteristics
//!
//! - `convertLfToCrlf()`: O(n) time, may allocate new buffer if LF characters present
//! - `convertCrlfToLf()`: O(n) time, modifies buffer in-place (no allocation)
//!
//! # Memory Management
//!
//! `convertLfToCrlf()` returns the original slice if no conversion is needed,
//! otherwise allocates a new buffer. Callers must check if the returned pointer
//! differs from the input pointer before freeing.

const std = @import("std");

/// Convert LF to CRLF in data (allocates new buffer if conversion needed).
///
/// Scans the input data for LF ('\n') characters and converts them to CRLF ('\r\n').
/// If no LF characters are found, returns the original data slice without allocation.
/// Otherwise, allocates a new buffer with the converted data.
///
/// Parameters:
///   - allocator: Memory allocator for the converted buffer
///   - data: Input data to convert
///
/// Returns:
///   - Original data slice if no conversion needed
///   - New allocated buffer with CRLF line endings if conversion performed
///
/// Errors:
///   - OutOfMemory: Failed to allocate buffer for converted data
///
/// Example:
/// ```zig
/// const result = try convertLfToCrlf(allocator, "Hello\n");
/// defer if (result.ptr != data.ptr) allocator.free(result);
/// // result is "Hello\r\n"
/// ```
pub fn convertLfToCrlf(allocator: std.mem.Allocator, data: []const u8) ![]const u8 {
    // Count LF characters
    var lf_count: usize = 0;
    for (data) |byte| {
        if (byte == '\n') lf_count += 1;
    }

    if (lf_count == 0) {
        // No conversion needed, return original data
        return data;
    }

    // Allocate buffer for converted data
    const new_len = data.len + lf_count;
    const result = try allocator.alloc(u8, new_len);

    var i: usize = 0;
    var j: usize = 0;
    while (i < data.len) : (i += 1) {
        if (data[i] == '\n') {
            // Insert CR before LF
            result[j] = '\r';
            j += 1;
            result[j] = '\n';
            j += 1;
        } else {
            result[j] = data[i];
            j += 1;
        }
    }

    return result;
}

/// Convert CRLF to LF in data (modifies in place, returns slice).
///
/// Scans the input buffer for CRLF sequences ('\r\n') and converts them to LF ('\n').
/// The conversion is performed in-place without allocation, and returns a slice
/// of the modified buffer with the new length (always <= original length).
///
/// This function is safe to use with mutable slices and does not require deallocation
/// since it operates on the caller's buffer.
///
/// Parameters:
///   - data: Mutable buffer to convert (modified in-place)
///
/// Returns:
///   - Slice of the input buffer with converted data (length may be shorter)
///
/// Example:
/// ```zig
/// var buffer = [_]u8{'H', 'i', '\r', '\n', 'B', 'y', 'e', '\r', '\n'};
/// const result = convertCrlfToLf(&buffer);
/// // result is "Hi\nBye\n" (length 7, original length 9)
/// ```
pub fn convertCrlfToLf(data: []u8) []u8 {
    var i: usize = 0;
    var j: usize = 0;

    while (i < data.len) {
        if (i + 1 < data.len and data[i] == '\r' and data[i + 1] == '\n') {
            // Skip CR, keep only LF
            data[j] = '\n';
            i += 2;
            j += 1;
        } else {
            data[j] = data[i];
            i += 1;
            j += 1;
        }
    }

    return data[0..j];
}

test "convertLfToCrlf no conversion" {
    const allocator = std.testing.allocator;
    const input = "hello world";
    const result = try convertLfToCrlf(allocator, input);
    defer if (result.ptr != input.ptr) allocator.free(result);

    try std.testing.expectEqualStrings(input, result);
}

test "convertLfToCrlf with newlines" {
    const allocator = std.testing.allocator;
    const input = "hello\nworld\n";
    const result = try convertLfToCrlf(allocator, input);
    defer allocator.free(result);

    try std.testing.expectEqualStrings("hello\r\nworld\r\n", result);
}

test "convertCrlfToLf" {
    var input = [_]u8{ 'h', 'e', 'l', 'l', 'o', '\r', '\n', 'w', 'o', 'r', 'l', 'd', '\r', '\n' };
    const result = convertCrlfToLf(&input);

    try std.testing.expectEqualStrings("hello\nworld\n", result);
}
</file>

<file path="io/output.zig">
//! Output file logging with support for truncate and append modes.
//!
//! This module provides the `OutputLogger` type for writing data to output files
//! with comprehensive error handling and user-friendly error messages. It supports
//! both truncate mode (overwrite existing file) and append mode (add to existing file).
//!
//! # Features
//!
//! - **Truncate/Append Modes**: Control whether to overwrite or append to existing files
//! - **Comprehensive Error Handling**: Detailed error messages with recovery suggestions
//! - **Optional File Output**: Can operate without a file (no-op mode)
//! - **Flush Support**: Explicit sync-to-disk for critical data
//!
//! # Usage Example
//!
//! ```zig
//! const allocator = std.heap.page_allocator;
//!
//! // Create logger in truncate mode (default)
//! var logger = try OutputLogger.init(allocator, "output.log", false);
//! defer logger.deinit();
//!
//! try logger.write("First line\n");
//! try logger.write("Second line\n");
//! try logger.flush();
//!
//! // Create logger in append mode
//! var append_logger = try OutputLogger.init(allocator, "output.log", true);
//! defer append_logger.deinit();
//! try append_logger.write("Appended line\n");
//! ```
//!
//! # Error Handling
//!
//! The module provides detailed error classification through `mapFileError()`,
//! which converts filesystem errors to `IOControlError` types with helpful
//! suggestions for resolution:
//!
//! - `InsufficientPermissions`: Permission denied (suggests chmod)
//! - `DirectoryNotFound`: Parent directory doesn't exist (suggests mkdir)
//! - `IsDirectory`: Path is a directory, not a file
//! - `DiskFull`: No space left on device
//! - `FileLocked`: File locked by another process
//! - `PathTooLong`: Path exceeds system limits
//! - `InvalidPathCharacters`: Path contains invalid characters
//!
//! # Platform Compatibility
//!
//! Works on all platforms supported by Zig's standard library (Unix, Windows, etc.)
//! with cross-platform file operations.

const std = @import("std");
const config = @import("../config.zig");

/// Map filesystem errors to specific IOControlError types with user-friendly messages.
///
/// This function provides detailed error classification and logging for file operations,
/// helping users understand what went wrong and how to fix it.
///
/// Parameters:
///   err: The original filesystem error
///   path: File path that caused the error (for logging)
///   operation: Description of the operation that failed
///
/// Returns: Appropriate IOControlError based on the original error
fn mapFileError(err: anyerror, path: []const u8, operation: []const u8) config.IOControlError {
    // Suppress debug output during tests to avoid contaminating test output
    const is_test = @import("builtin").is_test;

    switch (err) {
        error.AccessDenied => {
            if (!is_test) {
                std.debug.print("Error: Permission denied to {s} output file '{s}'\n", .{ operation, path });
                std.debug.print("  Try: chmod +w '{s}' or run with appropriate permissions\n", .{path});
            }
            return config.IOControlError.InsufficientPermissions;
        },
        error.FileNotFound => {
            if (!is_test) {
                std.debug.print("Error: Directory not found for output file '{s}'\n", .{path});
                std.debug.print("  Try: mkdir -p '{s}'\n", .{std.fs.path.dirname(path) orelse "."});
            }
            return config.IOControlError.DirectoryNotFound;
        },
        error.IsDir => {
            if (!is_test) {
                std.debug.print("Error: Output path '{s}' is a directory, not a file\n", .{path});
            }
            return config.IOControlError.IsDirectory;
        },
        error.NoSpaceLeft => {
            if (!is_test) {
                std.debug.print("Error: No space left on device for output file '{s}'\n", .{path});
                std.debug.print("  Try: Free up disk space or choose a different location\n", .{});
            }
            return config.IOControlError.DiskFull;
        },
        error.FileBusy, error.ResourceBusy => {
            if (!is_test) {
                std.debug.print("Error: Output file '{s}' is locked by another process\n", .{path});
                std.debug.print("  Try: Close other applications using this file\n", .{});
            }
            return config.IOControlError.FileLocked;
        },
        error.NameTooLong => {
            if (!is_test) {
                std.debug.print("Error: Output file path '{s}' is too long\n", .{path});
            }
            return config.IOControlError.PathTooLong;
        },
        error.InvalidUtf8, error.BadPathName => {
            if (!is_test) {
                std.debug.print("Error: Output file path '{s}' contains invalid characters\n", .{path});
            }
            return config.IOControlError.InvalidPathCharacters;
        },
        error.NotDir => {
            if (!is_test) {
                std.debug.print("Error: Parent directory in path '{s}' is not a directory\n", .{path});
            }
            return config.IOControlError.DirectoryNotFound;
        },
        error.DeviceBusy, error.SystemResources => {
            if (!is_test) {
                std.debug.print("Error: System resources unavailable for output file '{s}'\n", .{path});
            }
            return config.IOControlError.FileSystemError;
        },
        else => {
            if (!is_test) {
                std.debug.print("Error: Failed to {s} output file '{s}': {any}\n", .{ operation, path, err });
            }
            return config.IOControlError.OutputFileCreateFailed;
        },
    }
}

/// OutputLogger handles writing data to output files with support for
/// truncate/append modes and proper resource management.
///
/// This type manages file output for Zigcat, supporting both truncate mode
/// (overwrite existing file) and append mode (add to existing file). It can
/// also operate without a file for scenarios where file output is optional.
///
/// The logger ensures proper cleanup via the `deinit()` method and provides
/// graceful error recovery with detailed error messages.
pub const OutputLogger = struct {
    file: ?std.fs.File = null,
    allocator: std.mem.Allocator,
    path: ?[]const u8 = null,
    append_mode: bool = false,

    /// Initialize OutputLogger with optional file path and append mode.
    ///
    /// Creates a new OutputLogger instance. If a file path is provided, the file
    /// will be opened (created if necessary). In truncate mode (append=false), any
    /// existing file will be overwritten. In append mode (append=true), data will
    /// be written to the end of existing files.
    ///
    /// Parameters:
    ///   - allocator: Memory allocator (stored for future use)
    ///   - path: Optional file path (null for no-file mode)
    ///   - append: If true, append to existing file; if false, truncate
    ///
    /// Returns:
    ///   Initialized OutputLogger instance
    ///
    /// Errors:
    ///   - InvalidOutputPath: Empty path string
    ///   - Various IOControlErrors from mapFileError() (permission, disk full, etc.)
    ///
    /// Example:
    /// ```zig
    /// var logger = try OutputLogger.init(allocator, "data.log", false);
    /// defer logger.deinit();
    /// ```
    pub fn init(allocator: std.mem.Allocator, path: ?[]const u8, append: bool) !OutputLogger {
        var logger = OutputLogger{
            .allocator = allocator,
            .path = path,
            .append_mode = append,
        };

        if (path) |file_path| {
            // Validate path is not empty
            if (file_path.len == 0) {
                return config.IOControlError.InvalidOutputPath;
            }

            // Create or open the file based on append mode
            const file = if (append) blk: {
                // Try to open existing file for appending, create if doesn't exist
                break :blk std.fs.cwd().createFile(file_path, .{
                    .read = false,
                    .truncate = false,
                    .exclusive = false,
                }) catch |err| switch (err) {
                    error.PathAlreadyExists => std.fs.cwd().openFile(file_path, .{
                        .mode = .write_only,
                    }) catch |open_err| {
                        return mapFileError(open_err, file_path, "open for appending");
                    },
                    else => {
                        return mapFileError(err, file_path, "create for appending");
                    },
                };
            } else blk: {
                // Create new file, truncating if it exists
                break :blk std.fs.cwd().createFile(file_path, .{
                    .read = false,
                    .truncate = true,
                    .exclusive = false,
                }) catch |err| {
                    return mapFileError(err, file_path, "create");
                };
            };

            // If in append mode, seek to end of file
            if (append) {
                file.seekFromEnd(0) catch |err| {
                    file.close();
                    return mapFileError(err, file_path, "seek to end");
                };
            }

            logger.file = file;
        }

        return logger;
    }

    /// Clean up resources and close file if open.
    ///
    /// Closes the output file (if one was opened) and releases resources.
    /// Safe to call multiple times. This method must be called to ensure
    /// the file is properly closed and buffers are flushed.
    ///
    /// Example:
    /// ```zig
    /// var logger = try OutputLogger.init(allocator, "output.log", false);
    /// defer logger.deinit(); // Ensures cleanup even on error
    /// ```
    pub fn deinit(self: *OutputLogger) void {
        if (self.file) |file| {
            file.close();
            self.file = null;
        }
    }

    /// Write data to the output file with graceful error recovery.
    ///
    /// Writes the provided data to the output file. If no file is configured
    /// (path was null during init), this is a no-op that returns immediately.
    ///
    /// Parameters:
    ///   - data: Byte slice to write to file
    ///
    /// Errors:
    ///   - Various IOControlErrors from mapFileError() if write fails
    ///
    /// Example:
    /// ```zig
    /// try logger.write("Hello, World!\n");
    /// try logger.write(binary_data);
    /// ```
    pub fn write(self: *OutputLogger, data: []const u8) !void {
        if (self.file) |file| {
            file.writeAll(data) catch |err| {
                // Attempt graceful error recovery for transient issues
                if (self.path) |path| {
                    return mapFileError(err, path, "write");
                } else {
                    return config.IOControlError.OutputFileWriteFailed;
                }
            };
        }
    }

    /// Flush any buffered data to disk with error recovery.
    ///
    /// Forces all buffered data to be written to disk using `file.sync()`.
    /// If no file is configured, this is a no-op that returns immediately.
    ///
    /// This should be called when data integrity is critical (e.g., after
    /// writing important records or before disconnecting).
    ///
    /// Errors:
    ///   - Various IOControlErrors from mapFileError() if sync fails
    ///
    /// Example:
    /// ```zig
    /// try logger.write("Critical data\n");
    /// try logger.flush(); // Ensure it's on disk
    /// ```
    pub fn flush(self: *OutputLogger) !void {
        if (self.file) |file| {
            file.sync() catch |err| {
                if (self.path) |path| {
                    return mapFileError(err, path, "flush");
                } else {
                    return config.IOControlError.OutputFileWriteFailed;
                }
            };
        }
    }

    /// Check if logger is configured to write to a file.
    ///
    /// Returns: true if a file was opened during init, false otherwise
    pub fn isEnabled(self: *const OutputLogger) bool {
        return self.file != null;
    }

    /// Get the configured file path (may be null).
    ///
    /// Returns: File path string if configured, null otherwise
    pub fn getPath(self: *const OutputLogger) ?[]const u8 {
        return self.path;
    }

    /// Check if logger is in append mode.
    ///
    /// Returns: true if logger was initialized with append=true, false for truncate mode
    pub fn isAppendMode(self: *const OutputLogger) bool {
        return self.append_mode;
    }
};

// Tests
test "OutputLogger - init with no path" {
    const testing = std.testing;

    var logger = try OutputLogger.init(testing.allocator, null, false);
    defer logger.deinit();

    try testing.expect(!logger.isEnabled());
    try testing.expect(logger.getPath() == null);
    try testing.expect(!logger.isAppendMode());
}

test "OutputLogger - init with empty path" {
    const testing = std.testing;

    try testing.expectError(config.IOControlError.InvalidOutputPath, OutputLogger.init(testing.allocator, "", false));
}

test "OutputLogger - write and flush with no file" {
    const testing = std.testing;

    var logger = try OutputLogger.init(testing.allocator, null, false);
    defer logger.deinit();

    // Should not error when no file is configured
    try logger.write("test data");
    try logger.flush();
}

test "OutputLogger - create and write to file" {
    const testing = std.testing;

    // Create a temporary file path
    const test_file = "test_output.tmp";

    // Clean up any existing test file
    std.fs.cwd().deleteFile(test_file) catch {};
    defer std.fs.cwd().deleteFile(test_file) catch {};

    // Test truncate mode (default)
    {
        var logger = try OutputLogger.init(testing.allocator, test_file, false);
        defer logger.deinit();

        try testing.expect(logger.isEnabled());
        try testing.expect(!logger.isAppendMode());
        try testing.expectEqualStrings(test_file, logger.getPath().?);

        try logger.write("Hello, ");
        try logger.write("World!");
        try logger.flush();
    }

    // Verify file contents
    {
        const file = try std.fs.cwd().openFile(test_file, .{});
        defer file.close();

        const contents = try file.readToEndAlloc(testing.allocator, 1024);
        defer testing.allocator.free(contents);

        try testing.expectEqualStrings("Hello, World!", contents);
    }
}

test "OutputLogger - append mode" {
    const testing = std.testing;

    const test_file = "test_append.tmp";

    // Clean up any existing test file
    std.fs.cwd().deleteFile(test_file) catch {};
    defer std.fs.cwd().deleteFile(test_file) catch {};

    // First write in truncate mode
    {
        var logger = try OutputLogger.init(testing.allocator, test_file, false);
        defer logger.deinit();

        try logger.write("First line\n");
        try logger.flush();
    }

    // Second write in append mode
    {
        var logger = try OutputLogger.init(testing.allocator, test_file, true);
        defer logger.deinit();

        try testing.expect(logger.isAppendMode());

        try logger.write("Second line\n");
        try logger.flush();
    }

    // Verify both lines are present
    {
        const file = try std.fs.cwd().openFile(test_file, .{});
        defer file.close();

        const contents = try file.readToEndAlloc(testing.allocator, 1024);
        defer testing.allocator.free(contents);

        try testing.expectEqualStrings("First line\nSecond line\n", contents);
    }
}

test "OutputLogger - truncate mode overwrites existing file" {
    const testing = std.testing;

    const test_file = "test_truncate.tmp";

    // Clean up any existing test file
    std.fs.cwd().deleteFile(test_file) catch {};
    defer std.fs.cwd().deleteFile(test_file) catch {};

    // First write
    {
        var logger = try OutputLogger.init(testing.allocator, test_file, false);
        defer logger.deinit();

        try logger.write("Original content");
        try logger.flush();
    }

    // Second write in truncate mode (default)
    {
        var logger = try OutputLogger.init(testing.allocator, test_file, false);
        defer logger.deinit();

        try logger.write("New content");
        try logger.flush();
    }

    // Verify only new content is present
    {
        const file = try std.fs.cwd().openFile(test_file, .{});
        defer file.close();

        const contents = try file.readToEndAlloc(testing.allocator, 1024);
        defer testing.allocator.free(contents);

        try testing.expectEqualStrings("New content", contents);
    }
}

test "OutputLogger - error recovery and graceful handling" {
    const testing = std.testing;

    // Test initialization with invalid directory
    const invalid_path = "/nonexistent/directory/file.txt";
    try testing.expectError(config.IOControlError.DirectoryNotFound, OutputLogger.init(testing.allocator, invalid_path, false));

    // Test with read-only directory (if we can create one)
    // This test is platform-dependent and may not work in all environments
    const readonly_test = false; // Disable for now due to platform differences
    if (readonly_test) {
        const readonly_dir = "readonly_test_dir";
        _ = "readonly_test_dir/file.txt"; // Suppress unused warning

        // Create directory and make it read-only
        std.fs.cwd().makeDir(readonly_dir) catch {};
        defer std.fs.cwd().deleteTree(readonly_dir) catch {};

        // This test would need platform-specific permission setting
        // For now, we'll skip it to maintain cross-platform compatibility
    }
}

test "mapFileError - comprehensive error mapping" {
    const testing = std.testing;

    // Test various error mappings
    const test_path = "test_file.txt";

    // Test access denied mapping
    const access_err = mapFileError(error.AccessDenied, test_path, "test");
    try testing.expectEqual(config.IOControlError.InsufficientPermissions, access_err);

    // Test file not found mapping
    const notfound_err = mapFileError(error.FileNotFound, test_path, "test");
    try testing.expectEqual(config.IOControlError.DirectoryNotFound, notfound_err);

    // Test is directory mapping
    const isdir_err = mapFileError(error.IsDir, test_path, "test");
    try testing.expectEqual(config.IOControlError.IsDirectory, isdir_err);

    // Test no space left mapping
    const nospace_err = mapFileError(error.NoSpaceLeft, test_path, "test");
    try testing.expectEqual(config.IOControlError.DiskFull, nospace_err);

    // Test file busy mapping
    const busy_err = mapFileError(error.FileBusy, test_path, "test");
    try testing.expectEqual(config.IOControlError.FileLocked, busy_err);

    // Test name too long mapping
    const toolong_err = mapFileError(error.NameTooLong, test_path, "test");
    try testing.expectEqual(config.IOControlError.PathTooLong, toolong_err);

    // Test unknown error mapping
    const unknown_err = mapFileError(error.Unexpected, test_path, "test");
    try testing.expectEqual(config.IOControlError.OutputFileCreateFailed, unknown_err);
}
// =============================================================================
// COMPREHENSIVE OUTPUT LOGGER TESTS
// =============================================================================

test "OutputLogger - comprehensive initialization and properties" {
    const testing = std.testing;

    // Test with no file path
    var logger1 = try OutputLogger.init(testing.allocator, null, false);
    defer logger1.deinit();

    try testing.expect(!logger1.isEnabled());
    try testing.expect(logger1.getPath() == null);
    try testing.expect(!logger1.isAppendMode());

    // Test with file path in truncate mode
    const test_file = "test_output_logger.tmp";
    std.fs.cwd().deleteFile(test_file) catch {};
    defer std.fs.cwd().deleteFile(test_file) catch {};

    var logger2 = try OutputLogger.init(testing.allocator, test_file, false);
    defer logger2.deinit();

    try testing.expect(logger2.isEnabled());
    try testing.expectEqualStrings(test_file, logger2.getPath().?);
    try testing.expect(!logger2.isAppendMode());

    // Test with file path in append mode
    var logger3 = try OutputLogger.init(testing.allocator, test_file, true);
    defer logger3.deinit();

    try testing.expect(logger3.isEnabled());
    try testing.expectEqualStrings(test_file, logger3.getPath().?);
    try testing.expect(logger3.isAppendMode());
}

test "OutputLogger - comprehensive empty path validation" {
    const testing = std.testing;

    try testing.expectError(config.IOControlError.InvalidOutputPath, OutputLogger.init(testing.allocator, "", false));
    try testing.expectError(config.IOControlError.InvalidOutputPath, OutputLogger.init(testing.allocator, "", true));
}

test "OutputLogger - comprehensive write operations without file" {
    const testing = std.testing;

    var logger = try OutputLogger.init(testing.allocator, null, false);
    defer logger.deinit();

    // Should not error when no file is configured
    try logger.write("test data");
    try logger.write("");
    try logger.write("more data");
    try logger.flush();
}

test "OutputLogger - comprehensive file creation and writing" {
    const testing = std.testing;

    const test_file = "test_output_write_comprehensive.tmp";
    std.fs.cwd().deleteFile(test_file) catch {};
    defer std.fs.cwd().deleteFile(test_file) catch {};

    // Test truncate mode with multiple writes
    {
        var logger = try OutputLogger.init(testing.allocator, test_file, false);
        defer logger.deinit();

        try logger.write("Hello, ");
        try logger.write("World!");
        try logger.write("\nSecond line");
        try logger.flush();
    }

    // Verify file contents
    {
        const file = try std.fs.cwd().openFile(test_file, .{});
        defer file.close();

        const contents = try file.readToEndAlloc(testing.allocator, 1024);
        defer testing.allocator.free(contents);

        try testing.expectEqualStrings("Hello, World!\nSecond line", contents);
    }
}

test "OutputLogger - comprehensive append mode functionality" {
    const testing = std.testing;

    const test_file = "test_output_append_comprehensive.tmp";
    std.fs.cwd().deleteFile(test_file) catch {};
    defer std.fs.cwd().deleteFile(test_file) catch {};

    // First write in truncate mode
    {
        var logger = try OutputLogger.init(testing.allocator, test_file, false);
        defer logger.deinit();

        try logger.write("First line\n");
        try logger.flush();
    }

    // Second write in append mode
    {
        var logger = try OutputLogger.init(testing.allocator, test_file, true);
        defer logger.deinit();

        try logger.write("Second line\n");
        try logger.flush();
    }

    // Third write in append mode
    {
        var logger = try OutputLogger.init(testing.allocator, test_file, true);
        defer logger.deinit();

        try logger.write("Third line\n");
        try logger.flush();
    }

    // Verify all lines are present
    {
        const file = try std.fs.cwd().openFile(test_file, .{});
        defer file.close();

        const contents = try file.readToEndAlloc(testing.allocator, 1024);
        defer testing.allocator.free(contents);

        try testing.expectEqualStrings("First line\nSecond line\nThird line\n", contents);
    }
}

test "OutputLogger - comprehensive large data handling" {
    const testing = std.testing;

    const test_file = "test_output_large_comprehensive.tmp";
    std.fs.cwd().deleteFile(test_file) catch {};
    defer std.fs.cwd().deleteFile(test_file) catch {};

    {
        var logger = try OutputLogger.init(testing.allocator, test_file, false);
        defer logger.deinit();

        // Write large amount of data in chunks
        const chunk_size = 1000;
        var i: usize = 0;
        while (i < 10) : (i += 1) {
            const large_chunk = "A" ** chunk_size;
            try logger.write(large_chunk);
        }
        try logger.flush();
    }

    // Verify file size
    {
        const file = try std.fs.cwd().openFile(test_file, .{});
        defer file.close();

        const stat = try file.stat();
        try testing.expectEqual(@as(u64, 10000), stat.size);
    }
}

test "OutputLogger - comprehensive binary data handling" {
    const testing = std.testing;

    const test_file = "test_output_binary_comprehensive.tmp";
    std.fs.cwd().deleteFile(test_file) catch {};
    defer std.fs.cwd().deleteFile(test_file) catch {};

    const binary_data = [_]u8{ 0x00, 0x01, 0x02, 0x03, 0xFF, 0xFE, 0xFD, 0xFC };
    const more_binary = [_]u8{ 0x10, 0x20, 0x30, 0x40, 0x50, 0x60, 0x70, 0x80 };

    {
        var logger = try OutputLogger.init(testing.allocator, test_file, false);
        defer logger.deinit();

        try logger.write(&binary_data);
        try logger.write(&more_binary);
        try logger.flush();
    }

    // Verify binary data integrity
    {
        const file = try std.fs.cwd().openFile(test_file, .{});
        defer file.close();

        var read_buffer: [16]u8 = undefined;
        const bytes_read = try file.readAll(&read_buffer);

        try testing.expectEqual(@as(usize, 16), bytes_read);

        // Check first chunk
        for (binary_data, 0..) |expected, i| {
            try testing.expectEqual(expected, read_buffer[i]);
        }

        // Check second chunk
        for (more_binary, 0..) |expected, i| {
            try testing.expectEqual(expected, read_buffer[8 + i]);
        }
    }
}

test "OutputLogger - comprehensive error recovery scenarios" {
    const testing = std.testing;

    // Test initialization with invalid directory
    const invalid_path = "/nonexistent/directory/file.txt";
    try testing.expectError(config.IOControlError.DirectoryNotFound, OutputLogger.init(testing.allocator, invalid_path, false));
    try testing.expectError(config.IOControlError.DirectoryNotFound, OutputLogger.init(testing.allocator, invalid_path, true));
}

test "mapFileError - comprehensive error mapping coverage" {
    const testing = std.testing;

    const test_path = "test_file.txt";

    // Test all error mappings
    const access_err = mapFileError(error.AccessDenied, test_path, "test");
    try testing.expectEqual(config.IOControlError.InsufficientPermissions, access_err);

    const notfound_err = mapFileError(error.FileNotFound, test_path, "test");
    try testing.expectEqual(config.IOControlError.DirectoryNotFound, notfound_err);

    const isdir_err = mapFileError(error.IsDir, test_path, "test");
    try testing.expectEqual(config.IOControlError.IsDirectory, isdir_err);

    const nospace_err = mapFileError(error.NoSpaceLeft, test_path, "test");
    try testing.expectEqual(config.IOControlError.DiskFull, nospace_err);

    const busy_err = mapFileError(error.FileBusy, test_path, "test");
    try testing.expectEqual(config.IOControlError.FileLocked, busy_err);

    const resource_busy_err = mapFileError(error.ResourceBusy, test_path, "test");
    try testing.expectEqual(config.IOControlError.FileLocked, resource_busy_err);

    const toolong_err = mapFileError(error.NameTooLong, test_path, "test");
    try testing.expectEqual(config.IOControlError.PathTooLong, toolong_err);

    const utf8_err = mapFileError(error.InvalidUtf8, test_path, "test");
    try testing.expectEqual(config.IOControlError.InvalidPathCharacters, utf8_err);

    const badpath_err = mapFileError(error.BadPathName, test_path, "test");
    try testing.expectEqual(config.IOControlError.InvalidPathCharacters, badpath_err);

    const notdir_err = mapFileError(error.NotDir, test_path, "test");
    try testing.expectEqual(config.IOControlError.DirectoryNotFound, notdir_err);

    const device_busy_err = mapFileError(error.DeviceBusy, test_path, "test");
    try testing.expectEqual(config.IOControlError.FileSystemError, device_busy_err);

    const system_resources_err = mapFileError(error.SystemResources, test_path, "test");
    try testing.expectEqual(config.IOControlError.FileSystemError, system_resources_err);

    const unknown_err = mapFileError(error.Unexpected, test_path, "test");
    try testing.expectEqual(config.IOControlError.OutputFileCreateFailed, unknown_err);
}

test "OutputLogger - multiple flush operations" {
    const testing = std.testing;

    const test_file = "test_output_flush.tmp";
    std.fs.cwd().deleteFile(test_file) catch {};
    defer std.fs.cwd().deleteFile(test_file) catch {};

    {
        var logger = try OutputLogger.init(testing.allocator, test_file, false);
        defer logger.deinit();

        try logger.write("Data 1");
        try logger.flush();

        try logger.write("Data 2");
        try logger.flush();

        try logger.write("Data 3");
        try logger.flush();
    }

    // Verify all data was written
    {
        const file = try std.fs.cwd().openFile(test_file, .{});
        defer file.close();

        const contents = try file.readToEndAlloc(testing.allocator, 1024);
        defer testing.allocator.free(contents);

        try testing.expectEqualStrings("Data 1Data 2Data 3", contents);
    }
}
</file>

<file path="io/tls_transfer.zig">
//! TLS transfer facade.
//!
//! Exposes the public API for TLS-aware transfers while delegating detailed
//! logic to focused modules under `io/tls_transfer/`.

const transfer = @import("tls_transfer/transfer.zig");
const errors = @import("tls_transfer/errors.zig");
const cleanup = @import("tls_transfer/cleanup.zig");

pub const BUFFER_SIZE = transfer.BUFFER_SIZE;

pub const TLSTransferError = errors.TLSTransferError;

pub const tlsBidirectionalTransfer = transfer.tlsBidirectionalTransfer;
pub const tlsBidirectionalTransferWindows = transfer.tlsBidirectionalTransferWindows;
pub const tlsBidirectionalTransferPosix = transfer.tlsBidirectionalTransferPosix;

pub const mapTlsError = errors.mapTlsError;
pub const getTlsErrorMessage = errors.getTlsErrorMessage;
pub const isTlsErrorRecoverable = errors.isTlsErrorRecoverable;
pub const handleTlsError = errors.handleTlsError;
pub const handleOutputError = errors.handleOutputError;
pub const printHexDump = errors.printHexDump;

pub const cleanupTlsTransferResources = cleanup.cleanupTlsTransferResources;

comptime {
    if (@import("builtin").is_test) {
        _ = @import("tls_transfer/tests.zig");
    }
}
</file>

<file path="io/transfer.zig">
//! Cross-platform I/O pipeline that mirrors ncat's interactive behavior.
//! This module owns the stdin/stdout  socket event loop used by both client
//! and server paths, layering Telnet processing, logging, throttling, and
//! TLS-specific variants on top of a shared poll/select abstraction.
const std = @import("std");
const posix = std.posix;
const config = @import("../config.zig");
const linecodec = @import("linecodec.zig");
const output = @import("output.zig");
const hexdump = @import("hexdump.zig");
const poll_wrapper = @import("../util/poll_wrapper.zig");
const telnet = @import("../protocol/telnet.zig");
const logging = @import("../util/logging.zig");

const BUFFER_SIZE = 8192;

/// Dispatches to the platform-specific transfer loop.
/// Non-Windows targets prefer the POSIX poll-based implementation, while the
/// fallback case intentionally reuses the Windows path because the select()
/// shim works anywhere Zig lacks native poll support (e.g. niche Unix targets).
pub fn bidirectionalTransfer(
    allocator: std.mem.Allocator,
    stream: std.net.Stream,
    cfg: *const config.Config,
    output_logger: ?*output.OutputLogger,
    hex_dumper: ?*hexdump.HexDumper,
) !void {
    switch (@import("builtin").os.tag) {
        .linux, .macos => {
            return bidirectionalTransferPosix(allocator, stream, cfg, output_logger, hex_dumper);
        },
        .windows => {
            return bidirectionalTransferWindows(allocator, stream, cfg, output_logger, hex_dumper);
        },
        else => {
            // share Windows path where poll() is unavailable; select() handles the two-fd case portably.
            return bidirectionalTransferWindows(allocator, stream, cfg, output_logger, hex_dumper);
        },
    }
}

/// Windows bidirectional transfer using poll-based event-driven I/O
/// Matches POSIX implementation for platform parity with timeout support
pub fn bidirectionalTransferWindows(
    allocator: std.mem.Allocator,
    stream: std.net.Stream,
    cfg: *const config.Config,
    output_logger: ?*output.OutputLogger,
    hex_dumper: ?*hexdump.HexDumper,
) !void {
    var buffer1: [BUFFER_SIZE]u8 = undefined;
    var buffer2: [BUFFER_SIZE]u8 = undefined;

    const stdin = std.fs.File.stdin();
    const stdout = std.fs.File.stdout();

    // Use poll-based event loop for timeout support and concurrent I/O
    var pollfds = [_]poll_wrapper.pollfd{
        .{ .fd = stdin.handle, .events = poll_wrapper.POLL.IN, .revents = 0 },
        .{ .fd = stream.handle, .events = poll_wrapper.POLL.IN, .revents = 0 },
    };

    // Determine which directions to enable
    const can_send = !cfg.recv_only;
    const can_recv = !cfg.send_only;

    var stdin_closed = false;
    var socket_closed = false;

    // Initialize Telnet processor if enabled
    var telnet_processor: ?telnet.TelnetProcessor = if (cfg.telnet)
        telnet.TelnetProcessor.init(allocator, "UNKNOWN", 80, 24)
    else
        null;
    defer if (telnet_processor) |*proc| proc.deinit();

    // Use unified timeout strategy (Windows doesn't have TTY, always 30s default)
    // Priority: explicit cfg.idle_timeout > platform default (30s)
    const timeout_ms = config.getConnectionTimeout(cfg, .tcp_server, null);

    while (!stdin_closed or !socket_closed) {
        // Set poll events based on what's still open and direction flags
        pollfds[0].events = if (!stdin_closed and can_send) poll_wrapper.POLL.IN else 0;
        pollfds[1].events = if (!socket_closed and can_recv) poll_wrapper.POLL.IN else 0;

        const ready = poll_wrapper.poll(&pollfds, timeout_ms) catch |err| {
            logging.logError(err, "Poll error");
            return err;
        };

        if (ready == 0) {
            // Idle timeout reached
            logging.logVerbose(cfg, "Idle timeout reached\n", .{});
            break;
        }

        // Check for stdin data (send to socket)
        if (pollfds[0].revents & poll_wrapper.POLL.IN != 0) {
            const n = stdin.read(&buffer1) catch 0;

            if (n == 0) {
                stdin_closed = true;

                // Handle half-close: shutdown write-half but keep reading (Windows)
                if (!cfg.no_shutdown) {
                    poll_wrapper.shutdown(stream.handle, .send) catch |err| {
                        logging.logVerbose(cfg, "Shutdown send failed: {any}\n", .{err});
                    };
                }

                if (cfg.close_on_eof) {
                    break;
                }
            } else {
                const input_slice = buffer1[0..n];
                const data = if (cfg.crlf)
                    // CRLF conversion has to allocate when translations occur; we keep
                    // zero-copy behavior for the common path where no conversion is required.
                    try linecodec.convertLfToCrlf(allocator, input_slice)
                else
                    input_slice;
                // Only free if a new buffer was allocated
                defer if (data.ptr != input_slice.ptr) allocator.free(data);

                _ = try stream.write(data);

                // Apply traffic shaping delay after send (Windows)
                if (cfg.delay_ms > 0) {
                    const delay_ns = cfg.delay_ms * std.time.ns_per_ms;
                    std.Thread.sleep(delay_ns);
                }

                logging.logVerbose(cfg, "Sent {any} bytes\n", .{data.len});
            }
        }

        // Check for socket data (send to stdout)
        if (pollfds[1].revents & poll_wrapper.POLL.IN != 0) {
            const n = stream.read(&buffer2) catch |err| {
                logging.logError(err, "Socket recv error");
                socket_closed = true;
                continue;
            };

            if (n == 0) {
                socket_closed = true;
                logging.logVerbose(cfg, "Connection closed by peer\n", .{});
            } else {
                var data = buffer2[0..n];

                // Process Telnet IAC sequences if enabled
                var telnet_response: ?[]u8 = null;
                if (telnet_processor) |*proc| {
                    const result = try proc.processInput(data);
                    defer allocator.free(result.data);

                    // Send Telnet response if negotiation generated one
                    if (result.response.len > 0) {
                        telnet_response = result.response;
                        // Flush negotiation bytes immediately so the peer's state machine
                        // receives acknowledgements before more payload arrives.
                        _ = try stream.write(result.response);
                        logging.logDebug("Sent Telnet negotiation: {any} bytes\n", .{result.response.len});
                    } else {
                        allocator.free(result.response);
                    }

                    // Use cleaned data for output
                    data = result.data;
                } else {
                    telnet_response = null;
                }
                defer if (telnet_response) |resp| allocator.free(resp);

                // Write to stdout (unless hex dump is enabled and replaces normal output)
                if (!cfg.hex_dump) {
                    try stdout.writeAll(data);
                }

                // Write to output file if logger is configured with error recovery
                if (output_logger) |logger| {
                    logger.write(data) catch |err| {
                        switch (err) {
                            config.IOControlError.DiskFull => {
                                logging.logNormal("Error: Disk full - stopping output logging to prevent data loss\n", .{});
                                // Continue without output logging
                            },
                            config.IOControlError.InsufficientPermissions => {
                                logging.logNormal("Error: Permission denied - stopping output logging\n", .{});
                                // Continue without output logging
                            },
                            else => {
                                logging.logVerbose(cfg, "Warning: Output logging failed: {any}\n", .{err});
                                // Continue without output logging for this data
                            },
                        }
                    };
                }

                // Hex dump if requested with error recovery
                if (cfg.hex_dump) {
                    if (hex_dumper) |dumper| {
                        dumper.dump(data) catch |err| {
                            switch (err) {
                                config.IOControlError.DiskFull => {
                                    logging.logNormal("Error: Disk full - stopping hex dump file logging\n", .{});
                                    // Continue with stdout hex dump only
                                    printHexDump(data);
                                },
                                config.IOControlError.InsufficientPermissions => {
                                    logging.logNormal("Error: Permission denied - stopping hex dump file logging\n", .{});
                                    // Continue with stdout hex dump only
                                    printHexDump(data);
                                },
                                else => {
                                    logging.logVerbose(cfg, "Warning: Hex dump file logging failed: {any}\n", .{err});
                                    // Keep user-visible output even when the logging path fails.
                                    // Fallback to stdout hex dump
                                    printHexDump(data);
                                },
                            }
                        };
                    } else {
                        // Fallback to inline hex dump if dumper not provided
                        printHexDump(data);
                    }
                }

                logging.logVerbose(cfg, "Received {any} bytes\n", .{n});
            }
        }

        // Check for errors (HUP, ERR, NVAL)
        if (pollfds[0].revents & (poll_wrapper.POLL.ERR | poll_wrapper.POLL.HUP | poll_wrapper.POLL.NVAL) != 0) {
            stdin_closed = true;
        }
        if (pollfds[1].revents & (poll_wrapper.POLL.ERR | poll_wrapper.POLL.HUP | poll_wrapper.POLL.NVAL) != 0) {
            socket_closed = true;
        }
    }

    // Flush output files before closing with proper error handling
    if (output_logger) |logger| {
        logger.flush() catch |err| {
            switch (err) {
                config.IOControlError.DiskFull => {
                    logging.logNormal("Critical: Output file flush failed - disk full. Data may be lost.\n", .{});
                },
                config.IOControlError.InsufficientPermissions => {
                    logging.logNormal("Critical: Output file flush failed - permission denied. Data may be lost.\n", .{});
                },
                else => {
                    logging.logVerbose(cfg, "Warning: Failed to flush output file: {any}\n", .{err});
                },
            }
        };
    }

    if (hex_dumper) |dumper| {
        dumper.flush() catch |err| {
            switch (err) {
                config.IOControlError.DiskFull => {
                    logging.logNormal("Critical: Hex dump file flush failed - disk full. Data may be lost.\n", .{});
                },
                config.IOControlError.InsufficientPermissions => {
                    logging.logNormal("Critical: Hex dump file flush failed - permission denied. Data may be lost.\n", .{});
                },
                else => {
                    logging.logVerbose(cfg, "Warning: Failed to flush hex dump file: {any}\n", .{err});
                },
            }
        };
    }
}

/// Bidirectional data transfer between stdin/stdout and socket
pub fn bidirectionalTransferPosix(
    allocator: std.mem.Allocator,
    stream: std.net.Stream,
    cfg: *const config.Config,
    output_logger: ?*output.OutputLogger,
    hex_dumper: ?*hexdump.HexDumper,
) !void {
    var buffer1: [BUFFER_SIZE]u8 = undefined;
    var buffer2: [BUFFER_SIZE]u8 = undefined;

    const stdin = std.fs.File.stdin();
    const stdout = std.fs.File.stdout();

    var pollfds = [_]poll_wrapper.pollfd{
        .{ .fd = stdin.handle, .events = poll_wrapper.POLL.IN, .revents = 0 },
        .{ .fd = stream.handle, .events = poll_wrapper.POLL.IN, .revents = 0 },
    };

    // Determine which directions to enable
    const can_send = !cfg.recv_only;
    const can_recv = !cfg.send_only;

    var stdin_closed = false;
    var socket_closed = false;

    // Initialize Telnet processor if enabled
    var telnet_processor: ?telnet.TelnetProcessor = if (cfg.telnet)
        telnet.TelnetProcessor.init(allocator, "UNKNOWN", 80, 24)
    else
        null;
    defer if (telnet_processor) |*proc| proc.deinit();

    // Use unified timeout strategy (respects --idle-timeout, then TTY detection)
    // Priority: explicit cfg.idle_timeout > TTY detection > platform default
    const timeout_ms = config.getConnectionTimeout(cfg, .tcp_server, stdin.handle);

    while (!stdin_closed or !socket_closed) {
        // Set poll events based on what's still open
        pollfds[0].events = if (!stdin_closed and can_send) poll_wrapper.POLL.IN else 0;
        pollfds[1].events = if (!socket_closed and can_recv) poll_wrapper.POLL.IN else 0;

        const ready = poll_wrapper.poll(&pollfds, timeout_ms) catch |err| {
            logging.logError(err, "Poll error");
            return err;
        };

        if (ready == 0) {
            // Timeout
            logging.logVerbose(cfg, "Idle timeout reached\n", .{});
            break;
        }

        // Check for stdin data (send to socket)
        if (pollfds[0].revents & poll_wrapper.POLL.IN != 0) {
            const n = stdin.read(&buffer1) catch 0;

            if (n == 0) {
                stdin_closed = true;

                // Handle half-close: shutdown write-half but keep reading
                if (!cfg.no_shutdown) {
                    posix.shutdown(stream.handle, .send) catch |err| {
                        logging.logVerbose(cfg, "Shutdown send failed: {any}\n", .{err});
                    };
                }

                if (cfg.close_on_eof) {
                    break;
                }
            } else {
                const input_slice = buffer1[0..n];
                const data = if (cfg.crlf)
                    // CRLF translation allocates only when new bytes are needed; otherwise
                    // we reuse the original slice to keep the hot path zero-copy.
                    try linecodec.convertLfToCrlf(allocator, input_slice)
                else
                    input_slice;
                // Only free if a new buffer was allocated
                defer if (data.ptr != input_slice.ptr) allocator.free(data);

                _ = try posix.send(stream.handle, data, 0);

                // Apply traffic shaping delay after send
                if (cfg.delay_ms > 0) {
                    const delay_ns = cfg.delay_ms * std.time.ns_per_ms;
                    std.Thread.sleep(delay_ns);
                }

                logging.logVerbose(cfg, "Sent {any} bytes\n", .{data.len});
            }
        }

        // Check for socket data (send to stdout)
        if (pollfds[1].revents & poll_wrapper.POLL.IN != 0) {
            const n = posix.recv(stream.handle, &buffer2, 0) catch |err| {
                logging.logError(err, "Socket recv error");
                socket_closed = true;
                continue;
            };

            if (n == 0) {
                socket_closed = true;
                logging.logVerbose(cfg, "Connection closed by peer\n", .{});
            } else {
                var data = buffer2[0..n];

                // Process Telnet IAC sequences if enabled
                var telnet_response: ?[]u8 = null;
                if (telnet_processor) |*proc| {
                    const result = try proc.processInput(data);
                    defer allocator.free(result.data);

                    // Send Telnet response if negotiation generated one
                    if (result.response.len > 0) {
                        telnet_response = result.response;
                        // Telnet replies must go out immediately so the negotiation state on
                        // both sides stays synchronized; buffering delays can trigger loops.
                        _ = try posix.send(stream.handle, result.response, 0);
                        logging.logDebug("Sent Telnet negotiation: {any} bytes\n", .{result.response.len});
                    } else {
                        allocator.free(result.response);
                    }

                    // Use cleaned data for output
                    data = result.data;
                } else {
                    telnet_response = null;
                }
                defer if (telnet_response) |resp| allocator.free(resp);

                // Write to stdout (unless hex dump is enabled and replaces normal output)
                if (!cfg.hex_dump) {
                    try stdout.writeAll(data);
                }

                // Write to output file if logger is configured with error recovery
                if (output_logger) |logger| {
                    logger.write(data) catch |err| {
                        switch (err) {
                            config.IOControlError.DiskFull => {
                                logging.logNormal("Error: Disk full - stopping output logging to prevent data loss\n", .{});
                                // Continue without output logging
                            },
                            config.IOControlError.InsufficientPermissions => {
                                logging.logNormal("Error: Permission denied - stopping output logging\n", .{});
                                // Continue without output logging
                            },
                            else => {
                                logging.logVerbose(cfg, "Warning: Output logging failed: {any}\n", .{err});
                                // Continue without output logging for this data
                            },
                        }
                    };
                }

                // Hex dump if requested with error recovery
                if (cfg.hex_dump) {
                    if (hex_dumper) |dumper| {
                        dumper.dump(data) catch |err| {
                            switch (err) {
                                config.IOControlError.DiskFull => {
                                    logging.logNormal("Error: Disk full - stopping hex dump file logging\n", .{});
                                    // Continue with stdout hex dump only
                                    printHexDump(data);
                                },
                                config.IOControlError.InsufficientPermissions => {
                                    logging.logNormal("Error: Permission denied - stopping hex dump file logging\n", .{});
                                    // Continue with stdout hex dump only
                                    printHexDump(data);
                                },
                                else => {
                                    logging.logVerbose(cfg, "Warning: Hex dump file logging failed: {any}\n", .{err});
                                    // Ensure the operator still sees the bytes even if the file path fails.
                                    // Fallback to stdout hex dump
                                    printHexDump(data);
                                },
                            }
                        };
                    } else {
                        // Fallback to inline hex dump if dumper not provided
                        printHexDump(data);
                    }
                }

                logging.logVerbose(cfg, "Received {any} bytes\n", .{n});
            }
        }

        // Check for errors
        if (pollfds[0].revents & (poll_wrapper.POLL.ERR | poll_wrapper.POLL.HUP | poll_wrapper.POLL.NVAL) != 0) {
            stdin_closed = true;
        }
        if (pollfds[1].revents & (poll_wrapper.POLL.ERR | poll_wrapper.POLL.HUP | poll_wrapper.POLL.NVAL) != 0) {
            socket_closed = true;
        }
    }

    // Flush output files before closing with proper error handling
    if (output_logger) |logger| {
        logger.flush() catch |err| {
            switch (err) {
                config.IOControlError.DiskFull => {
                    logging.logNormal("Critical: Output file flush failed - disk full. Data may be lost.\n", .{});
                },
                config.IOControlError.InsufficientPermissions => {
                    logging.logNormal("Critical: Output file flush failed - permission denied. Data may be lost.\n", .{});
                },
                else => {
                    logging.logVerbose(cfg, "Warning: Failed to flush output file: {any}\n", .{err});
                },
            }
        };
    }

    if (hex_dumper) |dumper| {
        dumper.flush() catch |err| {
            switch (err) {
                config.IOControlError.DiskFull => {
                    logging.logNormal("Critical: Hex dump file flush failed - disk full. Data may be lost.\n", .{});
                },
                config.IOControlError.InsufficientPermissions => {
                    logging.logNormal("Critical: Hex dump file flush failed - permission denied. Data may be lost.\n", .{});
                },
                else => {
                    logging.logVerbose(cfg, "Warning: Failed to flush hex dump file: {any}\n", .{err});
                },
            }
        };
    }
}

fn printHexDump(data: []const u8) void {
    var i: usize = 0;
    while (i < data.len) : (i += 16) {
        std.debug.print("{x:0>8}: ", .{i});

        // Hex bytes
        var j: usize = 0;
        while (j < 16) : (j += 1) {
            if (i + j < data.len) {
                std.debug.print("{x:0>2} ", .{data[i + j]});
            } else {
                std.debug.print("   ", .{});
            }
        }

        std.debug.print(" |", .{});

        // ASCII representation
        j = 0;
        while (j < 16 and i + j < data.len) : (j += 1) {
            const c = data[i + j];
            if (c >= 32 and c <= 126) {
                std.debug.print("{c}", .{c});
            } else {
                std.debug.print(".", .{});
            }
        }

        std.debug.print("|\n", .{});
    }
}
</file>

<file path="main/modes/broker.zig">
//! Broker/chat server bootstrap.

const std = @import("std");

const config = @import("../../config.zig");
const logging = @import("../../util/logging.zig");
const allowlist = @import("../../net/allowlist.zig");
const broker = @import("../../server/broker.zig");

pub fn runBrokerServer(
    allocator: std.mem.Allocator,
    listen_socket: std.posix.socket_t,
    cfg: *const config.Config,
    access_list: *allowlist.AccessList,
) !void {
    logging.setVerbosity(cfg.verbose_level);

    const mode: broker.BrokerMode = if (cfg.chat_mode) .chat else .broker;

    logging.log(1, "Starting {any} server on socket {}\n", .{ mode, listen_socket });
    logging.logDebug("Server configuration:\n", .{});
    logging.logDebug("  Max clients: {}\n", .{cfg.max_clients});
    logging.logDebug("  TLS enabled: {}\n", .{cfg.ssl});
    logging.logDebug("  Connect timeout: {}ms\n", .{cfg.connect_timeout});
    logging.logDebug("  Idle timeout: {}ms\n", .{cfg.idle_timeout});
    logging.logDebug("  Access control rules: {} allow, {} deny\n", .{
        access_list.allow_rules.items.len,
        access_list.deny_rules.items.len,
    });

    if (mode == .chat) {
        logging.logDebug("  Chat mode settings:\n", .{});
        logging.logDebug("    Max nickname length: {}\n", .{cfg.chat_max_nickname_len});
        logging.logDebug("    Max message length: {}\n", .{cfg.chat_max_message_len});
    }

    if (cfg.ssl) {
        logging.logDebug("  TLS configuration:\n", .{});
        logging.logDebug("    Certificate: {?s}\n", .{cfg.ssl_cert});
        logging.logDebug("    Private key: {?s}\n", .{cfg.ssl_key});
        logging.logDebug("    Verify peer: {}\n", .{cfg.ssl_verify});
    }

    var broker_server = broker.BrokerServer.init(
        allocator,
        listen_socket,
        mode,
        cfg,
        access_list,
    ) catch |err| {
        logging.logError(err, "broker server initialization");
        return err;
    };
    defer broker_server.deinit();

    logging.logDebug("Broker server initialized, entering main event loop\n", .{});

    broker_server.run() catch |err| {
        switch (err) {
            broker.BrokerError.MaxClientsReached => {
                logging.logDebug("Broker server: Maximum clients reached, continuing\n", .{});
            },
            broker.BrokerError.MultiplexingError => {
                logging.logError(err, "I/O multiplexing");
                return err;
            },
            broker.BrokerError.ListenSocketError => {
                logging.logError(err, "listen socket");
                return err;
            },
            broker.BrokerError.OutOfMemory => {
                logging.logError(err, "memory allocation");
                return err;
            },
            broker.BrokerError.InvalidConfiguration => {
                logging.logError(err, "configuration validation");
                return err;
            },
            else => {
                logging.logError(err, "broker server");
                logging.logWarning("Broker server encountered error, attempting graceful shutdown\n", .{});
            },
        }
    };

    logging.log(1, "Broker server shutdown complete\n", .{});
}
</file>

<file path="main/modes/server.zig">
//! Server/broker entrypoints for zigcat.

const std = @import("std");
const posix = std.posix;

const config = @import("../../config.zig");
const common = @import("../common.zig");
const logging = @import("../../util/logging.zig");

const net = @import("../../net/socket.zig");
const tcp = @import("../../net/tcp.zig");
const udp = @import("../../net/udp.zig");
const unixsock = @import("../../net/unixsock.zig");
const allowlist = @import("../../net/allowlist.zig");
const listen = @import("../../server/listen.zig");
const exec = @import("../../server/exec.zig");
const security = @import("../../util/security.zig");
const tls = @import("../../tls/tls.zig");
const client = @import("../../client.zig");
const output = @import("../../io/output.zig");
const hexdump = @import("../../io/hexdump.zig");
const transfer = @import("../../io/transfer.zig");
const tls_transfer = @import("../../io/tls_transfer.zig");
const Connection = @import("../../net/connection.zig").Connection;
const TelnetConnection = @import("../../protocol/telnet_connection.zig").TelnetConnection;

const broker_mode = @import("broker.zig");
const unix_mode = @import("unix.zig");

pub fn runServer(allocator: std.mem.Allocator, cfg: *const config.Config) !void {
    if (cfg.unix_socket_path) |socket_path| {
        return unix_mode.runUnixSocketServer(allocator, cfg, socket_path);
    }

    const port = if (cfg.positional_args.len > 0)
        try std.fmt.parseInt(u16, cfg.positional_args[0], 10)
    else
        0;

    const bind_addr_str = if (cfg.bind_addr) |addr|
        addr
    else if (cfg.listen_mode and cfg.positional_args.len > 1)
        cfg.positional_args[1]
    else
        "0.0.0.0";

    const bind_addr = try std.net.Address.resolveIp(bind_addr_str, port);

    const should_drop_privileges = cfg.drop_privileges_user != null;
    const is_privileged_port = port < 1024;

    if (should_drop_privileges and !is_privileged_port) {
        try security.dropPrivileges(cfg.drop_privileges_user.?);
    }

    if (cfg.verbose) {
        logging.logVerbose(cfg, "Server configuration:\n", .{});
        logging.logVerbose(cfg, "  Bind address: {s}:{d}\n", .{ bind_addr_str, port });
        logging.logVerbose(cfg, "  Protocol: {s}\n", .{if (cfg.udp_mode) "UDP" else "TCP"});
        logging.logVerbose(cfg, "  Keep-open: {}\n", .{cfg.keep_listening});
        logging.logVerbose(cfg, "  Max connections: {}\n", .{cfg.max_conns});
        if (cfg.exec_command) |cmd| {
            logging.logVerbose(cfg, "  Exec command: {s}\n", .{cmd});
        }
        if (cfg.shell_command) |cmd| {
            logging.logVerbose(cfg, "  Shell command: {s}\n", .{cmd});
        }
    }

    const has_access_control = cfg.allow_list.items.len > 0 or cfg.deny_list.items.len > 0 or cfg.allow_file != null or cfg.deny_file != null;

    if (cfg.udp_mode) {
        const udp_socket = try udp.openUdpServer(bind_addr_str, port);
        defer net.closeSocket(udp_socket);

        if (should_drop_privileges and is_privileged_port) {
            try security.dropPrivileges(cfg.drop_privileges_user.?);
        }

        logging.logNormal(cfg, "Listening on {s}:{d} (UDP)...\n", .{ bind_addr_str, port });
        try handleUdpServer(allocator, udp_socket, cfg);
        return;
    }

    if (cfg.sctp_mode) {
        logging.logWarning("Note: SCTP mode not fully implemented\n", .{});
    }

    var server = try bind_addr.listen(.{ .reuse_address = true });
    defer server.deinit();

    if (should_drop_privileges and is_privileged_port) {
        try security.dropPrivileges(cfg.drop_privileges_user.?);
    }

    var access_list_obj: ?allowlist.AccessList = null;
    defer if (access_list_obj) |*al| al.deinit();

    if (has_access_control) {
        access_list_obj = try listen.createAccessListFromConfig(allocator, cfg);
        if (cfg.verbose) {
            logging.logVerbose(cfg, "Access control enabled:\n", .{});
            logging.logVerbose(cfg, "  Allow rules: {any}\n", .{access_list_obj.?.allow_rules.items.len});
            logging.logVerbose(cfg, "  Deny rules: {any}\n", .{access_list_obj.?.deny_rules.items.len});
        }
    }

    if (cfg.broker_mode or cfg.chat_mode) {
        var default_access_list = allowlist.AccessList.init(allocator);
        defer if (access_list_obj == null) default_access_list.deinit();
        const access_list_ptr = if (access_list_obj) |*al| al else &default_access_list;
        try broker_mode.runBrokerServer(allocator, server.stream.handle, cfg, access_list_ptr);
        return;
    }

    logging.logNormal(cfg, "Listening on {s}:{d}...\n", .{ bind_addr_str, port });

    var connection_count: u32 = 0;

    while (!common.shutdown_requested.load(.seq_cst)) {
        if (cfg.verbose and cfg.keep_listening) {
            logging.logVerbose(cfg, "Waiting for next connection...\n", .{});
        }

        const conn = if (access_list_obj) |*al|
            listen.acceptWithAccessControl(&server, al, cfg.verbose) catch |err| {
                if (common.shutdown_requested.load(.seq_cst)) {
                    if (cfg.verbose) {
                        logging.logVerbose(cfg, "Server shutdown requested, stopping accept loop\n", .{});
                    }
                    break;
                }
                return err;
            }
        else
            server.accept() catch |err| {
                if (common.shutdown_requested.load(.seq_cst)) {
                    if (cfg.verbose) {
                        logging.logVerbose(cfg, "Server shutdown requested, stopping accept loop\n", .{});
                    }
                    break;
                }
                return err;
            };

        if (common.shutdown_requested.load(.seq_cst)) {
            conn.stream.close();
            break;
        }

        connection_count += 1;

        if (cfg.verbose) {
            logging.logVerbose(cfg, "Accepted connection #{any} from {any}\n", .{ connection_count, conn.address });
        }

        if (cfg.max_conns > 0 and connection_count > cfg.max_conns) {
            if (cfg.verbose) {
                logging.logVerbose(cfg, "Max connections ({any}) reached, closing new connection.\n", .{cfg.max_conns});
            }
            conn.stream.close();
            continue;
        }

        if (cfg.max_conns > 0) {
            const ctx = try allocator.create(ThreadContext);
            ctx.* = .{
                .allocator = allocator,
                .conn = conn,
                .cfg = cfg,
            };

            var thread = try std.Thread.spawn(.{}, handleClientThread, .{ctx});
            thread.detach();
        } else {
            handleClient(allocator, conn.stream, conn.address, cfg) catch |err| {
                logging.logError(err, "handling client");
            };
            conn.stream.close();
        }

        if (!cfg.keep_listening) {
            break;
        }
    }

    if (common.shutdown_requested.load(.seq_cst)) {
        logging.logNormal(cfg, "Server shutting down gracefully...\n", .{});
    }
}

const ThreadContext = struct {
    allocator: std.mem.Allocator,
    conn: std.net.Server.Connection,
    cfg: *const config.Config,
};

fn handleClientThread(ctx: *ThreadContext) void {
    defer ctx.allocator.destroy(ctx);
    defer ctx.conn.stream.close();

    handleClient(ctx.allocator, ctx.conn.stream, ctx.conn.address, ctx.cfg) catch |err| {
        logging.logError(err, "client handler");
    };
}

fn handleClient(
    allocator: std.mem.Allocator,
    stream: std.net.Stream,
    client_address: std.net.Address,
    cfg: *const config.Config,
) !void {
    if (cfg.verbose) {
        logging.logVerbose(cfg, "Handling client from {any}\n", .{client_address});
    }

    if (cfg.exec_command != null or cfg.shell_command != null) {
        const exec_config = if (cfg.exec_command) |prog| blk: {
            break :blk exec.ExecConfig{
                .mode = .direct,
                .program = prog,
                .args = cfg.exec_args.items,
                .require_allow = cfg.require_allow_with_exec,
                .session_config = config.buildExecSessionConfig(cfg),
                .redirect_stdin = cfg.exec_redirect_stdin,
                .redirect_stdout = cfg.exec_redirect_stdout,
                .redirect_stderr = cfg.exec_redirect_stderr,
            };
        } else blk: {
            const shell_cmd = try exec.buildShellCommand(allocator, cfg.shell_command.?);
            defer allocator.free(shell_cmd.args);

            break :blk exec.ExecConfig{
                .mode = .shell,
                .program = shell_cmd.program,
                .args = shell_cmd.args,
                .require_allow = cfg.require_allow_with_exec,
                .session_config = config.buildExecSessionConfig(cfg),
                .redirect_stdin = cfg.exec_redirect_stdin,
                .redirect_stdout = cfg.exec_redirect_stdout,
                .redirect_stderr = cfg.exec_redirect_stderr,
            };
        };

        if (cfg.telnet) {
            const connection = Connection.fromSocket(stream.handle);
            var telnet_conn = try TelnetConnection.init(connection, allocator, null, null, null);
            defer telnet_conn.deinit();

            if (cfg.verbose) {
                logging.logVerbose(cfg, "Telnet protocol mode enabled for exec mode (server), performing server negotiation...\n", .{});
            }

            try telnet_conn.performServerNegotiation();
            try exec.executeWithTelnetConnection(allocator, &telnet_conn, exec_config, client_address);
        } else {
            try exec.executeWithConnection(allocator, stream, exec_config, client_address);
        }
        return;
    }

    var output_logger = output.OutputLogger.init(allocator, cfg.output_file, cfg.append_output) catch |err| {
        common.handleIOInitError(cfg, err, "output logger");
        return err;
    };
    defer output_logger.deinit();

    var hex_dumper = hexdump.HexDumper.init(allocator, cfg.hex_dump_file) catch |err| {
        common.handleIOInitError(cfg, err, "hex dumper");
        return err;
    };
    defer hex_dumper.deinit();

    if (cfg.verbose) {
        if (output_logger.isEnabled()) {
            const mode = if (output_logger.isAppendMode()) "append" else "truncate";
            logging.logVerbose(cfg, "Output logging enabled: {s} (mode: {s})\n", .{ output_logger.getPath().?, mode });
        }
        if (hex_dumper.isFileEnabled()) {
            logging.logVerbose(cfg, "Hex dump file enabled: {s}\n", .{hex_dumper.getPath().?});
        }
        if (cfg.hex_dump and !hex_dumper.isFileEnabled()) {
            logging.logVerbose(cfg, "Hex dump to stdout enabled\n", .{});
        }
        if (cfg.send_only) {
            logging.logVerbose(cfg, "I/O mode: send-only\n", .{});
        } else if (cfg.recv_only) {
            logging.logVerbose(cfg, "I/O mode: receive-only\n", .{});
        }
    }

    if (cfg.ssl) {
        if (!cfg.ssl_verify) {
            logging.logWarning("  SSL certificate verification is DISABLED in server mode.", .{});
        }

        const tls_config = tls.TlsConfig{
            .cert_file = cfg.ssl_cert,
            .key_file = cfg.ssl_key,
            .verify_peer = cfg.ssl_verify,
            .trust_file = cfg.ssl_trustfile,
            .crl_file = cfg.ssl_crl,
            .cipher_suites = cfg.ssl_ciphers,
            .server_name = cfg.ssl_servername,
            .alpn_protocols = cfg.ssl_alpn,
        };

        if (tls.isTlsEnabled()) {
            var tls_conn = try tls.acceptTls(allocator, stream.handle, tls_config);
            defer tls_conn.deinit();

            if (cfg.telnet) {
                const telnet_connection = Connection.fromTls(tls_conn);
                var telnet_conn = try TelnetConnection.init(telnet_connection, allocator, null, null, null);
                defer telnet_conn.deinit();

                try telnet_conn.performServerNegotiation();
                try client.telnetBidirectionalTransfer(allocator, .{ .telnet_conn = &telnet_conn }, cfg, &output_logger, &hex_dumper);
            } else {
                try tls_transfer.tlsBidirectionalTransfer(allocator, &tls_conn, cfg, &output_logger, &hex_dumper);
            }
            return;
        } else {
            tls.displayTlsNotAvailableError();
            return error.TlsNotEnabled;
        }
    }

    if (cfg.telnet) {
        const connection = Connection.fromSocket(stream.handle);
        var telnet_conn = try TelnetConnection.init(connection, allocator, null, null, null);
        defer telnet_conn.deinit();

        try telnet_conn.performServerNegotiation();
        try client.telnetBidirectionalTransfer(allocator, .{ .telnet_conn = &telnet_conn }, cfg, &output_logger, &hex_dumper);
    } else {
        try transfer.bidirectionalTransfer(allocator, stream, cfg, &output_logger, &hex_dumper);
    }
}

fn handleUdpServer(
    allocator: std.mem.Allocator,
    socket: std.posix.socket_t,
    cfg: *const config.Config,
) !void {
    var buffer: [8192]u8 = undefined;
    var client_map = std.AutoHashMap([64]u8, u32).init(allocator);
    defer client_map.deinit();

    var connection_count: u32 = 0;

    while (!common.shutdown_requested.load(.seq_cst)) {
        var pollfds = [_]posix.pollfd{
            .{
                .fd = socket,
                .events = posix.POLL.IN,
                .revents = 0,
            },
        };

        // Use unified timeout strategy (UDP uses 30s default, changed from 1s for consistency)
        const timeout_ms = config.getConnectionTimeout(cfg, .udp_server, null);

        const ready = posix.poll(&pollfds, timeout_ms) catch |err| {
            if (common.shutdown_requested.load(.seq_cst)) {
                if (cfg.verbose) {
                    logging.logVerbose(cfg, "UDP server shutdown requested during poll\n", .{});
                }
                break;
            }
            logging.logError(err, "poll");
            return err;
        };

        if (ready == 0) {
            if (common.shutdown_requested.load(.seq_cst)) {
                if (cfg.verbose) {
                    logging.logVerbose(cfg, "UDP server shutdown requested\n", .{});
                }
                break;
            }

            if (cfg.idle_timeout > 0) {
                if (cfg.verbose) {
                    logging.logVerbose(cfg, "UDP server idle timeout reached\n", .{});
                }
                break;
            }

            continue;
        }

        if (pollfds[0].revents & (posix.POLL.ERR | posix.POLL.HUP | posix.POLL.NVAL) != 0) {
            logging.logError(error.SocketError, "UDP server socket");
            break;
        }

        const result = udp.recvFromUdp(socket, &buffer) catch |err| {
            if (cfg.verbose) {
                logging.logVerbose(cfg, "UDP recv error: {}\n", .{err});
            }
            continue;
        };

        var addr_key: [64]u8 = [_]u8{0} ** 64;
        const addr_str = try std.fmt.bufPrint(&addr_key, "{any}", .{result.addr});
        _ = addr_str; // addr_key already contains the formatted address
        const entry = try client_map.getOrPut(addr_key);
        if (!entry.found_existing) {
            connection_count += 1;
            entry.value_ptr.* = connection_count;

            if (cfg.verbose) {
                logging.logVerbose(cfg, "New UDP client #{d} from {any}\n", .{ connection_count, result.addr });
            }
        }

        if (cfg.verbose) {
            logging.logVerbose(cfg, "Received {d} bytes from {any}\n", .{ result.bytes, result.addr });
        }

        if (cfg.exec_command != null or cfg.shell_command != null) {
            logging.logWarning("Exec mode with UDP is not fully supported\n", .{});
            logging.logNormal(cfg, "{s}\n", .{buffer[0..result.bytes]});
        } else {
            const data = buffer[0..result.bytes];
            // Data output handled by output_logger and hex_dumper below

            var output_logger = output.OutputLogger.init(allocator, cfg.output_file, cfg.append_output) catch |err| blk: {
                if (cfg.verbose) {
                    logging.logWarning("Failed to initialize output logger for UDP: {}\n", .{err});
                }
                break :blk output.OutputLogger.init(allocator, null, false) catch unreachable;
            };
            defer output_logger.deinit();

            var hex_dumper = hexdump.HexDumper.init(allocator, cfg.hex_dump_file) catch |err| blk: {
                if (cfg.verbose) {
                    logging.logWarning("Failed to initialize hex dumper for UDP: {}\n", .{err});
                }
                break :blk hexdump.HexDumper.init(allocator, null) catch unreachable;
            };
            defer hex_dumper.deinit();

            output_logger.write(data) catch |err| {
                if (cfg.verbose) {
                    logging.logWarning("Failed to write to output file: {}\n", .{err});
                }
            };

            if (cfg.hex_dump) {
                hex_dumper.dump(data) catch |err| {
                    if (cfg.verbose) {
                        logging.logWarning("Failed to write hex dump: {}\n", .{err});
                    }
                };
            }

            if (!cfg.recv_only) {
                _ = udp.sendToUdp(socket, data, result.addr) catch |err| {
                    if (cfg.verbose) {
                        logging.logVerbose(cfg, "Failed to send response: {}\n", .{err});
                    }
                };
            }
        }

        if (!cfg.keep_listening) {
            if (cfg.verbose) {
                logging.logVerbose(cfg, "Not in keep-listening mode, exiting after first datagram\n", .{});
            }
            break;
        }
    }

    if (common.shutdown_requested.load(.seq_cst)) {
        logging.logNormal(cfg, "UDP server shutting down gracefully...\n", .{});
    }

    if (cfg.verbose) {
        logging.logVerbose(cfg, "UDP server shutting down, handled {d} unique clients\n", .{connection_count});
    }
}
</file>

<file path="main/modes/unix.zig">
//! Unix domain socket server helpers.

const std = @import("std");
const posix = std.posix;

const config = @import("../../config.zig");
const common = @import("../common.zig");
const logging = @import("../../util/logging.zig");
const unixsock = @import("../../net/unixsock.zig");
const security = @import("../../util/security.zig");
const output = @import("../../io/output.zig");
const hexdump = @import("../../io/hexdump.zig");
const exec = @import("../../server/exec.zig");
const client = @import("../../client.zig");
const transfer = @import("../../io/transfer.zig");
const Connection = @import("../../net/connection.zig").Connection;
const TelnetConnection = @import("../../protocol/telnet_connection.zig").TelnetConnection;

pub fn runUnixSocketServer(allocator: std.mem.Allocator, cfg: *const config.Config, socket_path: []const u8) !void {
    if (!unixsock.unix_socket_supported) {
        logging.logError(error.UnixSocketsNotSupported, "Unix domain sockets not supported on this platform");
        return error.UnixSocketsNotSupported;
    }

    if (cfg.ssl) {
        logging.logError(error.InvalidConfiguration, "TLS not meaningful with Unix domain sockets (local communication)");
        return error.InvalidConfiguration;
    }

    if (cfg.udp_mode) {
        logging.logError(error.InvalidConfiguration, "UDP mode not supported with Unix domain sockets");
        return error.InvalidConfiguration;
    }

    if (cfg.verbose) {
        logging.logVerbose(cfg, "Unix socket server configuration:\n", .{});
        logging.logVerbose(cfg, "  Socket path: {s}\n", .{socket_path});
        logging.logVerbose(cfg, "  Keep-open: {}\n", .{cfg.keep_listening});
        logging.logVerbose(cfg, "  Max connections: {}\n", .{cfg.max_conns});
        logging.logVerbose(cfg, "  Connect timeout: {}ms\n", .{cfg.connect_timeout});
        logging.logVerbose(cfg, "  Idle timeout: {}ms\n", .{cfg.idle_timeout});
        if (cfg.exec_command) |cmd| {
            logging.logVerbose(cfg, "  Exec command: {s}\n", .{cmd});
        }
        if (cfg.shell_command) |cmd| {
            logging.logVerbose(cfg, "  Shell command: {s}\n", .{cmd});
        }
    }

    try unixsock.validatePath(socket_path);

    if (cfg.drop_privileges_user) |user| {
        try security.dropPrivileges(user);
    }

    var unix_server = unixsock.UnixSocket.initServer(allocator, socket_path) catch |err| {
        logging.logError(err, "creating Unix socket server");
        logging.logWarning("  Socket path: {s}\n", .{socket_path});
        logging.logWarning("  Check path, permissions, and available resources\n", .{});
        return err;
    };
    defer unix_server.cleanup();

    logging.logNormal(cfg, "Listening on Unix socket: {s}\n", .{socket_path});

    if (cfg.broker_mode or cfg.chat_mode) {
        logging.logError(error.NotImplemented, "Broker/Chat mode not yet supported with Unix domain sockets");
        return error.NotImplemented;
    }

    var connection_count: u32 = 0;

    while (!common.shutdown_requested.load(.seq_cst)) {
        if (cfg.verbose and cfg.keep_listening) {
            logging.logVerbose(cfg, "Waiting for next Unix socket connection...\n", .{});
        }

        var client_conn = acceptUnixSocketWithTimeout(&unix_server, cfg) catch |err| {
            switch (err) {
                error.AcceptTimeout => {
                    if (common.shutdown_requested.load(.seq_cst)) {
                        if (cfg.verbose) {
                            logging.logVerbose(cfg, "Unix socket server shutdown requested\n", .{});
                        }
                        break;
                    }
                    if (cfg.verbose) {
                        logging.logVerbose(cfg, "Unix socket accept timeout, continuing\n", .{});
                    }
                    continue;
                },
                else => return err,
            }
        };

        const stream = std.net.Stream{ .handle = client_conn.getSocket() };
        const unix_addr = std.net.Address.initUnix(client_conn.getPath()) catch |err| {
            client_conn.close();
            return err;
        };

        connection_count += 1;

        if (cfg.verbose) {
            logging.logVerbose(cfg, "Unix socket connection #{d} from {s}\n", .{ connection_count, client_conn.getPath() });
        }

        if (cfg.max_conns > 0 and connection_count > cfg.max_conns) {
            if (cfg.verbose) {
                logging.logVerbose(cfg, "Max connections ({any}) reached, closing new Unix connection.\n", .{cfg.max_conns});
            }
            client_conn.close();
            continue;
        }

        if (cfg.max_conns > 0) {
            const ctx = try allocator.create(UnixThreadContext);
            ctx.* = .{
                .allocator = allocator,
                .conn = client_conn,
                .cfg = cfg,
                .connection_id = connection_count,
            };

            var thread = try std.Thread.spawn(.{}, handleUnixClientThread, .{ctx});
            thread.detach();
        } else {
            handleUnixSocketClient(allocator, stream, unix_addr, cfg, connection_count) catch |err| {
                logging.logError(err, "Unix socket client handler");
            };
            client_conn.close();
        }

        if (!cfg.keep_listening) {
            if (cfg.verbose) {
                logging.logVerbose(cfg, "Not in keep-listening mode, exiting\n", .{});
            }
            break;
        }
    }

    if (common.shutdown_requested.load(.seq_cst)) {
        logging.logNormal(cfg, "Unix socket server shutting down gracefully...\n", .{});
    }
}

const UnixThreadContext = struct {
    allocator: std.mem.Allocator,
    conn: unixsock.UnixSocket,
    cfg: *const config.Config,
    connection_id: u32,
};

fn handleUnixClientThread(ctx: *UnixThreadContext) void {
    defer ctx.allocator.destroy(ctx);
    defer ctx.conn.close();

    const stream = std.net.Stream{ .handle = ctx.conn.getSocket() };
    const unix_addr = std.net.Address.initUnix(ctx.conn.getPath()) catch |err| {
        logging.logError(err, "creating Unix address");
        return;
    };

    handleUnixSocketClient(ctx.allocator, stream, unix_addr, ctx.cfg, ctx.connection_id) catch |err| {
        logging.logError(err, "Unix socket client handler");
    };
}

fn acceptUnixSocketWithTimeout(unix_server: *unixsock.UnixSocket, cfg: *const config.Config) !unixsock.UnixSocket {
    const socket = unix_server.getSocket();

    // Use unified timeout for accept (respects accept_timeout, then idle_timeout, then defaults)
    const timeout_ms: i32 = if (cfg.accept_timeout > 0)
        @intCast(cfg.accept_timeout)
    else
        // Use unified timeout for fallback (respects --idle-timeout, then 30s default)
        config.getConnectionTimeout(cfg, .unix_server, null);

    var pollfds = [_]posix.pollfd{
        .{
            .fd = socket,
            .events = posix.POLL.IN,
            .revents = 0,
        },
    };

    const ready = posix.poll(&pollfds, timeout_ms) catch |err| {
        if (cfg.verbose) {
            logging.logVerbose(cfg, "Poll error during Unix socket accept: {}\n", .{err});
        }
        return err;
    };

    if (ready == 0) {
        return error.AcceptTimeout;
    }

    if (pollfds[0].revents & (posix.POLL.ERR | posix.POLL.HUP | posix.POLL.NVAL) != 0) {
        if (cfg.verbose) {
            logging.logVerbose(cfg, "Socket error during Unix socket accept\n", .{});
        }
        return error.SocketError;
    }

    return unix_server.accept();
}

fn handleUnixSocketClient(
    allocator: std.mem.Allocator,
    stream: std.net.Stream,
    client_address: std.net.Address,
    cfg: *const config.Config,
    connection_id: u32,
) !void {
    if (cfg.verbose) {
        logging.logVerbose(cfg, "Unix socket client #{} connected\n", .{connection_id});
    }

    if (cfg.exec_command != null or cfg.shell_command != null) {
        const exec_config = if (cfg.exec_command) |prog| blk: {
            break :blk exec.ExecConfig{
                .mode = .direct,
                .program = prog,
                .args = cfg.exec_args.items,
                .require_allow = false,
                .session_config = config.buildExecSessionConfig(cfg),
            };
        } else blk: {
            const shell_cmd = try exec.buildShellCommand(allocator, cfg.shell_command.?);
            defer allocator.free(shell_cmd.args);

            break :blk exec.ExecConfig{
                .mode = .shell,
                .program = shell_cmd.program,
                .args = shell_cmd.args,
                .require_allow = false,
                .session_config = config.buildExecSessionConfig(cfg),
            };
        };

        try exec.executeWithConnection(allocator, stream, exec_config, client_address, cfg);

        if (cfg.verbose) {
            logging.logVerbose(cfg, "Unix socket client #{}: Exec mode completed\n", .{connection_id});
        }
        return;
    }

    var output_logger = output.OutputLogger.init(allocator, cfg.output_file, cfg.append_output) catch |err| {
        common.handleIOInitError(cfg, err, "output logger");
        return err;
    };
    defer output_logger.deinit();

    var hex_dumper = hexdump.HexDumper.init(allocator, cfg.hex_dump_file) catch |err| {
        common.handleIOInitError(cfg, err, "hex dumper");
        return err;
    };
    defer hex_dumper.deinit();

    if (cfg.telnet) {
        const connection = Connection.fromSocket(stream.handle);
        var telnet_conn = try TelnetConnection.init(connection, allocator, null, null, null);
        defer telnet_conn.deinit();

        try telnet_conn.performServerNegotiation();
        try client.telnetBidirectionalTransfer(allocator, .{ .telnet_conn = &telnet_conn }, cfg, &output_logger, &hex_dumper);
    } else {
        try transfer.bidirectionalTransfer(allocator, stream, cfg, &output_logger, &hex_dumper);
    }
}
</file>

<file path="main/app.zig">
//! Application bootstrap for zigcat.

const std = @import("std");

const cli = @import("../cli.zig");
const config = @import("../config.zig");
const client = @import("../client.zig");
const net = @import("../net/socket.zig");
const logging = @import("../util/logging.zig");

const common = @import("common.zig");
const server_mode = @import("modes/server.zig");

pub fn run() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    try net.initPlatform();
    defer net.deinitPlatform();

    const args = try std.process.argsAlloc(allocator);
    defer std.process.argsFree(allocator, args);

    var cfg = cli.parseArgs(allocator, args) catch |err| {
        switch (err) {
            cli.CliError.ShowHelp => {
                cli.printHelp();
                std.process.exit(0);
            },
            cli.CliError.ShowVersion => {
                cli.printVersion();
                std.process.exit(0);
            },
            else => return err,
        }
    };
    defer cfg.deinit(allocator);

    config.validate(&cfg) catch |err| {
        switch (err) {
            config.IOControlError.ConflictingIOModes,
            config.IOControlError.InvalidOutputPath,
            config.IOControlError.PathTraversalDetected,
            config.IOControlError.OutputFileCreateFailed,
            config.IOControlError.HexDumpFileCreateFailed,
            config.IOControlError.OutputFileWriteFailed,
            config.IOControlError.HexDumpFileWriteFailed,
            => common.handleIOInitError(&cfg, err, "configuration"),

            else => logging.logError(err, "configuration validation"),
        }
        std.process.exit(1);
    };

    logging.setVerbosity(cfg.verbose_level);

    if (cfg.listen_mode) {
        common.registerSignalHandlers(&cfg);
        try server_mode.runServer(allocator, &cfg);
    } else {
        try client.runClient(allocator, &cfg);
    }
}
</file>

<file path="main/common.zig">
//! Shared runtime utilities for `main`.

const std = @import("std");
const posix = std.posix;

const config = @import("../config.zig");
const logging = @import("../util/logging.zig");

/// Global shutdown flag (atomic for thread safety).
pub var shutdown_requested = std.atomic.Value(bool).init(false);

/// Signal handler for graceful shutdown (SIGINT, SIGTERM).
pub fn handleShutdownSignal(sig: c_int) callconv(.c) void {
    _ = sig;
    shutdown_requested.store(true, .seq_cst);
}

/// Register signal handlers when running in listen/server mode.
pub fn registerSignalHandlers(cfg: *const config.Config) void {
    // Initialize empty mask (Zig 0.15.x returns by value).
    const empty_mask = posix.sigemptyset();

    const sigaction = posix.Sigaction{
        .handler = .{ .handler = handleShutdownSignal },
        .mask = empty_mask,
        .flags = 0,
    };

    _ = posix.sigaction(posix.SIG.INT, &sigaction, null);
    _ = posix.sigaction(posix.SIG.TERM, &sigaction, null);

    logging.logVerbose(cfg, "Signal handlers registered (SIGINT, SIGTERM)\n", .{});
}

/// Display user-friendly error messages for I/O control initialization failures.
pub fn handleIOInitError(cfg: *const config.Config, err: anyerror, component: []const u8) void {
    _ = cfg;
    switch (err) {
        config.IOControlError.ConflictingIOModes => {
            logging.logError(err, "Cannot use both --send-only and --recv-only flags simultaneously");
            logging.logWarning("  Choose either --send-only OR --recv-only, not both\n", .{});
        },
        config.IOControlError.InvalidOutputPath => {
            logging.logError(err, "Invalid file path specified");
            logging.logWarning("  Component: {s}\n", .{component});
            logging.logWarning("  Path cannot be empty or contain invalid characters\n", .{});
        },
        config.IOControlError.InvalidPathCharacters => {
            logging.logError(err, "file path contains invalid characters");
            logging.logWarning("  Component: {s}\n", .{component});
            logging.logWarning("  Avoid control characters, null bytes, and platform-specific reserved names\n", .{});
        },
        config.IOControlError.PathTraversalDetected => {
            logging.logError(err, "file path contains forbidden directory traversal sequences");
            logging.logWarning("  Component: {s}\n", .{component});
            logging.logWarning("  Remove any '../' or '..\\' segments and target a safe directory\n", .{});
        },
        config.IOControlError.PathTooLong => {
            logging.logError(err, "file path is too long");
            logging.logWarning("  Component: {s}\n", .{component});
            logging.logWarning("  Try using a shorter path or relative path\n", .{});
        },
        config.IOControlError.DirectoryNotFound => {
            logging.logError(err, "Parent directory does not exist");
            logging.logWarning("  Component: {s}\n", .{component});
            logging.logWarning("  Create the directory first or choose an existing location\n", .{});
        },
        config.IOControlError.InsufficientPermissions => {
            logging.logError(err, "Insufficient permissions for file operations");
            logging.logWarning("  Component: {s}\n", .{component});
            logging.logWarning("  Check file/directory permissions or run with appropriate privileges\n", .{});
        },
        config.IOControlError.DiskFull => {
            logging.logError(err, "No space left on device");
            logging.logWarning("  Component: {s}\n", .{component});
            logging.logWarning("  Free up disk space or choose a different location\n", .{});
        },
        config.IOControlError.FileLocked => {
            logging.logError(err, "file is locked by another process");
            logging.logWarning("  Component: {s}\n", .{component});
            logging.logWarning("  Close other applications using this file\n", .{});
        },
        config.IOControlError.IsDirectory => {
            logging.logError(err, "path points to a directory, not a file");
            logging.logWarning("  Component: {s}\n", .{component});
            logging.logWarning("  Specify a file path, not a directory\n", .{});
        },
        config.IOControlError.FileSystemError => {
            logging.logError(err, "File system error during initialization");
            logging.logWarning("  Component: {s}\n", .{component});
            logging.logWarning("  Check system resources and try again\n", .{});
        },
        config.IOControlError.OutputFileCreateFailed => {
            logging.logError(err, "Failed to create or open file");
            logging.logWarning("  Component: {s}\n", .{component});
            logging.logWarning("  Check path, permissions, and available disk space\n", .{});
        },
        config.IOControlError.HexDumpFileCreateFailed => {
            logging.logError(err, "Failed to create file");
            logging.logWarning("  Component: {s}\n", .{component});
            logging.logWarning("  Check path, permissions, and available disk space\n", .{});
        },
        config.IOControlError.OutputFileWriteFailed => {
            logging.logError(err, "Failed to write to file");
            logging.logWarning("  Component: {s}\n", .{component});
            logging.logWarning("  Check disk space, permissions, and file system health\n", .{});
        },
        config.IOControlError.HexDumpFileWriteFailed => {
            logging.logError(err, "Failed to write to file");
            logging.logWarning("  Component: {s}\n", .{component});
            logging.logWarning("  Check disk space, permissions, and file system health\n", .{});
        },
        else => {
            logging.logError(err, "Failed to initialize component");
            logging.logWarning("  Component: {s}\n", .{component});
            logging.logWarning("  This may be a system-specific issue - check logs for details\n", .{});
        },
    }
}
</file>

<file path="net/allowlist/dns_cache.zig">
//! DNS Cache Module
//!
//! Provides DNS resolution caching with TTL-based expiration to reduce
//! latency and DNS load for hostname-based access control rules.
//!
//! ## Features
//! - TTL-based caching (default 5 minutes)
//! - Automatic expiry and cleanup
//! - Failure caching (empty results cached to prevent repeated lookups)
//! - Forward DNS lookup (A and AAAA records)
//!
//! ## Performance Characteristics
//! - Cache hit: O(1) hash map lookup
//! - Cache miss: O(n) DNS lookup where n = network latency (10-100ms)
//! - Memory: O(n) where n = number of cached hostnames
//!
//! ## Security Considerations
//! - DNS results can be manipulated (cache poisoning, rebinding attacks)
//! - Short TTL reduces attack window but increases DNS load
//! - Consider using IP-based rules for security-critical access control
//!
//! ## Usage Example
//! ```zig
//! var cache = DnsCache.init(allocator, 300); // 5 minute TTL
//! defer cache.deinit();
//!
//! const addresses = try cache.resolve("example.com");
//! // Subsequent calls within TTL use cached result
//! ```

const std = @import("std");
const time = std.time;

/// DNS cache entry with expiry timestamp
const DnsCacheEntry = struct {
    addresses: []const std.net.Address,
    expiry: i64, // Unix timestamp in seconds
};

/// DNS cache with TTL-based expiration
pub const DnsCache = struct {
    allocator: std.mem.Allocator,
    cache: std.StringHashMap(DnsCacheEntry),
    ttl_seconds: i64,

    /// Initialize DNS cache with TTL
    ///
    /// ## Parameters
    /// - `allocator`: Memory allocator for cache storage
    /// - `ttl_seconds`: Time-to-live for cached entries (e.g., 300 = 5 minutes)
    ///
    /// ## Returns
    /// Empty DNS cache ready for use
    pub fn init(allocator: std.mem.Allocator, ttl_seconds: u64) DnsCache {
        return .{
            .allocator = allocator,
            .cache = std.StringHashMap(DnsCacheEntry).init(allocator),
            .ttl_seconds = @intCast(ttl_seconds),
        };
    }

    /// Free all cache resources
    ///
    /// ## Safety
    /// - Must call before discarding DnsCache
    /// - Frees all cached address lists
    /// - Deallocates hash map storage
    pub fn deinit(self: *DnsCache) void {
        var it = self.cache.iterator();
        while (it.next()) |entry| {
            self.allocator.free(entry.value_ptr.addresses);
        }
        self.cache.deinit();
    }

    /// Resolve hostname to IP addresses with caching
    ///
    /// Performs DNS lookup (A and AAAA records) with automatic caching.
    /// Checks cache first, returns cached result if not expired.
    /// On cache miss or expiry, performs fresh DNS lookup.
    ///
    /// ## Parameters
    /// - `self`: DnsCache instance
    /// - `hostname`: Hostname to resolve (e.g., "google.com")
    ///
    /// ## Returns
    /// - Array of resolved addresses (both IPv4 and IPv6)
    /// - Result is owned by cache (DO NOT free)
    ///
    /// ## Errors
    /// - `error.OutOfMemory`: Cache allocation failed
    /// - `error.UnknownHostName`: DNS lookup failed
    /// - `error.TemporaryNameServerFailure`: DNS server unreachable
    ///
    /// ## Caching Behavior
    /// - Cache hit (not expired): O(1) hash map lookup
    /// - Cache miss: O(n) DNS lookup + cache store
    /// - Failed lookups: Cached as empty list to prevent repeated failures
    /// - Expiry: Automatic removal on access after TTL
    ///
    /// ## Performance
    /// - DNS lookup latency: 10-100ms typical
    /// - Can block for seconds on timeout
    /// - Cache reduces load and latency for repeated lookups
    ///
    /// ## Example
    /// ```zig
    /// const addresses = try cache.resolve("google.com");
    /// // addresses valid until next cache expiry/cleanup
    /// ```
    pub fn resolve(self: *DnsCache, hostname: []const u8) ![]const std.net.Address {
        const now = time.timestamp();

        if (self.cache.getEntry(hostname)) |entry| {
            if (entry.value_ptr.expiry > now) {
                return entry.value_ptr.addresses;
            } else {
                // Entry expired, remove it
                self.allocator.free(entry.value_ptr.addresses);
                _ = self.cache.remove(hostname);
            }
        }

        const address_list = std.net.getAddressList(self.allocator, hostname, 0) catch |err| {
            // Also cache failures to prevent repeated lookups for bad hostnames
            const expiry = now + self.ttl_seconds;
            const empty_slice = try self.allocator.alloc(std.net.Address, 0);
            const hostname_copy = try self.allocator.dupe(u8, hostname);
            errdefer self.allocator.free(hostname_copy);

            try self.cache.put(hostname_copy, .{
                .addresses = empty_slice,
                .expiry = expiry,
            });
            return err;
        };
        defer address_list.deinit();

        const addresses = try self.allocator.alloc(std.net.Address, address_list.addrs.len);
        errdefer self.allocator.free(addresses);
        @memcpy(addresses, address_list.addrs);

        const expiry = now + self.ttl_seconds;
        const hostname_copy = try self.allocator.dupe(u8, hostname);
        errdefer {
            self.allocator.free(hostname_copy);
            self.allocator.free(addresses);
        }

        try self.cache.put(hostname_copy, .{
            .addresses = addresses,
            .expiry = expiry,
        });

        return addresses;
    }
};
</file>

<file path="net/allowlist/ip_filter.zig">
//! IP Filtering and Matching Module
//!
//! Provides IP address matching logic for access control rules including:
//! - Single IPv4/IPv6 address matching (exact comparison)
//! - CIDR range matching for both IPv4 and IPv6
//! - Hostname matching via DNS resolution with caching
//! - Address comparison utilities
//!
//! ## Matching Algorithm
//! - Single IP: Byte-by-byte comparison (O(1) for IPv4, O(1) for IPv6)
//! - CIDR IPv4: Subnet mask bitwise comparison (O(1))
//! - CIDR IPv6: Byte-by-byte prefix comparison (O(n) where n  16)
//! - Hostname: DNS lookup + comparison against all resolved IPs
//!
//! ## Performance Characteristics
//! - Single IP match: O(1) - Constant time byte comparison
//! - CIDR IPv4 match: O(1) - Bitwise operations
//! - CIDR IPv6 match: O(n) - n = prefix_len / 8 (max 16 bytes)
//! - Hostname match: O(m) - m = number of resolved addresses + DNS latency
//!
//! ## Usage Example
//! ```zig
//! const addr = std.net.Address.initIp4([_]u8{192, 168, 1, 100}, 0);
//! const cidr = try std.net.Ip4Address.parse("192.168.1.0", 0);
//!
//! if (matchesCidrV4(addr.in, cidr, 24)) {
//!     // Address is in 192.168.1.0/24 range
//! }
//! ```

const std = @import("std");
const rule_parser = @import("rule_parser.zig");
const dns_cache = @import("dns_cache.zig");

const IpRule = rule_parser.IpRule;
const DnsCache = dns_cache.DnsCache;

/// Check if an address matches an IP rule
///
/// Dispatches to appropriate matching function based on rule type:
/// - single_ipv4/single_ipv6: Exact address comparison
/// - cidr_v4/cidr_v6: CIDR range matching
/// - hostname: DNS resolution + comparison
///
/// ## Parameters
/// - `dns_cache_ptr`: DNS cache for hostname resolution
/// - `addr`: Address to test
/// - `rule`: Rule to match against
///
/// ## Returns
/// - `true`: Address matches the rule
/// - `false`: Address does not match
///
/// ## Performance
/// - Single IP: O(1) byte comparison
/// - CIDR: O(1) for IPv4, O(n) for IPv6 where n  16
/// - Hostname: O(m) + DNS latency where m = resolved addresses
///
/// ## Security Note
/// Hostname matching uses DNS which can be manipulated.
/// DNS resolution failures result in false (deny access).
pub fn matchesRule(dns_cache_ptr: *DnsCache, addr: std.net.Address, rule: IpRule) bool {
    switch (rule) {
        .single_ipv4 => |rule_addr| {
            if (addr.any.family == std.posix.AF.INET) {
                const addr_v4 = addr.in;
                // Convert u32 to [4]u8 for comparison
                const rule_bytes = std.mem.asBytes(&rule_addr.sa.addr);
                const addr_bytes = std.mem.asBytes(&addr_v4.sa.addr);
                return std.mem.eql(u8, rule_bytes, addr_bytes);
            }
            return false;
        },
        .single_ipv6 => |rule_addr| {
            if (addr.any.family == std.posix.AF.INET6) {
                const addr_v6 = addr.in6;
                return std.mem.eql(u8, &rule_addr.sa.addr, &addr_v6.sa.addr);
            }
            return false;
        },
        .cidr_v4 => |cidr| {
            if (addr.any.family == std.posix.AF.INET) {
                const addr_v4 = addr.in;
                return matchesCidrV4(addr_v4, cidr.addr, cidr.prefix_len);
            }
            return false;
        },
        .cidr_v6 => |cidr| {
            if (addr.any.family == std.posix.AF.INET6) {
                const addr_v6 = addr.in6;
                return matchesCidrV6(addr_v6, cidr.addr, cidr.prefix_len);
            }
            return false;
        },
        .hostname => |hostname| {
            // Resolve hostname to IP addresses via DNS
            const addresses = dns_cache_ptr.resolve(hostname) catch {
                // DNS resolution failed - deny access
                // In production, consider logging this event for security auditing
                return false;
            };

            // Check if client IP matches any resolved address
            // Note: Port is ignored for ACL matching (only IP matters)
            var addr_no_port = addr;
            if (addr.any.family == std.posix.AF.INET) {
                addr_no_port.in.sa.port = 0;
            } else if (addr.any.family == std.posix.AF.INET6) {
                addr_no_port.in6.sa.port = 0;
            }

            for (addresses) |resolved_addr| {
                var resolved_no_port = resolved_addr;
                if (resolved_addr.any.family == std.posix.AF.INET) {
                    resolved_no_port.in.sa.port = 0;
                } else if (resolved_addr.any.family == std.posix.AF.INET6) {
                    resolved_no_port.in6.sa.port = 0;
                }

                if (addressesEqual(addr_no_port, resolved_no_port)) {
                    return true;
                }
            }

            return false;
        },
    }
}

/// Check if an IPv4 address matches a CIDR range
///
/// Uses subnet mask comparison to determine if an address falls within
/// a CIDR network range. Implements RFC 4632 CIDR notation.
///
/// ## Parameters
/// - `addr`: IPv4 address to test
/// - `cidr_addr`: Base address of the CIDR range
/// - `prefix_len`: Prefix length (0-32 bits)
///
/// ## Returns
/// - `true`: Address is within the CIDR range
/// - `false`: Address is outside the CIDR range
///
/// ## Algorithm
/// 1. Special case: prefix_len = 0 matches everything (0.0.0.0/0)
/// 2. Create subnet mask from prefix length
/// 3. Convert addresses to 32-bit big-endian integers
/// 4. Apply mask to both addresses
/// 5. Compare masked network portions
///
/// ## Subnet Mask Calculation
/// ```
/// mask = 0xFFFFFFFF << (32 - prefix_len)
///
/// Examples:
/// /24: 0xFFFFFF00 (255.255.255.0)
/// /16: 0xFFFF0000 (255.255.0.0)
/// /8:  0xFF000000 (255.0.0.0)
/// ```
///
/// ## CIDR Range Examples
/// - 192.168.1.0/24: 192.168.1.0 - 192.168.1.255 (254 hosts)
/// - 10.0.0.0/8: 10.0.0.0 - 10.255.255.255 (16.7M hosts)
/// - 172.16.0.0/12: 172.16.0.0 - 172.31.255.255 (1M hosts)
///
/// ## Edge Cases
/// - /0: Matches all IPv4 addresses (0.0.0.0/0)
/// - /32: Matches single host (equivalent to exact match)
/// - Base address host bits set: Mask clears them (192.168.1.5/24 = 192.168.1.0/24)
///
/// ## Performance
/// - Time complexity: O(1) (constant bitwise operations)
/// - No allocations (stack-only computation)
///
/// ## Example
/// ```zig
/// const addr = try std.net.Ip4Address.parse("192.168.1.100", 0);
/// const cidr = try std.net.Ip4Address.parse("192.168.1.0", 0);
///
/// matchesCidrV4(addr, cidr, 24);  // true (192.168.1.100 in 192.168.1.0/24)
/// matchesCidrV4(addr, cidr, 25);  // true (192.168.1.100 in 192.168.1.0/25)
/// matchesCidrV4(addr, cidr, 26);  // false (192.168.1.100 not in 192.168.1.0/26)
/// ```
pub fn matchesCidrV4(addr: std.net.Ip4Address, cidr_addr: std.net.Ip4Address, prefix_len: u8) bool {
    if (prefix_len == 0) {
        // 0.0.0.0/0 matches everything
        return true;
    }

    // Create network mask
    const mask: u32 = if (prefix_len >= 32)
        0xFFFFFFFF
    else
        @as(u32, 0xFFFFFFFF) << @intCast(32 - prefix_len);

    // Convert u32 addresses to [4]u8 arrays for readInt
    const addr_bytes = std.mem.asBytes(&addr.sa.addr);
    const cidr_bytes = std.mem.asBytes(&cidr_addr.sa.addr);

    // Extract IP addresses as u32 (big-endian)
    const addr_bits = std.mem.readInt(u32, addr_bytes[0..4], .big);
    const cidr_bits = std.mem.readInt(u32, cidr_bytes[0..4], .big);

    // Compare network portions
    return (addr_bits & mask) == (cidr_bits & mask);
}

/// Check if an IPv6 address matches a CIDR range
///
/// Uses byte-by-byte prefix comparison to determine if an IPv6 address
/// falls within a CIDR network range. Implements RFC 4291 IPv6 addressing.
///
/// ## Parameters
/// - `addr`: IPv6 address to test
/// - `cidr_addr`: Base address of the CIDR range
/// - `prefix_len`: Prefix length (0-128 bits)
///
/// ## Returns
/// - `true`: Address is within the CIDR range
/// - `false`: Address is outside the CIDR range
///
/// ## Algorithm
/// 1. Special case: prefix_len = 0 matches everything (::/0)
/// 2. Calculate full bytes and remainder bits from prefix length
/// 3. Compare full bytes (8-bit chunks) for equality
/// 4. If remainder bits exist, compare partial byte with mask
/// 5. Return true if all comparisons match
///
/// ## Byte-wise Comparison Strategy
/// IPv6 addresses are 128 bits (16 bytes). Instead of bitwise operations
/// on 128-bit integers (not supported), we compare bytes individually:
///
/// ```
/// prefix_len = 40 bits
/// full_bytes = 40 / 8 = 5 bytes
/// remainder_bits = 40 % 8 = 0 bits
///
/// Compare bytes 0-4 for exact equality
/// ```
///
/// ## Partial Byte Masking
/// For prefix lengths not aligned to byte boundaries:
/// ```
/// prefix_len = 42 bits
/// full_bytes = 5, remainder_bits = 2
///
/// Compare bytes 0-4 exactly
/// Compare byte 5 with mask: 0xFF << (8 - 2) = 0xC0
///
/// Example:
/// addr[5]     = 0b10110101 (0xB5)
/// cidr_addr[5] = 0b10100000 (0xA0)
/// mask        = 0b11000000 (0xC0)
///
/// addr[5] & mask     = 0b10000000
/// cidr_addr[5] & mask = 0b10000000
/// Match!
/// ```
///
/// ## Common IPv6 Prefix Lengths
/// - /0: Entire IPv6 space (::/0)
/// - /32: ISP allocation (65K /48 sites)
/// - /48: Site allocation (65K /64 subnets)
/// - /64: Single subnet (standard for LANs)
/// - /128: Single host (exact match)
///
/// ## CIDR Range Examples
/// - 2001:db8::/32: 2001:db8:: - 2001:db8:ffff:ffff:ffff:ffff:ffff:ffff
/// - fe80::/10: Link-local addresses
/// - fc00::/7: Unique local addresses (ULA)
///
/// ## Performance
/// - Time complexity: O(n) where n = prefix_len / 8 (max 16 bytes)
/// - Best case: O(1) for prefix_len = 0
/// - Worst case: O(16) for prefix_len = 128
/// - No allocations (stack-only computation)
///
/// ## Edge Cases
/// - /0: Matches all IPv6 addresses (::/0)
/// - /128: Matches single host (equivalent to exact match)
/// - Host bits set in base address: Ignored by prefix comparison
///
/// ## Example
/// ```zig
/// const addr = try std.net.Ip6Address.parse("2001:db8::100", 0);
/// const cidr = try std.net.Ip6Address.parse("2001:db8::", 0);
///
/// matchesCidrV6(addr, cidr, 32);   // true (in 2001:db8::/32)
/// matchesCidrV6(addr, cidr, 64);   // true (in 2001:db8::/64)
/// matchesCidrV6(addr, cidr, 120);  // false (different /120 subnet)
/// ```
pub fn matchesCidrV6(addr: std.net.Ip6Address, cidr_addr: std.net.Ip6Address, prefix_len: u8) bool {
    if (prefix_len == 0) {
        // ::/0 matches everything
        return true;
    }

    // IPv6 addresses are 128 bits (16 bytes)
    // We'll compare byte by byte
    const full_bytes = prefix_len / 8;
    const remainder_bits = prefix_len % 8;

    // Compare full bytes
    var i: usize = 0;
    while (i < full_bytes) : (i += 1) {
        if (addr.sa.addr[i] != cidr_addr.sa.addr[i]) {
            return false;
        }
    }

    // Compare remaining bits if any
    if (remainder_bits > 0 and full_bytes < 16) {
        const mask: u8 = @as(u8, 0xFF) << @intCast(8 - remainder_bits);
        const addr_byte = addr.sa.addr[full_bytes];
        const cidr_byte = cidr_addr.sa.addr[full_bytes];
        if ((addr_byte & mask) != (cidr_byte & mask)) {
            return false;
        }
    }

    return true;
}

/// Compare two addresses for equality (both IP and port)
///
/// ## Parameters
/// - `addr1`: First address to compare
/// - `addr2`: Second address to compare
///
/// ## Returns
/// - `true`: Both IP and port are equal
/// - `false`: Different IP family, IP address, or port
///
/// ## Performance
/// - IPv4: O(1) - 4 byte comparison + port
/// - IPv6: O(1) - 16 byte comparison + port
///
/// ## Usage
/// Primarily used for hostname matching where resolved addresses
/// need to be compared against client addresses (with ports normalized).
pub fn addressesEqual(addr1: std.net.Address, addr2: std.net.Address) bool {
    // Different address families can't be equal
    if (addr1.any.family != addr2.any.family) {
        return false;
    }

    if (addr1.any.family == std.posix.AF.INET) {
        // IPv4 comparison
        const a1 = addr1.in;
        const a2 = addr2.in;

        // Compare port
        if (a1.sa.port != a2.sa.port) {
            return false;
        }

        // Compare IP address (4 bytes)
        const bytes1 = std.mem.asBytes(&a1.sa.addr);
        const bytes2 = std.mem.asBytes(&a2.sa.addr);
        return std.mem.eql(u8, bytes1, bytes2);
    } else if (addr1.any.family == std.posix.AF.INET6) {
        // IPv6 comparison
        const a1 = addr1.in6;
        const a2 = addr2.in6;

        // Compare port
        if (a1.sa.port != a2.sa.port) {
            return false;
        }

        // Compare IP address (16 bytes)
        return std.mem.eql(u8, &a1.sa.addr, &a2.sa.addr);
    }

    // Unknown family
    return false;
}
</file>

<file path="net/allowlist/rule_parser.zig">
//! IP Rule Parser Module
//!
//! Provides rule type definitions and parsing logic for IP access control.
//! Supports single IPs, CIDR ranges, and hostnames for both IPv4 and IPv6.
//!
//! ## Supported Rule Formats
//! - Single IPv4: "192.168.1.1", "10.0.0.1", "127.0.0.1"
//! - Single IPv6: "2001:db8::1", "::1", "fe80::1"
//! - IPv4 CIDR: "192.168.1.0/24", "10.0.0.0/8", "0.0.0.0/0"
//! - IPv6 CIDR: "2001:db8::/32", "::/0", "fe80::/10"
//! - Hostname: "example.com", "localhost", "server.local"
//!
//! ## Parsing Strategy
//! Uses greedy parsing with fallback:
//! 1. Check for "/" character (CIDR notation)
//! 2. Try IPv4 CIDR, then IPv6 CIDR
//! 3. Try single IPv4, then single IPv6
//! 4. Treat as hostname (any valid string)
//!
//! ## Memory Management
//! - Single IP and CIDR rules: Stack-allocated (no cleanup needed)
//! - Hostname rules: Heap-allocated string (must call IpRule.deinit())
//!
//! ## Usage Example
//! ```zig
//! const rule1 = try parseRule(allocator, "192.168.1.0/24");
//! // Returns: IpRule{ .cidr_v4 = .{ .addr = ..., .prefix_len = 24 }}
//!
//! const rule2 = try parseRule(allocator, "2001:db8::1");
//! // Returns: IpRule{ .single_ipv6 = ... }
//!
//! var rule3 = try parseRule(allocator, "example.com");
//! defer rule3.deinit(allocator);
//! // Returns: IpRule{ .hostname = "example.com" }
//! ```

const std = @import("std");

/// IP access control rule
///
/// Represents a single access control rule that can match:
/// - Single IPv4/IPv6 addresses (exact match)
/// - CIDR ranges with prefix length (subnet match)
/// - Hostnames (parsed but not matched - requires DNS resolution)
///
/// ## Memory Management
/// - Single IP rules: Stack-allocated (no cleanup needed)
/// - CIDR rules: Stack-allocated (no cleanup needed)
/// - Hostname rules: Heap-allocated string (must call deinit())
///
/// ## Example
/// ```zig
/// // Single IPv4 rule
/// const rule1 = IpRule{ .single_ipv4 = try std.net.Ip4Address.parse("192.168.1.1", 0) };
///
/// // CIDR rule
/// const rule2 = IpRule{ .cidr_v4 = .{
///     .addr = try std.net.Ip4Address.parse("192.168.0.0", 0),
///     .prefix_len = 24,  // 192.168.0.0/24
/// }};
///
/// // Hostname rule (heap-allocated)
/// var rule3 = IpRule{ .hostname = try allocator.dupe(u8, "example.com") };
/// defer rule3.deinit(allocator);
/// ```
pub const IpRule = union(enum) {
    /// Single IPv4 address (exact match)
    single_ipv4: std.net.Ip4Address,

    /// Single IPv6 address (exact match)
    single_ipv6: std.net.Ip6Address,

    /// IPv4 CIDR range with subnet mask
    cidr_v4: struct {
        addr: std.net.Ip4Address,
        prefix_len: u8, // 0-32 (0 = match all, 32 = single host)
    },

    /// IPv6 CIDR range with prefix length
    cidr_v6: struct {
        addr: std.net.Ip6Address,
        prefix_len: u8, // 0-128 (0 = match all, 128 = single host)
    },

    /// Hostname (DNS forward lookup - A/AAAA records)
    /// WARNING: Hostname matching uses DNS which can be manipulated.
    /// Use IP-based rules for production security-critical access control.
    /// DNS lookups add 10-100ms latency per connection.
    hostname: []const u8,

    /// Free heap-allocated memory (hostnames only)
    ///
    /// ## Parameters
    /// - `self`: Rule to clean up (modified in-place)
    /// - `allocator`: Allocator used to create hostname string
    ///
    /// ## Safety
    /// - Safe to call multiple times (idempotent)
    /// - Safe to call on non-hostname rules (no-op)
    /// - Must use same allocator that created the hostname
    pub fn deinit(self: *IpRule, allocator: std.mem.Allocator) void {
        switch (self.*) {
            .hostname => |h| allocator.free(h),
            else => {},
        }
    }
};

/// Parse rule string into structured IpRule
///
/// Attempts to parse the input string as various rule types in order:
/// 1. CIDR notation (IPv4 or IPv6 with "/" prefix length)
/// 2. Single IPv4 address
/// 3. Single IPv6 address
/// 4. Hostname (fallback - any string)
///
/// ## Supported Formats
/// - IPv4 single: "192.168.1.1", "10.0.0.1", "127.0.0.1"
/// - IPv4 CIDR: "192.168.1.0/24", "10.0.0.0/8", "0.0.0.0/0"
/// - IPv6 single: "2001:db8::1", "::1", "fe80::1"
/// - IPv6 CIDR: "2001:db8::/32", "::/0", "fe80::/10"
/// - Hostname: "example.com", "localhost", "server.local"
///
/// ## Parameters
/// - `allocator`: Memory allocator for hostname strings (heap-allocated)
/// - `rule_str`: Input string to parse
///
/// ## Returns
/// - Parsed IpRule (single_ipv4, single_ipv6, cidr_v4, cidr_v6, or hostname)
///
/// ## Errors
/// - `error.InvalidPrefixLength`: CIDR prefix out of valid range
///   - IPv4: Must be 0-32
///   - IPv6: Must be 0-128
/// - `error.InvalidCidrAddress`: CIDR base address parsing failed
/// - `error.OutOfMemory`: Hostname string allocation failed
///
/// ## CIDR Prefix Length Validation
/// - IPv4: 0-32 bits
///   - /0 = 0.0.0.0/0 (entire IPv4 space)
///   - /8 = Class A network (16.7M hosts)
///   - /16 = Class B network (65K hosts)
///   - /24 = Class C network (254 hosts)
///   - /32 = Single host
/// - IPv6: 0-128 bits
///   - /0 = ::/0 (entire IPv6 space)
///   - /32 = Typical ISP allocation
///   - /48 = Typical site allocation
///   - /64 = Single subnet
///   - /128 = Single host
///
/// ## Parsing Strategy
/// Uses greedy parsing with fallback:
/// 1. Check for "/" character (CIDR notation)
/// 2. Try IPv4 CIDR, then IPv6 CIDR
/// 3. Try single IPv4, then single IPv6
/// 4. Treat as hostname (any valid string)
///
/// ## Example
/// ```zig
/// const rule1 = try parseRule(allocator, "192.168.1.0/24");
/// // Returns: IpRule{ .cidr_v4 = .{ .addr = ..., .prefix_len = 24 }}
///
/// const rule2 = try parseRule(allocator, "2001:db8::1");
/// // Returns: IpRule{ .single_ipv6 = ... }
///
/// const rule3 = try parseRule(allocator, "example.com");
/// // Returns: IpRule{ .hostname = "example.com" }
/// ```
pub fn parseRule(allocator: std.mem.Allocator, rule_str: []const u8) !IpRule {
    // Check for CIDR notation
    if (std.mem.indexOf(u8, rule_str, "/")) |slash_pos| {
        const addr_str = rule_str[0..slash_pos];
        const prefix_str = rule_str[slash_pos + 1 ..];
        const prefix_len = try std.fmt.parseInt(u8, prefix_str, 10);

        // Try to parse as IPv4 CIDR
        if (std.net.Ip4Address.parse(addr_str, 0)) |ipv4| {
            if (prefix_len > 32) return error.InvalidPrefixLength;
            return IpRule{ .cidr_v4 = .{
                .addr = ipv4,
                .prefix_len = prefix_len,
            } };
        } else |_| {
            // Try IPv6 CIDR
            if (std.net.Ip6Address.parse(addr_str, 0)) |ipv6| {
                if (prefix_len > 128) return error.InvalidPrefixLength;
                return IpRule{ .cidr_v6 = .{
                    .addr = ipv6,
                    .prefix_len = prefix_len,
                } };
            } else |_| {
                return error.InvalidCidrAddress;
            }
        }
    }

    // Try to parse as single IPv4
    if (std.net.Ip4Address.parse(rule_str, 0)) |ipv4| {
        return IpRule{ .single_ipv4 = ipv4 };
    } else |_| {
        // Try IPv6
        if (std.net.Ip6Address.parse(rule_str, 0)) |ipv6| {
            return IpRule{ .single_ipv6 = ipv6 };
        } else |_| {
            // Treat as hostname
            const hostname = try allocator.dupe(u8, rule_str);
            return IpRule{ .hostname = hostname };
        }
    }
}
</file>

<file path="net/proxy/http_connect.zig">
//! HTTP CONNECT proxy implementation (RFC 7231 Section 4.3.6).
//!
//! Establishes a TCP tunnel through an HTTP proxy server using the
//! CONNECT method. After successful connection, the proxy becomes
//! transparent and forwards all data bidirectionally.
//!
//! **Protocol Flow:**
//! 1. Client connects to proxy server
//! 2. Client sends: `CONNECT target:port HTTP/1.1`
//! 3. Proxy connects to target
//! 4. Proxy responds: `HTTP/1.1 200 Connection Established`
//! 5. Tunnel active - all subsequent data is forwarded
//!
//! **Authentication:**
//! Supports HTTP Basic authentication via `Proxy-Authorization` header.
//! Credentials are base64-encoded (username:password).
//!
//! **Use Cases:**
//! - HTTPS through corporate proxy
//! - SSH tunneling through HTTP proxy
//! - Any TCP protocol through HTTP infrastructure
//!
//! **Security:**
//! - CONNECT method creates end-to-end encrypted tunnel (for TLS)
//! - Basic auth sends credentials in base64 (use HTTPS to proxy if possible)
//! - Proxy can see connection metadata (target host:port)
//!
//! **References:**
//! - RFC 7231 Section 4.3.6: CONNECT method
//! - RFC 7235: HTTP Authentication
//! - RFC 4648: Base64 encoding

const std = @import("std");
const posix = std.posix;
const socket = @import("../socket.zig");
const poll_wrapper = @import("../../util/poll_wrapper.zig");
const logging = @import("../../util/logging.zig");

/// Proxy authentication credentials for HTTP Basic authentication.
///
/// **Format:**
/// Sent as: `Proxy-Authorization: Basic base64(username:password)`
///
/// **Security:**
/// Credentials are base64-encoded (NOT encrypted). Use HTTPS connection
/// to proxy server to protect credentials in transit.
pub const ProxyAuth = struct {
    username: []const u8,
    password: []const u8,
};

/// Connect to target through HTTP CONNECT proxy.
///
/// **Parameters:**
/// - `allocator`: Memory allocator for request/response buffers
/// - `proxy_host`: HTTP proxy hostname or IP
/// - `proxy_port`: HTTP proxy port (typically 8080, 3128, or 8888)
/// - `target_host`: Destination hostname or IP
/// - `target_port`: Destination port
/// - `auth`: Optional Basic authentication credentials
/// - `timeout_ms`: Connection timeout in milliseconds
///
/// **Returns:**
/// Socket connected to target through proxy tunnel.
///
/// **Errors:**
/// - `error.UnknownHost`: Proxy hostname resolution failed
/// - `error.ConnectionTimeout`: Proxy connect timeout
/// - `error.ProxyConnectionFailed`: Proxy returned non-200 status
/// - `error.InvalidProxyResponse`: Malformed HTTP response
/// - `error.ProxyTimeout`: Response read timeout (30s)
///
/// **Example:**
/// ```zig
/// const auth = ProxyAuth{ .username = "user", .password = "pass" };
/// const sock = try connect(
///     allocator,
///     "proxy.example.com",
///     8080,
///     "target.com",
///     443,
///     auth,
///     30000
/// );
/// defer socket.closeSocket(sock);
/// // Now use sock for TLS/SSH/etc to target.com:443
/// ```
pub fn connect(
    allocator: std.mem.Allocator,
    proxy_host: []const u8,
    proxy_port: u16,
    target_host: []const u8,
    target_port: u16,
    auth: ?ProxyAuth,
    timeout_ms: u32,
) !socket.Socket {
    // Step 1: Connect to proxy server
    const proxy_sock = try connectToProxy(proxy_host, proxy_port, timeout_ms);
    errdefer socket.closeSocket(proxy_sock);

    // Step 2: Send CONNECT request
    try sendConnectRequest(
        allocator,
        proxy_sock,
        target_host,
        target_port,
        auth,
    );

    // Step 3: Read and parse response
    try readConnectResponse(allocator, proxy_sock);

    // Step 4: Connection established, return socket
    return proxy_sock;
}

/// Connect to proxy server
fn connectToProxy(host: []const u8, port: u16, timeout_ms: u32) !socket.Socket {
    const family = socket.detectAddressFamily(host);
    const sock = try socket.createTcpSocket(family);
    errdefer socket.closeSocket(sock);

    try socket.setNonBlocking(sock);

    const addr_list = try std.net.getAddressList(
        std.heap.page_allocator,
        host,
        port,
    );
    defer addr_list.deinit();

    if (addr_list.addrs.len == 0) {
        return error.UnknownHost;
    }

    var last_error: ?anyerror = null;
    for (addr_list.addrs) |addr| {
        const result = posix.connect(sock, &addr.any, addr.getOsSockLen());

        if (result) {
            return sock;
        } else |err| {
            if (err == error.WouldBlock or err == error.InProgress) {
                if (try waitForConnect(sock, timeout_ms)) {
                    return sock;
                }
                last_error = error.ConnectionTimeout;
            } else {
                last_error = err;
            }
        }
    }

    return last_error orelse error.ConnectionFailed;
}

/// Wait for socket to become writable
fn waitForConnect(sock: socket.Socket, timeout_ms: u32) !bool {
    var pollfds = [_]poll_wrapper.pollfd{.{
        .fd = sock,
        .events = poll_wrapper.POLL.OUT,
        .revents = 0,
    }};

    const ready = try poll_wrapper.poll(&pollfds, @intCast(timeout_ms));
    if (ready == 0) return false;

    var err: i32 = undefined;
    const len: posix.socklen_t = @sizeOf(i32);
    try posix.getsockopt(sock, posix.SOL.SOCKET, posix.SO.ERROR, std.mem.asBytes(&err)[0..len]);

    return err == 0;
}

/// Send HTTP CONNECT request
fn sendConnectRequest(
    allocator: std.mem.Allocator,
    sock: socket.Socket,
    target_host: []const u8,
    target_port: u16,
    auth: ?ProxyAuth,
) !void {
    var request = std.ArrayList(u8){};
    defer request.deinit(allocator);

    // Build CONNECT request
    try request.writer(allocator).print("CONNECT {s}:{d} HTTP/1.1\r\n", .{ target_host, target_port });
    try request.writer(allocator).print("Host: {s}:{d}\r\n", .{ target_host, target_port });

    // Add authentication if provided
    if (auth) |credentials| {
        const auth_str = try std.fmt.allocPrint(
            allocator,
            "{s}:{s}",
            .{ credentials.username, credentials.password },
        );
        errdefer allocator.free(auth_str);

        const encoder = std.base64.standard.Encoder;
        const encoded_len = encoder.calcSize(auth_str.len);
        const encoded = try allocator.alloc(u8, encoded_len);
        errdefer allocator.free(encoded);

        _ = encoder.encode(encoded, auth_str);

        try request.writer(allocator).print("Proxy-Authorization: Basic {s}\r\n", .{encoded});

        allocator.free(encoded);
        allocator.free(auth_str);
    }

    try request.appendSlice(allocator, "\r\n");

    // Send request
    const bytes_to_send = request.items;
    var sent: usize = 0;
    while (sent < bytes_to_send.len) {
        const n = try posix.send(sock, bytes_to_send[sent..], 0);
        sent += n;
    }
}

/// Read and validate HTTP CONNECT response.
///
/// **TCP Fragmentation Handling:**
/// HTTP responses can be fragmented across multiple TCP packets.
/// This function implements buffered reading, continuously receiving
/// data until the end-of-headers marker (\r\n\r\n) is detected.
///
/// **Timeout Protection:**
/// Uses poll() with 30-second timeout for each recv() attempt.
/// If any individual recv() times out, returns error.ProxyTimeout.
///
/// **Edge Cases:**
/// - Partial response received: Continues reading until complete
/// - Buffer overflow: Returns error if response exceeds 4KB
/// - Connection closed early: Returns error.UnexpectedEof
/// - Malformed response: Returns error.InvalidProxyResponse
fn readConnectResponse(_: std.mem.Allocator, sock: socket.Socket) !void {
    var buffer: [4096]u8 = undefined;
    var received: usize = 0;

    // CRITICAL: Buffered reading loop to handle TCP fragmentation
    // TCP is a stream protocol - response may arrive in multiple packets
    // Continue reading until we find end-of-headers marker (\r\n\r\n)
    while (received < buffer.len) {
        // Poll with timeout before each recv (30s timeout)
        var pollfds = [_]poll_wrapper.pollfd{.{
            .fd = sock,
            .events = poll_wrapper.POLL.IN,
            .revents = 0,
        }};

        const ready = try poll_wrapper.poll(&pollfds, 30000);
        if (ready == 0) return error.ProxyTimeout;

        // Check for error conditions on socket
        if (pollfds[0].revents & (poll_wrapper.POLL.ERR | poll_wrapper.POLL.HUP | poll_wrapper.POLL.NVAL) != 0) {
            return error.ProxyConnectionClosed;
        }

        // Read next chunk of data
        const n = try posix.recv(sock, buffer[received..], 0);
        if (n == 0) return error.UnexpectedEof; // Connection closed before complete headers

        received += n;

        // Check if we have complete headers (end marker: \r\n\r\n)
        if (std.mem.indexOf(u8, buffer[0..received], "\r\n\r\n")) |_| {
            break; // Complete HTTP headers received
        }

        // If we've filled the buffer and still no end-of-headers, response is too large
        if (received == buffer.len) {
            return error.InvalidProxyResponse; // Response exceeds buffer size
        }
    }

    // Parse HTTP status line (now safe - we have complete headers)
    const response = buffer[0..received];
    const status_line_end = std.mem.indexOf(u8, response, "\r\n") orelse return error.InvalidProxyResponse;
    const status_line = response[0..status_line_end];

    // Check for "HTTP/1.x 200"
    if (!std.mem.startsWith(u8, status_line, "HTTP/1.")) {
        return error.InvalidProxyResponse;
    }

    // Find status code
    const space_idx = std.mem.indexOf(u8, status_line, " ") orelse return error.InvalidProxyResponse;
    const status_code_start = space_idx + 1;
    const status_code_end = std.mem.indexOfPos(u8, status_line, status_code_start, " ") orelse status_line.len;

    const status_code_str = status_line[status_code_start..status_code_end];
    const status_code = std.fmt.parseInt(u16, status_code_str, 10) catch return error.InvalidProxyResponse;

    if (status_code != 200) {
        logging.logVerbose(null, "Proxy returned status code: {d}\n", .{status_code});
        return error.ProxyConnectionFailed;
    }
}

/// Parse proxy address from "host:port" format.
///
/// **Parameters:**
/// - `proxy_str`: String in format "hostname:port" or "IP:port"
///
/// **Returns:**
/// Struct with separated host and port fields.
///
/// **Errors:**
/// - `error.InvalidProxyFormat`: Missing colon or malformed
///
/// **Examples:**
/// - "proxy.example.com:8080"  { "proxy.example.com", 8080 }
/// - "192.168.1.1:3128"  { "192.168.1.1", 3128 }
/// - "[::1]:8888"  { "[::1]", 8888 } (IPv6)
pub fn parseProxyAddress(_: std.mem.Allocator, proxy_str: []const u8) !struct { host: []const u8, port: u16 } {
    const colon_idx = std.mem.lastIndexOf(u8, proxy_str, ":") orelse return error.InvalidProxyFormat;

    const host = proxy_str[0..colon_idx];
    const port_str = proxy_str[colon_idx + 1 ..];
    const port = try std.fmt.parseInt(u16, port_str, 10);

    return .{ .host = host, .port = port };
}

/// Parse proxy authentication credentials from "username:password" format.
///
/// **Parameters:**
/// - `auth_str`: Credentials string in format "user:pass"
///
/// **Returns:**
/// `ProxyAuth` struct with separated username and password.
///
/// **Errors:**
/// - `error.InvalidAuthFormat`: Missing colon separator
///
/// **Example:**
/// ```zig
/// const auth = try parseProxyAuth(allocator, "alice:secret123");
/// // auth.username = "alice"
/// // auth.password = "secret123"
/// ```
pub fn parseProxyAuth(_: std.mem.Allocator, auth_str: []const u8) !ProxyAuth {
    const colon_idx = std.mem.indexOf(u8, auth_str, ":") orelse return error.InvalidAuthFormat;

    return ProxyAuth{
        .username = auth_str[0..colon_idx],
        .password = auth_str[colon_idx + 1 ..],
    };
}
</file>

<file path="net/proxy/mod.zig">
//! Proxy support module providing HTTP CONNECT, SOCKS4, and SOCKS5 protocols.
//!
//! This module implements proxy connection establishment for:
//! - **HTTP CONNECT** (RFC 7231 Section 4.3.6): Tunneling via HTTP proxy
//! - **SOCKS4** (Legacy): IPv4-only proxy protocol
//! - **SOCKS5** (RFC 1928): Modern SOCKS with authentication and IPv6
//!
//! **Usage:**
//! ```zig
//! const sock = try proxy.connectThroughProxy(
//!     allocator,
//!     cfg,
//!     "example.com",
//!     443
//! );
//! defer socket.closeSocket(sock);
//! ```
//!
//! **Configuration:**
//! Set these fields in `config.Config`:
//! - `proxy`: Proxy address (format: "host:port")
//! - `proxy_type`: `.http`, `.socks4`, or `.socks5`
//! - `proxy_auth`: Optional "username:password"
//!
//! **Supported Features:**
//! - Authentication (HTTP Basic, SOCKS5 user/pass, SOCKS4 user-id)
//! - IPv4 and IPv6 (SOCKS5 only, SOCKS4 is IPv4-only)
//! - Domain name resolution (SOCKS5 and HTTP CONNECT)
//! - Timeout support for all operations

const std = @import("std");
const socket = @import("../socket.zig");
const config = @import("../../config.zig");

pub const http_connect = @import("http_connect.zig");
pub const socks5 = @import("socks5.zig");
pub const socks4 = @import("socks4.zig");

pub const ProxyAuth = http_connect.ProxyAuth;

/// Connect to target host through configured proxy server.
///
/// **Parameters:**
/// - `allocator`: Memory allocator for transient data
/// - `cfg`: Zigcat configuration (must have proxy settings)
/// - `target_host`: Destination hostname or IP
/// - `target_port`: Destination port
///
/// **Returns:**
/// Connected socket tunneled through proxy to target.
///
/// **Errors:**
/// - `error.NoProxyConfigured`: `cfg.proxy` is null
/// - `error.InvalidProxyFormat`: Proxy address malformed
/// - `error.ConnectionTimeout`: Proxy connect timeout
/// - `error.ProxyConnectionFailed`: Proxy rejected connection
/// - `error.AuthenticationFailed`: Proxy auth failed
///
/// **Protocol Selection:**
/// Based on `cfg.proxy_type`:
/// - `.http`: Uses HTTP CONNECT method
/// - `.socks5`: Uses SOCKS5 protocol (RFC 1928)
/// - `.socks4`: Uses SOCKS4 protocol (IPv4 only)
///
/// **Example:**
/// ```zig
/// var cfg = Config{
///     .proxy = "proxy.example.com:8080",
///     .proxy_type = .http,
///     .proxy_auth = "user:pass",
///     .connect_timeout = 30000,
/// };
/// const sock = try connectThroughProxy(allocator, &cfg, "target.com", 443);
/// ```
pub fn connectThroughProxy(
    allocator: std.mem.Allocator,
    cfg: *const config.Config,
    target_host: []const u8,
    target_port: u16,
) !socket.Socket {
    const proxy_str = cfg.proxy orelse return error.NoProxyConfigured;

    // Parse proxy address
    const proxy_addr = try http_connect.parseProxyAddress(allocator, proxy_str);

    // Parse authentication if provided
    const auth = if (cfg.proxy_auth) |auth_str|
        try http_connect.parseProxyAuth(allocator, auth_str)
    else
        null;

    // Connect based on proxy type
    return switch (cfg.proxy_type) {
        .http => try http_connect.connect(
            allocator,
            proxy_addr.host,
            proxy_addr.port,
            target_host,
            target_port,
            auth,
            cfg.connect_timeout,
        ),
        .socks5 => try socks5.connect(
            allocator,
            proxy_addr.host,
            proxy_addr.port,
            target_host,
            target_port,
            auth,
            cfg.connect_timeout,
        ),
        .socks4 => blk: {
            // SOCKS4 uses user_id instead of username/password
            const user_id = if (auth) |a| a.username else "";
            break :blk try socks4.connect(
                allocator,
                proxy_addr.host,
                proxy_addr.port,
                target_host,
                target_port,
                user_id,
                cfg.connect_timeout,
            );
        },
    };
}
</file>

<file path="net/proxy/socks4.zig">
//! SOCKS4 proxy protocol implementation.
//!
//! ** LEGACY PROTOCOL - IPv4 ONLY **
//!
//! SOCKS4 is an older proxy protocol with significant limitations:
//! - **IPv4 only**: Cannot connect to IPv6 targets
//! - **No authentication**: Only optional user-id field
//! - **No DNS resolution**: Target must be resolved to IPv4 before request
//!
//! **Protocol Format:**
//! ```
//! Request:
//! +-----+-----+----------+----------+----------+-------+
//! | VER | CMD | DST.PORT | DST.ADDR | USER-ID  | NULL  |
//! +-----+-----+----------+----------+----------+-------+
//! |  1  |  1  |    2     |    4     | variable |   1   |
//! +-----+-----+----------+----------+----------+-------+
//!
//! Response:
//! +-----+-----+----------+----------+
//! | VER | REP | BND.PORT | BND.ADDR |
//! +-----+-----+----------+----------+
//! |  1  |  1  |    2     |    4     |
//! +-----+-----+----------+----------+
//! ```
//!
//! **Commands:**
//! - CMD_CONNECT (0x01): Establish TCP connection
//! - CMD_BIND (0x02): Bind port for incoming connection
//!
//! **Reply Codes:**
//! - 90: Request granted
//! - 91: Request rejected or failed
//! - 92: Identd connection failed
//! - 93: Identd user-id mismatch
//!
//! **Use Cases:**
//! - Legacy proxy systems that don't support SOCKS5
//! - Simplified proxy scenarios where IPv4 is sufficient
//!
//! **Recommendation:**
//! Use SOCKS5 for new deployments (supports IPv6, auth, DNS resolution).

const std = @import("std");
const posix = std.posix;
const socket = @import("../socket.zig");
const poll_wrapper = @import("../../util/poll_wrapper.zig");
const logging = @import("../../util/logging.zig");

// SOCKS4 protocol constants
const SOCKS4_VERSION: u8 = 0x04;
const CMD_CONNECT: u8 = 0x01;
const CMD_BIND: u8 = 0x02;

// Reply codes
const REP_GRANTED: u8 = 90;
const REP_REJECTED: u8 = 91;
const REP_IDENT_FAILED: u8 = 92;
const REP_IDENT_MISMATCH: u8 = 93;

/// Connect to target through SOCKS4 proxy.
///
/// ** IPv4 LIMITATION:**
/// SOCKS4 only supports IPv4. Hostnames are resolved to IPv4 before
/// sending request. If target has only IPv6 address, connection fails.
///
/// **Parameters:**
/// - `allocator`: Memory allocator for hostname resolution
/// - `proxy_host`: SOCKS4 proxy hostname or IP
/// - `proxy_port`: SOCKS4 proxy port (typically 1080)
/// - `target_host`: Destination hostname or IPv4 address
/// - `target_port`: Destination port
/// - `user_id`: Optional user identifier (empty string if none)
/// - `timeout_ms`: Connection timeout in milliseconds
///
/// **Returns:**
/// Socket connected to target through SOCKS4 proxy.
///
/// **Errors:**
/// - `error.NoIpv4Address`: Target has no IPv4 address
/// - `error.Socks4ConnectionFailed`: Proxy rejected request
/// - `error.ConnectionTimeout`: Proxy connect timeout
/// - `error.InvalidProxyResponse`: Malformed response
///
/// **Protocol Flow:**
/// 1. Resolve target to IPv4 address
/// 2. Connect to SOCKS4 proxy
/// 3. Send CONNECT request (version, cmd, port, IP, user-id)
/// 4. Receive response (8 bytes: null, reply, port, IP)
/// 5. Check reply code (90 = success)
///
/// **Example:**
/// ```zig
/// const sock = try connect(
///     allocator,
///     "socks4.example.com",
///     1080,
///     "target.com",  // Will be resolved to IPv4
///     80,
///     "",  // No user-id
///     30000
/// );
/// ```
pub fn connect(
    allocator: std.mem.Allocator,
    proxy_host: []const u8,
    proxy_port: u16,
    target_host: []const u8,
    target_port: u16,
    user_id: []const u8,
    timeout_ms: u32,
) !socket.Socket {
    // Step 1: Connect to SOCKS4 proxy
    const sock = try connectToProxy(proxy_host, proxy_port, timeout_ms);
    errdefer socket.closeSocket(sock);

    // Step 2: Resolve target to IPv4 (SOCKS4 requires IPv4)
    const target_addr = try resolveToIpv4(allocator, target_host);

    // Step 3: Send CONNECT request
    try sendConnectRequest(sock, target_addr, target_port, user_id);

    // Step 4: Read response
    try readConnectResponse(sock);

    // Step 5: Connection established
    return sock;
}

fn connectToProxy(host: []const u8, port: u16, timeout_ms: u32) !socket.Socket {
    const family = socket.detectAddressFamily(host);
    const sock = try socket.createTcpSocket(family);
    errdefer socket.closeSocket(sock);

    try socket.setNonBlocking(sock);

    const addr_list = try std.net.getAddressList(
        std.heap.page_allocator,
        host,
        port,
    );
    defer addr_list.deinit();

    if (addr_list.addrs.len == 0) {
        return error.UnknownHost;
    }

    var last_error: ?anyerror = null;
    for (addr_list.addrs) |addr| {
        const result = posix.connect(sock, &addr.any, addr.getOsSockLen());

        if (result) {
            return sock;
        } else |err| {
            if (err == error.WouldBlock or err == error.InProgress) {
                if (try waitForConnect(sock, timeout_ms)) {
                    return sock;
                }
                last_error = error.ConnectionTimeout;
            } else {
                last_error = err;
            }
        }
    }

    return last_error orelse error.ConnectionFailed;
}

fn waitForConnect(sock: socket.Socket, timeout_ms: u32) !bool {
    var pollfds = [_]poll_wrapper.pollfd{.{
        .fd = sock,
        .events = poll_wrapper.POLL.OUT,
        .revents = 0,
    }};

    const ready = try poll_wrapper.poll(&pollfds, @intCast(timeout_ms));
    if (ready == 0) return false;

    var err: i32 = undefined;
    const len: posix.socklen_t = @sizeOf(i32);
    try posix.getsockopt(sock, posix.SOL.SOCKET, posix.SO.ERROR, std.mem.asBytes(&err)[0..len]);

    return err == 0;
}

/// Resolve hostname to IPv4 address
fn resolveToIpv4(allocator: std.mem.Allocator, host: []const u8) ![4]u8 {
    // Try parsing as IPv4 first
    if (std.net.Address.parseIp4(host, 0)) |addr| {
        return @as(*const [4]u8, @ptrCast(&addr.in.sa.addr)).*;
    } else |_| {
        // Not a direct IPv4, need to resolve
        const addr_list = try std.net.getAddressList(allocator, host, 0);
        defer addr_list.deinit();

        // Find first IPv4 address
        for (addr_list.addrs) |addr| {
            if (addr.any.family == posix.AF.INET) {
                return @as(*const [4]u8, @ptrCast(&addr.in.sa.addr)).*;
            }
        }

        return error.NoIpv4Address;
    }
}

/// Send SOCKS4 CONNECT request
fn sendConnectRequest(
    sock: socket.Socket,
    target_addr: [4]u8,
    target_port: u16,
    user_id: []const u8,
) !void {
    var request: [512]u8 = undefined;
    var idx: usize = 0;

    // Version
    request[idx] = SOCKS4_VERSION;
    idx += 1;

    // Command (CONNECT)
    request[idx] = CMD_CONNECT;
    idx += 1;

    // Port (big-endian)
    request[idx] = @intCast((target_port >> 8) & 0xFF);
    idx += 1;
    request[idx] = @intCast(target_port & 0xFF);
    idx += 1;

    // IPv4 address
    @memcpy(request[idx..][0..4], &target_addr);
    idx += 4;

    // User ID (null-terminated)
    if (user_id.len > 0) {
        @memcpy(request[idx..][0..user_id.len], user_id);
        idx += user_id.len;
    }
    request[idx] = 0;
    idx += 1;

    // Send request
    _ = try posix.send(sock, request[0..idx], 0);
}

/// Read SOCKS4 response
fn readConnectResponse(sock: socket.Socket) !void {
    var response: [8]u8 = undefined;

    var pollfds = [_]poll_wrapper.pollfd{.{
        .fd = sock,
        .events = poll_wrapper.POLL.IN,
        .revents = 0,
    }};

    const ready = try poll_wrapper.poll(&pollfds, 30000);
    if (ready == 0) return error.ProxyTimeout;

    const n = try posix.recv(sock, &response, 0);
    if (n != 8) return error.InvalidProxyResponse;

    // Response format:
    // Byte 0: null byte (should be 0)
    // Byte 1: reply code
    // Bytes 2-3: destination port (ignored)
    // Bytes 4-7: destination IP (ignored)

    const reply = response[1];

    if (reply != REP_GRANTED) {
        const err_msg = switch (reply) {
            REP_REJECTED => "Request rejected or failed",
            REP_IDENT_FAILED => "Request rejected because SOCKS server cannot connect to identd",
            REP_IDENT_MISMATCH => "Request rejected because identd reported different user-id",
            else => "Unknown error",
        };
        logging.logVerbose(null, "SOCKS4 error: {s}\n", .{err_msg});
        return error.Socks4ConnectionFailed;
    }
}
</file>

<file path="net/proxy/socks5.zig">
//! SOCKS5 proxy protocol implementation (RFC 1928).
//!
//! **Modern Proxy Protocol with Full Features:**
//! -  IPv4 and IPv6 support
//! -  Domain name resolution by proxy
//! -  Authentication (user/password, GSSAPI)
//! -  Multiple commands (CONNECT, BIND, UDP ASSOCIATE)
//!
//! **Protocol Flow:**
//! ```
//! 1. Client  Proxy: Authentication method selection
//!    +-----+----------+----------+
//!    | VER | NMETHODS | METHODS  |
//!    +-----+----------+----------+
//!    |  1  |    1     | 1 to 255 |
//!    +-----+----------+----------+
//!
//! 2. Proxy  Client: Selected method
//!    +-----+--------+
//!    | VER | METHOD |
//!    +-----+--------+
//!    |  1  |   1    |
//!    +-----+--------+
//!
//! 3. [If auth required] Username/Password authentication (RFC 1929)
//!
//! 4. Client  Proxy: Connection request
//!    +-----+-----+-------+------+----------+----------+
//!    | VER | CMD |  RSV  | ATYP | DST.ADDR | DST.PORT |
//!    +-----+-----+-------+------+----------+----------+
//!    |  1  |  1  | 0x00  |  1   | Variable |    2     |
//!    +-----+-----+-------+------+----------+----------+
//!
//! 5. Proxy  Client: Connection response
//!    +-----+-----+-------+------+----------+----------+
//!    | VER | REP |  RSV  | ATYP | BND.ADDR | BND.PORT |
//!    +-----+-----+-------+------+----------+----------+
//! ```
//!
//! **Address Types (ATYP):**
//! - 0x01: IPv4 (4 bytes)
//! - 0x03: Domain name (1-byte length + name)
//! - 0x04: IPv6 (16 bytes)
//!
//! **Authentication Methods:**
//! - 0x00: No authentication
//! - 0x01: GSSAPI (not implemented)
//! - 0x02: Username/Password (RFC 1929)
//! - 0xFF: No acceptable methods
//!
//! **Reply Codes:**
//! - 0x00: Success
//! - 0x01: General SOCKS server failure
//! - 0x02: Connection not allowed by ruleset
//! - 0x03: Network unreachable
//! - 0x04: Host unreachable
//! - 0x05: Connection refused
//! - 0x06: TTL expired
//! - 0x07: Command not supported
//! - 0x08: Address type not supported
//!
//! **References:**
//! - RFC 1928: SOCKS Protocol Version 5
//! - RFC 1929: Username/Password Authentication

const std = @import("std");
const posix = std.posix;
const socket = @import("../socket.zig");
const http_connect = @import("http_connect.zig");
const poll_wrapper = @import("../../util/poll_wrapper.zig");
const logging = @import("../../util/logging.zig");

pub const ProxyAuth = http_connect.ProxyAuth;

// SOCKS5 protocol constants (RFC 1928)
const SOCKS5_VERSION: u8 = 0x05;

// Authentication methods
const AUTH_NO_AUTH: u8 = 0x00;
const AUTH_GSSAPI: u8 = 0x01;
const AUTH_USERNAME_PASSWORD: u8 = 0x02;
const AUTH_NO_ACCEPTABLE: u8 = 0xFF;

// Commands
const CMD_CONNECT: u8 = 0x01;
const CMD_BIND: u8 = 0x02;
const CMD_UDP_ASSOCIATE: u8 = 0x03;

// Address types
const ATYP_IPV4: u8 = 0x01;
const ATYP_DOMAIN: u8 = 0x03;
const ATYP_IPV6: u8 = 0x04;

// Reply codes
const REP_SUCCESS: u8 = 0x00;
const REP_GENERAL_FAILURE: u8 = 0x01;
const REP_CONNECTION_NOT_ALLOWED: u8 = 0x02;
const REP_NETWORK_UNREACHABLE: u8 = 0x03;
const REP_HOST_UNREACHABLE: u8 = 0x04;
const REP_CONNECTION_REFUSED: u8 = 0x05;
const REP_TTL_EXPIRED: u8 = 0x06;
const REP_COMMAND_NOT_SUPPORTED: u8 = 0x07;
const REP_ADDRESS_TYPE_NOT_SUPPORTED: u8 = 0x08;

/// Connect to target through SOCKS5 proxy with optional authentication.
///
/// **Parameters:**
/// - `allocator`: Memory allocator for request/response buffers
/// - `proxy_host`: SOCKS5 proxy hostname or IP
/// - `proxy_port`: SOCKS5 proxy port (typically 1080)
/// - `target_host`: Destination hostname, IPv4, or IPv6
/// - `target_port`: Destination port
/// - `auth`: Optional username/password credentials
/// - `timeout_ms`: Connection timeout in milliseconds
///
/// **Returns:**
/// Socket connected to target through SOCKS5 proxy.
///
/// **Errors:**
/// - `error.NoAcceptableAuthMethod`: Proxy requires auth we don't support
/// - `error.AuthenticationRequired`: Auth needed but not provided
/// - `error.AuthenticationFailed`: Invalid username/password
/// - `error.Socks5ConnectionFailed`: Proxy rejected connection (see reply code)
/// - `error.ConnectionTimeout`: Proxy connect timeout
/// - `error.InvalidProxyResponse`: Malformed SOCKS5 response
///
/// **Protocol Steps:**
/// 1. Connect to SOCKS5 proxy server
/// 2. Send authentication method selection (no-auth + user/pass if provided)
/// 3. Receive selected authentication method
/// 4. If user/pass selected, authenticate (RFC 1929)
/// 5. Send CONNECT request (supports IPv4/IPv6/domain)
/// 6. Receive CONNECT response
/// 7. Return connected socket
///
/// **Address Type Selection:**
/// - If `target_host` parses as IPv4: Use ATYP_IPV4
/// - If `target_host` parses as IPv6: Use ATYP_IPV6
/// - Otherwise: Use ATYP_DOMAIN (proxy resolves DNS)
///
/// **Example:**
/// ```zig
/// const auth = ProxyAuth{ .username = "user", .password = "pass" };
/// const sock = try connect(
///     allocator,
///     "socks5.example.com",
///     1080,
///     "ipv6.google.com",  // Works with IPv6!
///     443,
///     auth,
///     30000
/// );
/// ```
pub fn connect(
    allocator: std.mem.Allocator,
    proxy_host: []const u8,
    proxy_port: u16,
    target_host: []const u8,
    target_port: u16,
    auth: ?ProxyAuth,
    timeout_ms: u32,
) !socket.Socket {
    // Step 1: Connect to SOCKS5 proxy
    const sock = try connectToProxy(proxy_host, proxy_port, timeout_ms);
    errdefer socket.closeSocket(sock);

    // Step 2: Send authentication method selection
    try sendAuthMethodSelection(sock, auth != null);

    // Step 3: Read authentication method response
    const selected_method = try readAuthMethodResponse(sock);

    // Step 4: Perform authentication if required
    if (selected_method == AUTH_USERNAME_PASSWORD) {
        if (auth) |credentials| {
            try authenticateUserPassword(sock, credentials);
        } else {
            return error.AuthenticationRequired;
        }
    } else if (selected_method == AUTH_NO_ACCEPTABLE) {
        return error.NoAcceptableAuthMethod;
    }

    // Step 5: Send CONNECT request
    try sendConnectRequest(allocator, sock, target_host, target_port);

    // Step 6: Read CONNECT response
    try readConnectResponse(allocator, sock);

    // Step 7: Connection established
    return sock;
}

fn connectToProxy(host: []const u8, port: u16, timeout_ms: u32) !socket.Socket {
    const family = socket.detectAddressFamily(host);
    const sock = try socket.createTcpSocket(family);
    errdefer socket.closeSocket(sock);

    try socket.setNonBlocking(sock);

    const addr_list = try std.net.getAddressList(
        std.heap.page_allocator,
        host,
        port,
    );
    defer addr_list.deinit();

    if (addr_list.addrs.len == 0) {
        return error.UnknownHost;
    }

    var last_error: ?anyerror = null;
    for (addr_list.addrs) |addr| {
        const result = posix.connect(sock, &addr.any, addr.getOsSockLen());

        if (result) {
            return sock;
        } else |err| {
            if (err == error.WouldBlock or err == error.InProgress) {
                if (try waitForConnect(sock, timeout_ms)) {
                    return sock;
                }
                last_error = error.ConnectionTimeout;
            } else {
                last_error = err;
            }
        }
    }

    return last_error orelse error.ConnectionFailed;
}

fn waitForConnect(sock: socket.Socket, timeout_ms: u32) !bool {
    var pollfds = [_]poll_wrapper.pollfd{.{
        .fd = sock,
        .events = poll_wrapper.POLL.OUT,
        .revents = 0,
    }};

    const ready = try poll_wrapper.poll(&pollfds, @intCast(timeout_ms));
    if (ready == 0) return false;

    var err: i32 = undefined;
    const len: posix.socklen_t = @sizeOf(i32);
    try posix.getsockopt(sock, posix.SOL.SOCKET, posix.SO.ERROR, std.mem.asBytes(&err)[0..len]);

    return err == 0;
}

/// Send authentication method selection
fn sendAuthMethodSelection(sock: socket.Socket, needs_auth: bool) !void {
    var request: [4]u8 = undefined;
    request[0] = SOCKS5_VERSION;

    if (needs_auth) {
        request[1] = 2; // Number of methods
        request[2] = AUTH_NO_AUTH;
        request[3] = AUTH_USERNAME_PASSWORD;
        _ = try posix.send(sock, request[0..4], 0);
    } else {
        request[1] = 1; // Number of methods
        request[2] = AUTH_NO_AUTH;
        _ = try posix.send(sock, request[0..3], 0);
    }
}

/// Read authentication method response
fn readAuthMethodResponse(sock: socket.Socket) !u8 {
    var response: [2]u8 = undefined;

    var pollfds = [_]poll_wrapper.pollfd{.{
        .fd = sock,
        .events = poll_wrapper.POLL.IN,
        .revents = 0,
    }};

    const ready = try poll_wrapper.poll(&pollfds, 30000);
    if (ready == 0) return error.ProxyTimeout;

    const n = try posix.recv(sock, &response, 0);
    if (n != 2) return error.InvalidProxyResponse;

    if (response[0] != SOCKS5_VERSION) {
        return error.InvalidProxyResponse;
    }

    return response[1];
}

/// Authenticate with username/password (RFC 1929)
fn authenticateUserPassword(sock: socket.Socket, auth: ProxyAuth) !void {
    var request: [513]u8 = undefined;
    var idx: usize = 0;

    // Version (1 for username/password auth)
    request[idx] = 0x01;
    idx += 1;

    // Username length and username
    if (auth.username.len > 255) return error.UsernameTooLong;
    request[idx] = @intCast(auth.username.len);
    idx += 1;
    @memcpy(request[idx..][0..auth.username.len], auth.username);
    idx += auth.username.len;

    // Password length and password
    if (auth.password.len > 255) return error.PasswordTooLong;
    request[idx] = @intCast(auth.password.len);
    idx += 1;
    @memcpy(request[idx..][0..auth.password.len], auth.password);
    idx += auth.password.len;

    // Send authentication request
    _ = try posix.send(sock, request[0..idx], 0);

    // Read response
    var response: [2]u8 = undefined;
    var pollfds = [_]poll_wrapper.pollfd{.{
        .fd = sock,
        .events = poll_wrapper.POLL.IN,
        .revents = 0,
    }};

    const ready = try poll_wrapper.poll(&pollfds, 30000);
    if (ready == 0) return error.ProxyTimeout;

    const n = try posix.recv(sock, &response, 0);
    if (n != 2) return error.InvalidProxyResponse;

    if (response[1] != 0) {
        return error.AuthenticationFailed;
    }
}

/// Send CONNECT request
fn sendConnectRequest(
    allocator: std.mem.Allocator,
    sock: socket.Socket,
    target_host: []const u8,
    target_port: u16,
) !void {
    var request = std.ArrayList(u8){};
    defer request.deinit(allocator);

    // Version, Command, Reserved
    try request.append(allocator, SOCKS5_VERSION);
    try request.append(allocator, CMD_CONNECT);
    try request.append(allocator, 0x00); // Reserved

    // Determine address type
    if (std.net.Address.parseIp4(target_host, 0)) |addr| {
        // IPv4 address
        try request.append(allocator, ATYP_IPV4);
        const ip4_bytes = @as(*const [4]u8, @ptrCast(&addr.in.sa.addr));
        try request.appendSlice(allocator, ip4_bytes);
    } else |_| {
        if (std.net.Address.parseIp6(target_host, 0)) |addr| {
            // IPv6 address
            try request.append(allocator, ATYP_IPV6);
            const ip6_bytes = @as(*const [16]u8, @ptrCast(&addr.in6.sa.addr));
            try request.appendSlice(allocator, ip6_bytes);
        } else |_| {
            // Domain name
            try request.append(allocator, ATYP_DOMAIN);
            if (target_host.len > 255) return error.DomainNameTooLong;
            try request.append(allocator, @intCast(target_host.len));
            try request.appendSlice(allocator, target_host);
        }
    }

    // Port (big-endian)
    try request.append(allocator, @intCast((target_port >> 8) & 0xFF));
    try request.append(allocator, @intCast(target_port & 0xFF));

    // Send request
    _ = try posix.send(sock, request.items, 0);
}

/// Read CONNECT response
fn readConnectResponse(_: std.mem.Allocator, sock: socket.Socket) !void {
    var buffer: [512]u8 = undefined;

    var pollfds = [_]poll_wrapper.pollfd{.{
        .fd = sock,
        .events = poll_wrapper.POLL.IN,
        .revents = 0,
    }};

    const ready = try poll_wrapper.poll(&pollfds, 30000);
    if (ready == 0) return error.ProxyTimeout;

    // Read at least first 4 bytes
    const n = try posix.recv(sock, &buffer, 0);
    if (n < 4) return error.InvalidProxyResponse;

    const version = buffer[0];
    const reply = buffer[1];
    const atyp = buffer[3];

    if (version != SOCKS5_VERSION) {
        return error.InvalidProxyResponse;
    }

    if (reply != REP_SUCCESS) {
        const err_msg = switch (reply) {
            REP_GENERAL_FAILURE => "General SOCKS server failure",
            REP_CONNECTION_NOT_ALLOWED => "Connection not allowed by ruleset",
            REP_NETWORK_UNREACHABLE => "Network unreachable",
            REP_HOST_UNREACHABLE => "Host unreachable",
            REP_CONNECTION_REFUSED => "Connection refused",
            REP_TTL_EXPIRED => "TTL expired",
            REP_COMMAND_NOT_SUPPORTED => "Command not supported",
            REP_ADDRESS_TYPE_NOT_SUPPORTED => "Address type not supported",
            else => "Unknown error",
        };
        logging.logVerbose(null, "SOCKS5 error: {s}\n", .{err_msg});
        return error.Socks5ConnectionFailed;
    }

    // Response includes bound address - we can ignore it for client connections
    _ = atyp;
}
</file>

<file path="net/unixsock/client.zig">
//! Unix Domain Socket client implementation.
//!
//! Handles client-side Unix socket operations including initialization
//! and connection establishment.

const std = @import("std");
const builtin = @import("builtin");
const posix = std.posix;
const socket_mod = @import("../socket.zig");
const utils = @import("utils.zig");
const logging = @import("../../util/logging.zig");

/// Unix socket client structure.
pub const UnixClient = struct {
    socket: socket_mod.Socket,
    path: []const u8,
    allocator: std.mem.Allocator,
    path_owned: bool,

    /// Initialize Unix socket client for connecting to existing socket.
    pub fn init(allocator: std.mem.Allocator, path: []const u8) !UnixClient {
        if (!utils.unix_socket_supported) {
            return error.NotSupported;
        }

        if (path.len == 0) return error.InvalidPath;
        if (path.len >= 108) return error.PathTooLong;

        const sock = try posix.socket(posix.AF.UNIX, posix.SOCK.STREAM, 0);
        errdefer socket_mod.closeSocket(sock);

        const owned_path = try allocator.dupe(u8, path);
        errdefer allocator.free(owned_path);

        return UnixClient{
            .socket = sock,
            .path = owned_path,
            .allocator = allocator,
            .path_owned = true,
        };
    }

    /// Connect to Unix socket server.
    pub fn connect(self: *UnixClient) !void {
        const addr = try utils.UnixAddress.fromPath(self.path);
        try posix.connect(self.socket, @ptrCast(&addr), addr.getLen());
    }

    /// Close socket and free resources.
    pub fn close(self: *UnixClient) void {
        socket_mod.closeSocket(self.socket);
        if (self.path_owned) {
            self.allocator.free(self.path);
        }
    }

    /// Set socket to non-blocking mode.
    pub fn setNonBlocking(self: *UnixClient) !void {
        try socket_mod.setNonBlocking(self.socket);
    }

    /// Get underlying socket descriptor.
    pub fn getSocket(self: *const UnixClient) socket_mod.Socket {
        return self.socket;
    }

    /// Get socket path.
    pub fn getPath(self: *const UnixClient) []const u8 {
        return self.path;
    }
};
</file>

<file path="net/unixsock/server.zig">
//! Unix Domain Socket server implementation.
//!
//! Handles server-side Unix socket operations including initialization,
//! binding, listening, and accepting connections.

const std = @import("std");
const builtin = @import("builtin");
const posix = std.posix;
const socket_mod = @import("../socket.zig");
const utils = @import("utils.zig");
const logging = @import("../../util/logging.zig");

/// Unix socket server structure.
pub const UnixServer = struct {
    socket: socket_mod.Socket,
    path: []const u8,
    allocator: std.mem.Allocator,
    path_owned: bool,

    /// Initialize Unix socket server. Creates parent directories and removes
    /// existing socket files as needed. Automatically starts listening.
    pub fn init(allocator: std.mem.Allocator, path: []const u8) !UnixServer {
        if (!utils.unix_socket_supported) {
            return error.NotSupported;
        }

        if (path.len == 0) return error.InvalidPath;
        if (path.len >= 108) return error.PathTooLong;

        // Create parent directory if needed
        if (std.fs.path.dirname(path)) |dir| {
            std.fs.cwd().makePath(dir) catch |err| switch (err) {
                error.PathAlreadyExists => {},
                else => return err,
            };
        }

        // Handle existing socket file (uses connect-before-delete to avoid TOCTTOU)
        try utils.handleExistingSocketFile(path);

        const sock = try posix.socket(posix.AF.UNIX, posix.SOCK.STREAM, 0);
        errdefer socket_mod.closeSocket(sock);

        const addr = try utils.UnixAddress.fromPath(path);

        // SECURITY: Set restrictive umask before creating socket file
        // This prevents brief exposure with permissive default umask permissions
        // Socket file will be created with 0o700 (rwx------) permissions
        const old_umask = posix.umask(0o077); // Deny all permissions to group and others
        defer _ = posix.umask(old_umask); // Restore original umask

        try posix.bind(sock, @ptrCast(&addr), addr.getLen());
        errdefer std.fs.cwd().deleteFile(path) catch {};

        try posix.listen(sock, 128);

        // SECURITY: Validate socket file permissions before accepting connections
        const security = @import("../../util/security.zig");
        security.validateUnixSocketPermissions(path) catch |err| {
            // Log validation errors but don't fail server startup
            // FileNotFound is expected on some platforms/race conditions
            if (err != error.FileNotFound and err != error.AccessDenied) {
                logging.logWarning("Socket permission validation failed: {any}\n", .{err});
            }
        };

        const owned_path = try allocator.dupe(u8, path);
        errdefer allocator.free(owned_path);

        return UnixServer{
            .socket = sock,
            .path = owned_path,
            .allocator = allocator,
            .path_owned = true,
        };
    }

    /// Accept incoming connection. Returns new socket representing the client.
    pub fn accept(self: *UnixServer) !socket_mod.Socket {
        var addr: posix.sockaddr = undefined;
        var addr_len: posix.socklen_t = @sizeOf(posix.sockaddr);

        return try posix.accept(self.socket, &addr, &addr_len, 0);
    }

    /// Close socket without removing socket file. Use cleanup() for full cleanup.
    pub fn close(self: *UnixServer) void {
        socket_mod.closeSocket(self.socket);
        if (self.path_owned) {
            self.allocator.free(self.path);
        }
    }

    /// Close socket and remove socket file with comprehensive error handling.
    pub fn cleanup(self: *UnixServer) void {
        utils.cleanupUnixSocketResources(
            self.socket,
            self.path,
            true, // is_server
            self.path_owned,
            false, // force_cleanup
            false, // verbose
        );
        if (self.path_owned) {
            self.allocator.free(self.path);
        }
    }

    /// Close socket and remove socket file with detailed error reporting.
    pub fn cleanupVerbose(self: *UnixServer, force_cleanup: bool) void {
        utils.cleanupUnixSocketResources(
            self.socket,
            self.path,
            true, // is_server
            self.path_owned,
            force_cleanup,
            true, // verbose
        );
        if (self.path_owned) {
            self.allocator.free(self.path);
        }
    }

    /// Set socket to non-blocking mode.
    pub fn setNonBlocking(self: *UnixServer) !void {
        try socket_mod.setNonBlocking(self.socket);
    }

    /// Get underlying socket descriptor.
    pub fn getSocket(self: *const UnixServer) socket_mod.Socket {
        return self.socket;
    }

    /// Get socket path.
    pub fn getPath(self: *const UnixServer) []const u8 {
        return self.path;
    }
};
</file>

<file path="net/unixsock/utils.zig">
//! Unix Domain Socket utilities and shared functionality.
//!
//! Provides common utilities for Unix socket operations including address handling,
//! validation, error mapping, and cleanup operations.

const std = @import("std");
const builtin = @import("builtin");
const posix = std.posix;
const socket_mod = @import("../socket.zig");
const logging = @import("../../util/logging.zig");
const config = @import("../../config.zig");

/// Platform support detection for Unix domain sockets.
pub const unix_socket_supported = switch (builtin.os.tag) {
    .linux, .macos, .freebsd, .openbsd, .netbsd, .dragonfly => true,
    else => false,
};

/// Comprehensive error types for Unix socket operations with detailed categorization.
pub const UnixSocketError = error{
    // Path validation errors
    PathTooLong,
    InvalidPath,
    PathContainsNull,
    DirectoryNotFound,
    InvalidPathCharacters,

    // File system errors
    SocketFileExists,
    PermissionDenied,
    InsufficientPermissions,
    DiskFull,
    FileLocked,
    IsDirectory,
    FileSystemError,

    // Socket operation errors
    AddressInUse,
    AddressNotAvailable,
    NetworkUnreachable,
    ConnectionRefused,
    ConnectionReset,
    ConnectionAborted,
    SocketNotConnected,
    SocketAlreadyConnected,

    // Platform and feature errors
    NotSupported,
    PlatformNotSupported,
    FeatureNotAvailable,

    // Resource management errors
    CleanupFailed,
    ResourceExhausted,
    TooManyOpenFiles,
    OutOfMemory,

    // Configuration errors
    InvalidOperation,
    ConflictingConfiguration,
    UnsupportedCombination,
};

/// Unix socket address structure for POSIX systems.
pub const UnixAddress = struct {
    family: u16,
    path: [108]u8,

    pub fn fromPath(path: []const u8) !UnixAddress {
        if (path.len == 0) return error.InvalidPath;
        if (path.len >= 108) return error.PathTooLong;

        var addr = UnixAddress{
            .family = posix.AF.UNIX,
            .path = std.mem.zeroes([108]u8),
        };

        @memcpy(addr.path[0..path.len], path);
        return addr;
    }

    pub fn getLen(self: *const UnixAddress) posix.socklen_t {
        const path_len = std.mem.indexOfScalar(u8, &self.path, 0) orelse self.path.len;
        return @intCast(2 + path_len); // family (2 bytes) + path
    }

    pub fn getPath(self: *const UnixAddress) []const u8 {
        const end = std.mem.indexOfScalar(u8, &self.path, 0) orelse self.path.len;
        return self.path[0..end];
    }
};

/// Handle existing socket files with comprehensive error recovery.
///
/// SECURITY: Uses connect-before-delete pattern to eliminate TOCTTOU race condition.
/// This is the industry-standard approach used by nginx, Apache, and systemd.
///
/// Strategy for existing files:
/// 1. Attempt to connect to the socket path
/// 2. If ConnectionRefused: Socket exists but no listener  stale socket, safe to remove
/// 3. If FileNotFound: No socket file exists  proceed normally
/// 4. If connection succeeds: Socket is actively in use  return AddressInUse
/// 5. Other errors: Map to appropriate UnixSocketError types
///
/// This eliminates the TOCTTOU race by using a single functional test (connect attempt)
/// instead of separate stat-then-delete operations. An attacker cannot exploit a race
/// because the connect operation atomically tests whether the socket is functional.
///
/// Benefits over stat-then-delete:
/// - No race condition window
/// - Functional test proves socket is truly stale
/// - Single atomic operation
/// - Cannot be tricked by symlink replacement
pub fn handleExistingSocketFile(path: []const u8) UnixSocketError!void {
    // Create a test socket to probe the existing socket
    const test_sock = posix.socket(posix.AF.UNIX, posix.SOCK.STREAM, 0) catch |err| {
        // Socket creation failed - treat as file system error
        logging.logDebug("Failed to create test socket for probing: {any}\n", .{err});
        return UnixSocketError.FileSystemError;
    };
    defer posix.close(test_sock);

    // Create Unix socket address for connection attempt
    const addr = UnixAddress.fromPath(path) catch |err| {
        // Path validation failed during address creation
        return err;
    };

    // Attempt to connect to existing socket
    // This is the key security improvement: single atomic operation instead of check-then-act
    posix.connect(test_sock, @ptrCast(&addr), addr.getLen()) catch |err| switch (err) {
        error.ConnectionRefused => {
            // ECONNREFUSED: Socket file exists but no process is listening
            // This definitively proves the socket is stale and safe to remove
            logging.logDebug("Stale socket detected at '{s}', removing\n", .{path});

            std.fs.cwd().deleteFile(path) catch |del_err| switch (del_err) {
                error.FileNotFound => {}, // Already removed by another process - OK
                error.AccessDenied => return UnixSocketError.PermissionDenied,
                error.FileBusy => return UnixSocketError.FileLocked,
                error.SystemResources => return UnixSocketError.ResourceExhausted,
                error.ReadOnlyFileSystem => return UnixSocketError.InsufficientPermissions,
                else => {
                    logging.logWarning("Failed to remove stale socket: {any}\n", .{del_err});
                    return UnixSocketError.CleanupFailed;
                },
            };
            return; // Successfully cleaned up stale socket
        },
        error.FileNotFound => {
            // ENOENT: No socket file exists at path - proceed normally
            return;
        },
        error.PermissionDenied, error.AccessDenied => {
            // EACCES: Cannot access the socket - permission issue
            return UnixSocketError.PermissionDenied;
        },
        error.AddressInUse => {
            // EADDRINUSE: Socket address is already bound (shouldn't happen on connect)
            return UnixSocketError.AddressInUse;
        },
        else => {
            // Other errors: Log and map to appropriate error type
            logging.logDebug("Socket probe failed for '{s}': {any}\n", .{ path, err });
            return handleSocketError(err, "socket probe");
        },
    };

    // Connection succeeded - socket is actively in use!
    logging.logDebug("Socket at '{s}' is actively in use\n", .{path});
    return UnixSocketError.AddressInUse;
}

/// Comprehensive Unix socket path validation with detailed error reporting.
///
/// Validates Unix socket paths for:
/// - Length limits (107 bytes max for portability)
/// - Invalid characters (null bytes, control characters)
/// - Directory accessibility and permissions
/// - Platform-specific path requirements
/// - File system constraints
///
/// Returns specific errors for different validation failures to enable
/// targeted error handling and user-friendly error messages.
pub fn validatePath(path: []const u8) UnixSocketError!void {
    // Basic path validation
    if (path.len == 0) return UnixSocketError.InvalidPath;
    if (path.len >= 108) return UnixSocketError.PathTooLong;

    // Check for null bytes (invalid in Unix paths)
    if (std.mem.indexOfScalar(u8, path, 0) != null) {
        return UnixSocketError.PathContainsNull;
    }

    // Check for invalid control characters (except tab)
    for (path) |byte| {
        if (byte < 32 and byte != '\t') {
            return UnixSocketError.InvalidPathCharacters;
        }
    }

    // Validate parent directory accessibility
    if (std.fs.path.dirname(path)) |dir| {
        validateDirectoryAccess(dir) catch |err| switch (err) {
            error.FileNotFound => return UnixSocketError.DirectoryNotFound,
            error.AccessDenied => return UnixSocketError.PermissionDenied,
            error.SystemResources => return UnixSocketError.ResourceExhausted,
            else => return UnixSocketError.FileSystemError,
        };
    }

    // Platform-specific validation
    try validatePlatformSpecificPath(path);
}

/// Validate directory access with comprehensive error mapping.
fn validateDirectoryAccess(dir_path: []const u8) !void {
    std.fs.cwd().access(dir_path, .{}) catch |err| switch (err) {
        error.FileNotFound => return error.FileNotFound,
        error.AccessDenied => return error.AccessDenied,
        error.SystemResources => return error.SystemResources,
        else => return err,
    };
}

/// Platform-specific Unix socket path validation.
fn validatePlatformSpecificPath(path: []const u8) UnixSocketError!void {
    switch (builtin.os.tag) {
        .linux => {
            // Linux supports abstract namespace sockets (starting with null byte)
            // but we don't support them in this implementation for security reasons
            if (path.len > 0 and path[0] == 0) {
                return UnixSocketError.UnsupportedCombination;
            }
            // Linux supports standard 108-byte paths
        },
        .macos, .freebsd, .openbsd, .netbsd, .dragonfly => {
            // BSD variants have stricter 104-byte path limit (not 108 like Linux)
            // This is due to smaller sockaddr_un structure on BSD systems
            if (path.len >= 104) {
                logging.logDebug("Path too long for BSD platform: {d} bytes (max 103)\n", .{path.len});
                return UnixSocketError.PathTooLong;
            }
        },
        else => {
            // Other Unix-like systems - use conservative 104-byte limit
            if (path.len >= 104) {
                return UnixSocketError.PathTooLong;
            }
        },
    }
}

/// Check Unix socket support with detailed platform information.
pub fn checkSupport() UnixSocketError!void {
    if (!unix_socket_supported) {
        return UnixSocketError.PlatformNotSupported;
    }
}

/// Handle Unix socket operation errors with detailed error mapping and recovery suggestions.
///
/// Maps low-level POSIX errors to specific UnixSocketError variants to enable
/// targeted error handling and user-friendly error messages.
pub fn handleSocketError(err: anyerror, operation: []const u8) UnixSocketError {
    return switch (err) {
        // Network and connection errors
        error.AddressInUse => UnixSocketError.AddressInUse,
        error.AddressNotAvailable => UnixSocketError.AddressNotAvailable,
        error.NetworkUnreachable => UnixSocketError.NetworkUnreachable,
        error.ConnectionRefused => UnixSocketError.ConnectionRefused,
        error.ConnectionResetByPeer => UnixSocketError.ConnectionReset,
        error.ConnectionAborted => UnixSocketError.ConnectionAborted,
        error.NotConnected => UnixSocketError.SocketNotConnected,
        error.AlreadyConnected => UnixSocketError.SocketAlreadyConnected,

        // Permission and access errors
        error.AccessDenied => UnixSocketError.PermissionDenied,
        error.PermissionDenied => UnixSocketError.InsufficientPermissions,

        // File system errors
        error.FileNotFound => UnixSocketError.DirectoryNotFound,
        error.IsDir => UnixSocketError.IsDirectory,
        error.FileBusy => UnixSocketError.FileLocked,
        error.NoSpaceLeft => UnixSocketError.DiskFull,
        error.ReadOnlyFileSystem => UnixSocketError.InsufficientPermissions,

        // Resource exhaustion errors
        error.SystemResources => UnixSocketError.ResourceExhausted,
        error.ProcessFdQuotaExceeded, error.SystemFdQuotaExceeded => UnixSocketError.TooManyOpenFiles,
        error.OutOfMemory => UnixSocketError.OutOfMemory,

        // Path and validation errors
        error.NameTooLong => UnixSocketError.PathTooLong,
        error.InvalidUtf8 => UnixSocketError.InvalidPathCharacters,

        // Platform support errors
        error.OperationNotSupported => UnixSocketError.NotSupported,
        error.ProtocolNotSupported => UnixSocketError.FeatureNotAvailable,

        // Generic fallback
        else => blk: {
            logging.logWarning("Unmapped Unix socket error in {s}: {any}\n", .{ operation, err });
            break :blk UnixSocketError.FileSystemError;
        },
    };
}

/// Provide user-friendly error messages for Unix socket errors.
///
/// Returns detailed error descriptions and recovery suggestions for different
/// error categories to help users diagnose and resolve issues.
pub fn getErrorMessage(err: UnixSocketError, path: []const u8, operation: []const u8) []const u8 {
    _ = path;
    _ = operation;
    return switch (err) {
        // Path validation errors
        UnixSocketError.PathTooLong => "Unix socket path is too long (max 107 characters)",
        UnixSocketError.InvalidPath => "Unix socket path is invalid or empty",
        UnixSocketError.PathContainsNull => "Unix socket path contains null bytes",
        UnixSocketError.DirectoryNotFound => "Parent directory for Unix socket does not exist",
        UnixSocketError.InvalidPathCharacters => "Unix socket path contains invalid characters",

        // File system errors
        UnixSocketError.SocketFileExists => "File exists at socket path but is not a Unix socket",
        UnixSocketError.PermissionDenied => "Permission denied accessing Unix socket path",
        UnixSocketError.InsufficientPermissions => "Insufficient permissions for Unix socket operation",
        UnixSocketError.DiskFull => "Disk full - cannot create Unix socket file",
        UnixSocketError.FileLocked => "Unix socket file is locked by another process",
        UnixSocketError.IsDirectory => "Unix socket path points to a directory",
        UnixSocketError.FileSystemError => "File system error during Unix socket operation",

        // Socket operation errors
        UnixSocketError.AddressInUse => "Unix socket address is already in use",
        UnixSocketError.AddressNotAvailable => "Unix socket address is not available",
        UnixSocketError.NetworkUnreachable => "Network unreachable for Unix socket",
        UnixSocketError.ConnectionRefused => "Connection refused to Unix socket",
        UnixSocketError.ConnectionReset => "Unix socket connection was reset",
        UnixSocketError.ConnectionAborted => "Unix socket connection was aborted",
        UnixSocketError.SocketNotConnected => "Unix socket is not connected",
        UnixSocketError.SocketAlreadyConnected => "Unix socket is already connected",

        // Platform and feature errors
        UnixSocketError.NotSupported => "Unix socket operation not supported",
        UnixSocketError.PlatformNotSupported => "Unix sockets not supported on this platform",
        UnixSocketError.FeatureNotAvailable => "Unix socket feature not available",

        // Resource management errors
        UnixSocketError.CleanupFailed => "Failed to clean up Unix socket file",
        UnixSocketError.ResourceExhausted => "System resources exhausted for Unix socket",
        UnixSocketError.TooManyOpenFiles => "Too many open files - cannot create Unix socket",
        UnixSocketError.OutOfMemory => "Out of memory for Unix socket operation",

        // Configuration errors
        UnixSocketError.InvalidOperation => "Invalid Unix socket operation",
        UnixSocketError.ConflictingConfiguration => "Conflicting Unix socket configuration",
        UnixSocketError.UnsupportedCombination => "Unsupported Unix socket feature combination",
    };
}

/// Handle Unix socket errors with logging and recovery suggestions.
///
/// Provides comprehensive error handling with:
/// - Detailed error messages based on error type
/// - Recovery suggestions for common issues
/// - Appropriate logging based on verbosity level
/// - Graceful degradation where possible
pub fn handleUnixSocketError(
    err: UnixSocketError,
    path: []const u8,
    operation: []const u8,
    verbose: bool,
) void {
    const error_msg = getErrorMessage(err, path, operation);

    if (verbose) {
        logging.logVerbose(null, "Unix socket error during {s} on '{s}': {s}\n", .{ operation, path, error_msg });

        // Provide recovery suggestions for common errors
        switch (err) {
            UnixSocketError.PermissionDenied, UnixSocketError.InsufficientPermissions => {
                logging.logVerbose(null, "Suggestion: Check file permissions and ensure the process has write access to the directory\n", .{});
            },
            UnixSocketError.DirectoryNotFound => {
                logging.logVerbose(null, "Suggestion: Create the parent directory or use an existing directory path\n", .{});
            },
            UnixSocketError.SocketFileExists => {
                logging.logVerbose(null, "Suggestion: Remove the existing file or choose a different socket path\n", .{});
            },
            UnixSocketError.AddressInUse => {
                logging.logVerbose(null, "Suggestion: Another process is using this socket - try a different path or stop the other process\n", .{});
            },
            UnixSocketError.PathTooLong => {
                logging.logVerbose(null, "Suggestion: Use a shorter socket path (max 107 characters)\n", .{});
            },
            UnixSocketError.PlatformNotSupported => {
                logging.logVerbose(null, "Suggestion: Unix sockets are not supported on this platform - use TCP sockets instead\n", .{});
            },
            else => {},
        }
    } else {
        // Non-verbose mode: concise error message
        logging.log(1, "Unix socket {s} failed: {s}\n", .{ operation, error_msg });
    }
}

/// Comprehensive resource cleanup for Unix sockets with error recovery.
///
/// Handles cleanup of Unix socket resources including:
/// - Socket file removal with error handling
/// - Memory deallocation with proper error reporting
/// - Graceful degradation on cleanup failures
/// - Logging of cleanup issues for debugging
pub fn cleanupUnixSocketResources(
    socket: socket_mod.Socket,
    path: []const u8,
    is_server: bool,
    path_owned: bool,
    force_cleanup: bool,
    verbose: bool,
) void {
    _ = path_owned;

    // Close socket first to prevent new connections (skip if invalid socket descriptor)
    // Note: Use > 0 instead of >= 0 to prevent accidentally closing stdin (fd 0) or stderr (fd 2)
    if (@as(i32, @bitCast(socket)) > 0) {
        socket_mod.closeSocket(socket);
    }

    // Clean up socket file if this is a server socket
    if (is_server and path.len > 0) {
        cleanupSocketFile(path, force_cleanup, verbose);
    }
}

/// Clean up Unix socket file with comprehensive error handling.
fn cleanupSocketFile(path: []const u8, force_cleanup: bool, verbose: bool) void {
    std.fs.cwd().deleteFile(path) catch |err| {
        // FileNotFound is not an error during cleanup - file already removed
        if (err == error.FileNotFound) {
            if (verbose) {
                logging.logWarning("Failed to remove Unix socket file '{s}': {any}\n", .{ path, err });
            }
            return;
        }

        const cleanup_err = handleSocketError(err, "cleanup");

        if (verbose) {
            const error_msg = getErrorMessage(cleanup_err, path, "cleanup");
            logging.logWarning("Failed to remove Unix socket file '{s}': {s}\n", .{ path, error_msg });

            // Provide recovery suggestions
            switch (cleanup_err) {
                UnixSocketError.PermissionDenied, UnixSocketError.InsufficientPermissions => {
                    logging.logWarning("Suggestion: Check file permissions or run with appropriate privileges\n", .{});
                },
                UnixSocketError.FileLocked => {
                    logging.logWarning("Suggestion: Another process may still be using the socket\n", .{});
                },
                UnixSocketError.ResourceExhausted => {
                    logging.logWarning("Suggestion: System resources exhausted - try again later\n", .{});
                },
                else => {
                    if (force_cleanup) {
                        logging.logWarning("Suggestion: Manual cleanup may be required for '{s}'\n", .{path});
                    }
                },
            }
        } else {
            // Non-verbose: just log the basic error
            logging.logWarning("Failed to remove Unix socket file '{s}': {any}\n", .{ path, err });
        }

        // In force cleanup mode, try alternative cleanup methods
        if (force_cleanup) {
            attemptForceCleanup(path, verbose);
        }
    };
}

/// Attempt alternative cleanup methods when standard cleanup fails.
fn attemptForceCleanup(path: []const u8, verbose: bool) void {
    // Try to stat the file to see if it still exists
    const stat = std.fs.cwd().statFile(path) catch |err| switch (err) {
        error.FileNotFound => {
            if (verbose) {
                logging.log(1, "Socket file '{s}' was already removed\n", .{path});
            }
            return; // File doesn't exist - cleanup successful
        },
        else => {
            if (verbose) {
                logging.logWarning("Cannot stat socket file '{s}' for force cleanup: {any}\n", .{ path, err });
            }
            return;
        },
    };

    // If file still exists, log detailed information for manual cleanup
    if (verbose) {
        logging.logWarning("Socket file '{s}' still exists after cleanup attempt:\n", .{path});
        logging.logWarning("  File type: {any}\n", .{stat.kind});
        logging.logWarning("  File size: {any} bytes\n", .{stat.size});
        logging.logWarning("  Manual removal may be required\n", .{});
    }
}

/// Validate Unix socket configuration with comprehensive error recovery.
///
/// Provides detailed validation with recovery suggestions for configuration issues.
/// Returns specific error types to enable targeted error handling in calling code.
pub fn validateUnixSocketConfiguration(
    path: []const u8,
    cfg: *const config.Config,
    verbose: bool,
) UnixSocketError!void {
    // Basic path validation
    validatePath(path) catch |err| {
        if (verbose) {
            handleUnixSocketError(err, path, "path validation", verbose);
        }
        return err;
    };

    // Platform support validation
    checkSupport() catch |err| {
        if (verbose) {
            handleUnixSocketError(err, path, "platform support check", verbose);
        }
        return err;
    };

    // Configuration conflict validation
    validateConfigurationConflicts(cfg) catch |err| {
        if (verbose) {
            handleUnixSocketError(err, path, "configuration validation", verbose);
        }
        return err;
    };
}

/// Validate Unix socket configuration conflicts with other features.
fn validateConfigurationConflicts(cfg: *const config.Config) UnixSocketError!void {
    // Check for conflicts with TCP mode
    if (cfg.positional_args.len > 0) {
        return UnixSocketError.ConflictingConfiguration;
    }

    // Check for conflicts with UDP mode
    if (cfg.udp_mode) {
        return UnixSocketError.UnsupportedCombination;
    }

    // Check for conflicts with TLS
    if (cfg.ssl) {
        return UnixSocketError.UnsupportedCombination;
    }

    // Check for conflicts with proxy settings
    if (cfg.proxy != null) {
        return UnixSocketError.UnsupportedCombination;
    }
}

/// Create Unix socket path in temporary directory for testing.
pub fn createTempPath(allocator: std.mem.Allocator, name: []const u8) ![]u8 {
    const temp_dir_owned = std.process.getEnvVarOwned(allocator, "TMPDIR") catch null;
    const temp_dir = temp_dir_owned orelse "/tmp";
    defer if (temp_dir_owned) |owned| allocator.free(owned);
    return std.fmt.allocPrint(allocator, "{s}/{s}", .{ temp_dir, name });
}
</file>

<file path="net/allowlist.zig">
//! IP Access Control Module
//!
//! This module provides IP-based access control with support for allow and deny lists.
//! It implements a flexible rule-based system that supports:
//!
//! ## Supported Rule Formats
//! - Single IPv4 addresses: "192.168.1.1"
//! - Single IPv6 addresses: "2001:db8::1"
//! - IPv4 CIDR ranges: "192.168.1.0/24"
//! - IPv6 CIDR ranges: "2001:db8::/32"
//! - Hostnames: "example.com" (DNS forward lookup A/AAAA records)
//!
//! ## Access Control Logic
//! 1. Deny rules are checked first (explicit denial)
//! 2. If deny list matches, access is DENIED immediately
//! 3. If allow list is empty, all addresses are ALLOWED (except denied)
//! 4. If allow list has entries, address must match at least one entry
//! 5. Deny rules take precedence over allow rules (security-first)
//!
//! ## CIDR Matching Algorithm
//! - IPv4: Uses 32-bit subnet mask comparison
//! - IPv6: Uses 128-bit byte-by-byte prefix comparison
//! - Prefix length validation: 0-32 for IPv4, 0-128 for IPv6
//!
//! ## Usage Example
//! ```zig
//! var access_list = AccessList.init(allocator);
//! defer access_list.deinit();
//!
//! // Deny entire private network
//! try access_list.addDenyRule("10.0.0.0/8");
//!
//! // Allow specific subnet
//! try access_list.addAllowRule("192.168.1.0/24");
//!
//! // Check if address is allowed
//! const addr = std.net.Address.initIp4([_]u8{192, 168, 1, 5}, 0);
//! if (access_list.isAllowed(addr)) {
//!     // Accept connection
//! }
//! ```
//!
//! ## Security Best Practices
//! - Use deny lists to block known malicious ranges (e.g., bogon addresses)
//! - Use allow lists to restrict access to trusted networks
//! - Combine both for defense-in-depth (deny malicious, allow trusted)
//! - Deny rules override allow rules (prevents accidental exposure)
//! - Validate CIDR prefix lengths to prevent wildcard matches (e.g., 0.0.0.0/0)
//!
//! ## File Format Specification
//! Access lists can be loaded from text files with one rule per line:
//! ```
//! # Allow local network
//! 192.168.0.0/16
//! 127.0.0.1
//!
//! # IPv6 support
//! 2001:db8::/32
//! ::1
//!
//! # Hostnames (DNS lookup - use with caution)
//! trusted.example.com
//! ```
//!
//! ## Security Warning: Hostname Rules
//! Hostname-based access control uses DNS forward lookups (A/AAAA records)
//! which are vulnerable to DNS manipulation attacks:
//! - DNS cache poisoning can redirect hostnames to attacker IPs
//! - DNS rebinding can change IP after initial authorization check
//! - Man-in-the-middle attacks can spoof DNS responses
//! - Compromised DNS servers can return malicious records
//!
//! Recommendations for production use:
//! - Prefer IP-based rules (single IP or CIDR) for security-critical ACLs
//! - Use DNSSEC validation if available
//! - Implement DNS result caching with short TTL (5-15 minutes)
//! - Rate limit DNS lookups to prevent DoS
//! - Log all hostname-based access control decisions for auditing
//!
//! ## Performance Characteristics
//! - Rule parsing: O(1) per rule (single-pass parsing)
//! - Match checking: O(n) where n = number of rules (linear search)
//! - CIDR matching: O(1) bitwise operations
//! - Memory: O(n) where n = number of rules + hostname strings
//!
//! ## Limitations
//! - Hostname rules use forward DNS only (not reverse DNS/PTR validation)
//! - DNS lookups add latency (10-100ms per connection with hostname rule)
//! - No support for dynamic rule updates (rebuild AccessList)
//! - No rule prioritization (order matters for overlapping CIDR ranges)
//! - No wildcard or regex support (use CIDR ranges instead)
//!
//! ## Module Structure
//! This module re-exports types and functions from specialized submodules:
//! - allowlist/dns_cache.zig: DNS caching with TTL
//! - allowlist/rule_parser.zig: Rule type definitions and parsing
//! - allowlist/ip_filter.zig: IP matching and CIDR logic

const std = @import("std");
const time = std.time;
const logging = @import("../util/logging.zig");

// Re-export submodules
const dns_cache = @import("allowlist/dns_cache.zig");
const rule_parser = @import("allowlist/rule_parser.zig");
const ip_filter = @import("allowlist/ip_filter.zig");

// Re-export types
pub const DnsCache = dns_cache.DnsCache;
pub const IpRule = rule_parser.IpRule;

// Re-export functions
pub const parseRule = rule_parser.parseRule;
pub const matchesRule = ip_filter.matchesRule;
pub const matchesCidrV4 = ip_filter.matchesCidrV4;
pub const matchesCidrV6 = ip_filter.matchesCidrV6;
pub const addressesEqual = ip_filter.addressesEqual;

/// IP access control list with allow and deny rules
///
/// Maintains two separate rule lists for access control:
/// - Allow list (whitelist): Addresses that should be permitted
/// - Deny list (blacklist): Addresses that should be blocked
///
/// ## Access Control Algorithm
/// 1. Check deny list first (O(n) where n = deny rules)
/// 2. If denied, return false immediately (deny takes precedence)
/// 3. If allow list is empty, return true (permissive default)
/// 4. Check allow list (O(m) where m = allow rules)
/// 5. If matched, return true, otherwise false (restrictive with allow list)
///
/// ## Security Model
/// This implements a "default deny" model when allow rules are present,
/// and a "default allow" model when allow list is empty. Deny rules
/// ALWAYS take precedence to prevent accidental exposure.
///
/// ## Memory Management
/// - List structures: Heap-allocated (ArrayListUnmanaged)
/// - Rules: Stack or heap (depending on type - see IpRule)
/// - Must call deinit() to free all resources
///
/// ## Thread Safety
/// - NOT thread-safe (no synchronization)
/// - Use external locking for concurrent access
/// - Modify on single thread, read from multiple threads is unsafe
///
/// ## Example Usage
/// ```zig
/// // Restrictive: Only allow specific network
/// var access_list = AccessList.init(allocator);
/// defer access_list.deinit();
///
/// try access_list.addAllowRule("192.168.1.0/24");
/// try access_list.addDenyRule("192.168.1.100");  // Deny specific host
///
/// const addr1 = std.net.Address.initIp4([_]u8{192, 168, 1, 50}, 0);
/// const addr2 = std.net.Address.initIp4([_]u8{192, 168, 1, 100}, 0);
/// const addr3 = std.net.Address.initIp4([_]u8{10, 0, 0, 1}, 0);
///
/// access_list.isAllowed(addr1);  // true (in allow range)
/// access_list.isAllowed(addr2);  // false (denied explicitly)
/// access_list.isAllowed(addr3);  // false (not in allow list)
/// ```
pub const AccessList = struct {
    /// Allow rules (whitelist) - addresses permitted for access
    allow_rules: std.ArrayListUnmanaged(IpRule),

    /// Deny rules (blacklist) - addresses blocked from access
    deny_rules: std.ArrayListUnmanaged(IpRule),

    /// Allocator for rule management
    allocator: std.mem.Allocator,

    /// DNS cache for hostname rules
    dns_cache_instance: DnsCache,

    /// Initialize empty access list
    ///
    /// ## Parameters
    /// - `allocator`: Memory allocator for rule storage
    ///
    /// ## Returns
    /// Empty AccessList with no rules (permissive mode - allows all)
    pub fn init(allocator: std.mem.Allocator) AccessList {
        return .{
            .allow_rules = .{},
            .deny_rules = .{},
            .allocator = allocator,
            .dns_cache_instance = DnsCache.init(allocator, 300), // 5 minute TTL
        };
    }

    /// Free all resources (rules and list storage)
    ///
    /// ## Safety
    /// - Safe to call multiple times (lists cleared on first call)
    /// - Must call before discarding AccessList
    /// - Frees hostname strings in rules
    /// - Deallocates internal list storage
    pub fn deinit(self: *AccessList) void {
        for (self.allow_rules.items) |*rule| {
            rule.deinit(self.allocator);
        }
        for (self.deny_rules.items) |*rule| {
            rule.deinit(self.allocator);
        }
        self.allow_rules.deinit(self.allocator);
        self.deny_rules.deinit(self.allocator);
        self.dns_cache_instance.deinit();
    }

    /// Add an allow rule from string representation
    ///
    /// Parses and appends a rule to the allow list (whitelist).
    /// Supported formats: "192.168.1.0/24", "10.0.0.1", "2001:db8::/32"
    pub fn addAllowRule(self: *AccessList, rule_str: []const u8) !void {
        const rule = try parseRule(self.allocator, rule_str);
        try self.allow_rules.append(self.allocator, rule);
    }

    /// Add a deny rule from string representation
    ///
    /// Parses and appends a rule to the deny list (blacklist).
    /// Deny rules take precedence over allow rules.
    pub fn addDenyRule(self: *AccessList, rule_str: []const u8) !void {
        const rule = try parseRule(self.allocator, rule_str);
        try self.deny_rules.append(self.allocator, rule);
    }

    /// Check if an address is allowed access
    ///
    /// Implements three-phase access control algorithm:
    /// 1. Check deny list first - if matched, DENY immediately
    /// 2. If allow list empty, ALLOW (permissive default)
    /// 3. Check allow list - if matched, ALLOW, otherwise DENY
    pub fn isAllowed(self: *AccessList, addr: std.net.Address) bool {
        // Check deny list first - deny takes precedence
        for (self.deny_rules.items) |rule| {
            if (matchesRule(&self.dns_cache_instance, addr, rule)) {
                return false;
            }
        }

        // If allow list is empty, allow all (that weren't denied)
        if (self.allow_rules.items.len == 0) {
            return true;
        }

        // Check if address matches any allow rule
        for (self.allow_rules.items) |rule| {
            if (matchesRule(&self.dns_cache_instance, addr, rule)) {
                return true;
            }
        }

        // Not in allow list
        return false;
    }
};

// ============================================================================
// Tests
// ============================================================================

test "parse single IPv4" {
    const allocator = std.testing.allocator;
    var rule = try parseRule(allocator, "192.168.1.1");
    defer rule.deinit(allocator);

    try std.testing.expect(rule == .single_ipv4);
}

test "parse IPv4 CIDR" {
    const allocator = std.testing.allocator;
    var rule = try parseRule(allocator, "192.168.1.0/24");
    defer rule.deinit(allocator);

    try std.testing.expect(rule == .cidr_v4);
    try std.testing.expectEqual(@as(u8, 24), rule.cidr_v4.prefix_len);
}

test "parse single IPv6" {
    const allocator = std.testing.allocator;
    var rule = try parseRule(allocator, "2001:db8::1");
    defer rule.deinit(allocator);

    try std.testing.expect(rule == .single_ipv6);
}

test "parse IPv6 CIDR" {
    const allocator = std.testing.allocator;
    var rule = try parseRule(allocator, "2001:db8::/32");
    defer rule.deinit(allocator);

    try std.testing.expect(rule == .cidr_v6);
    try std.testing.expectEqual(@as(u8, 32), rule.cidr_v6.prefix_len);
}

test "parse hostname" {
    const allocator = std.testing.allocator;
    var rule = try parseRule(allocator, "example.com");
    defer rule.deinit(allocator);

    try std.testing.expect(rule == .hostname);
    try std.testing.expectEqualStrings("example.com", rule.hostname);
}

test "IPv4 CIDR matching" {
    const addr1 = try std.net.Ip4Address.parse("192.168.1.5", 0);
    const addr2 = try std.net.Ip4Address.parse("192.168.2.5", 0);
    const cidr = try std.net.Ip4Address.parse("192.168.1.0", 0);

    try std.testing.expect(matchesCidrV4(addr1, cidr, 24));
    try std.testing.expect(!matchesCidrV4(addr2, cidr, 24));
}

test "IPv6 CIDR matching" {
    const addr1 = try std.net.Ip6Address.parse("2001:db8::5", 0);
    const addr2 = try std.net.Ip6Address.parse("2001:db9::5", 0);
    const cidr = try std.net.Ip6Address.parse("2001:db8::", 0);

    try std.testing.expect(matchesCidrV6(addr1, cidr, 32));
    try std.testing.expect(!matchesCidrV6(addr2, cidr, 32));
}

test "AccessList allow/deny logic" {
    const allocator = std.testing.allocator;
    var access_list = AccessList.init(allocator);
    defer access_list.deinit();

    // Add deny rule for 10.0.0.0/8
    try access_list.addDenyRule("10.0.0.0/8");

    // Add allow rule for 192.168.0.0/16
    try access_list.addAllowRule("192.168.0.0/16");

    // Test addresses
    const allowed_addr = std.net.Address.initIp4([_]u8{ 192, 168, 1, 1 }, 0);
    const denied_addr = std.net.Address.initIp4([_]u8{ 10, 0, 0, 1 }, 0);
    const other_addr = std.net.Address.initIp4([_]u8{ 8, 8, 8, 8 }, 0);

    // 192.168.1.1 should be allowed
    try std.testing.expect((&access_list).isAllowed(allowed_addr));

    // 10.0.0.1 should be denied (even though not in allow list)
    try std.testing.expect(!(&access_list).isAllowed(denied_addr));

    // 8.8.8.8 should be denied (not in allow list)
    try std.testing.expect(!(&access_list).isAllowed(other_addr));
}

test "AccessList empty allow list allows all" {
    const allocator = std.testing.allocator;
    var access_list = AccessList.init(allocator);
    defer access_list.deinit();

    // No rules - should allow everything
    const addr = std.net.Address.initIp4([_]u8{ 192, 168, 1, 1 }, 0);
    try std.testing.expect((&access_list).isAllowed(addr));
}

test "AccessList deny takes precedence" {
    const allocator = std.testing.allocator;
    var access_list = AccessList.init(allocator);
    defer access_list.deinit();

    // Add overlapping rules
    try access_list.addAllowRule("192.168.0.0/16");
    try access_list.addDenyRule("192.168.1.0/24");

    const allowed_addr = std.net.Address.initIp4([_]u8{ 192, 168, 2, 1 }, 0);
    const denied_addr = std.net.Address.initIp4([_]u8{ 192, 168, 1, 1 }, 0);

    // 192.168.2.1 should be allowed
    try std.testing.expect((&access_list).isAllowed(allowed_addr));

    // 192.168.1.1 should be denied (deny takes precedence)
    try std.testing.expect(!(&access_list).isAllowed(denied_addr));
}

test "hostname resolution and caching" {
    const allocator = std.testing.allocator;
    var cache = DnsCache.init(allocator, 1); // 1 second TTL
    defer cache.deinit();

    // Test DNS resolution for localhost
    const addresses = cache.resolve("localhost") catch |err| {
        // DNS resolution can fail in test environments
        logging.logVerbose(null, "DNS resolution failed (expected in some environments): {any}\n", .{err});
        return;
    };

    // Localhost should resolve to at least one address
    try std.testing.expect(addresses.len > 0);

    // Check that at least one address is loopback
    var found_loopback = false;
    for (addresses) |addr| {
        if (addr.any.family == std.posix.AF.INET) {
            const ipv4 = addr.in;
            const bytes = std.mem.asBytes(&ipv4.sa.addr);
            // 127.0.0.1 in network byte order
            if (bytes[0] == 127 and bytes[1] == 0 and bytes[2] == 0 and bytes[3] == 1) {
                found_loopback = true;
                break;
            }
        } else if (addr.any.family == std.posix.AF.INET6) {
            const ipv6 = addr.in6;
            // ::1 (all zeros except last byte)
            var is_loopback = true;
            for (ipv6.sa.addr[0..15]) |byte| {
                if (byte != 0) {
                    is_loopback = false;
                    break;
                }
            }
            if (is_loopback and ipv6.sa.addr[15] == 1) {
                found_loopback = true;
                break;
            }
        }
    }
    try std.testing.expect(found_loopback);

    // Check that the result is cached
    const cached_addresses = try cache.resolve("localhost");
    try std.testing.expectEqual(addresses.ptr, cached_addresses.ptr);

    // Wait for TTL to expire
    std.time.sleep(2 * std.time.ns_per_s);

    // Check that the entry is expired and a new resolution happens
    const new_addresses = try cache.resolve("localhost");
    try std.testing.expect(addresses.ptr != new_addresses.ptr);
}

test "hostname matching in AccessList" {
    const allocator = std.testing.allocator;
    var access_list = AccessList.init(allocator);
    defer access_list.deinit();

    // Add localhost hostname rule
    try access_list.addAllowRule("localhost");

    // Test with loopback address
    const loopback_v4 = std.net.Address.initIp4([_]u8{ 127, 0, 0, 1 }, 0);

    // This test may fail if DNS resolution is unavailable
    // In that case, the hostname rule will not match
    const is_allowed = (&access_list).isAllowed(loopback_v4);

    // Log result for debugging (test may pass or fail depending on DNS availability)
    logging.logVerbose(null, "Hostname matching test: localhost -> 127.0.0.1 allowed={any}\n", .{is_allowed});

    // We can't assert true/false reliably because DNS may be unavailable
    // The test passes if it doesn't crash - actual functionality validated manually
}

test "addressesEqual function" {
    // IPv4 addresses
    const addr1 = std.net.Address.initIp4([_]u8{ 192, 168, 1, 1 }, 80);
    const addr2 = std.net.Address.initIp4([_]u8{ 192, 168, 1, 1 }, 80);
    const addr3 = std.net.Address.initIp4([_]u8{ 192, 168, 1, 2 }, 80);
    const addr4 = std.net.Address.initIp4([_]u8{ 192, 168, 1, 1 }, 8080);

    try std.testing.expect(addressesEqual(addr1, addr2)); // Same IP and port
    try std.testing.expect(!addressesEqual(addr1, addr3)); // Different IP
    try std.testing.expect(!addressesEqual(addr1, addr4)); // Different port

    // IPv6 addresses
    const addr5 = try std.net.Address.parseIp6("2001:db8::1", 80);
    const addr6 = try std.net.Address.parseIp6("2001:db8::1", 80);
    const addr7 = try std.net.Address.parseIp6("2001:db8::2", 80);

    try std.testing.expect(addressesEqual(addr5, addr6)); // Same IP and port
    try std.testing.expect(!addressesEqual(addr5, addr7)); // Different IP

    // Different families
    try std.testing.expect(!addressesEqual(addr1, addr5)); // IPv4 vs IPv6
}
</file>

<file path="net/connection.zig">
//! Connection abstraction layer providing unified interface for TCP, TLS, and Unix domain sockets.
//!
//! Uses tagged union to enable polymorphic operations across connection types while maintaining
//! type safety and zero-cost abstractions.

const std = @import("std");
const builtin = @import("builtin");
const tls = @import("../tls/tls.zig");
const socket_mod = @import("socket.zig");
const logging = @import("../util/logging.zig");

/// Connection type enumeration for different socket types.
pub const ConnectionType = enum {
    tcp_plain,
    tcp_tls,
    udp,
    unix_socket,
};

/// Unix domain socket platform support detection.
pub const UnixSocketSupport = struct {
    pub const available = switch (builtin.os.tag) {
        .linux, .macos, .freebsd, .openbsd, .netbsd, .dragonfly => true,
        else => false,
    };

    pub fn checkSupport() !void {
        if (!available) {
            return error.UnixSocketsNotSupported;
        }
    }
};

/// Unified connection interface supporting TCP, TLS, and Unix domain sockets.
pub const Connection = union(enum) {
    plain: socket_mod.Socket,
    tls: tls.TlsConnection,
    unix_socket: struct {
        socket: socket_mod.Socket,
        path: ?[]const u8, // For cleanup tracking
    },

    /// Read data from the connection.
    /// Returns number of bytes read (0 indicates EOF).
    /// TLS connections may require multiple socket reads for one application read.
    pub fn read(self: *Connection, buffer: []u8) !usize {
        return switch (self.*) {
            .plain => |sock| {
                const result = std.posix.recv(sock, buffer, 0) catch |err| {
                    return err;
                };
                return result;
            },
            .tls => |*conn| conn.read(buffer),
            .unix_socket => |unix_conn| {
                const result = std.posix.recv(unix_conn.socket, buffer, 0) catch |err| {
                    return err;
                };
                return result;
            },
        };
    }

    /// Write data to the connection.
    /// Returns number of bytes written (may be less than data.len).
    /// TLS connections may require multiple socket writes for one application write.
    pub fn write(self: *Connection, data: []const u8) !usize {
        return switch (self.*) {
            .plain => |sock| {
                const result = std.posix.send(sock, data, 0) catch |err| {
                    return err;
                };
                return result;
            },
            .tls => |*conn| conn.write(data),
            .unix_socket => |unix_conn| {
                const result = std.posix.send(unix_conn.socket, data, 0) catch |err| {
                    return err;
                };
                return result;
            },
        };
    }

    /// Close the connection and release resources.
    /// TLS connections perform close_notify alert before closing.
    /// For Unix sockets needing file cleanup, use closeWithCleanup() instead.
    pub fn close(self: *Connection) void {
        switch (self.*) {
            .plain => |sock| socket_mod.closeSocket(sock),
            .tls => |*conn| conn.close(),
            .unix_socket => |unix_conn| socket_mod.closeSocket(unix_conn.socket),
        }
    }

    /// Close connection and remove Unix socket files if path is tracked.
    /// File removal errors are logged but don't prevent socket closure.
    pub fn closeWithCleanup(self: *Connection) void {
        switch (self.*) {
            .plain => |sock| socket_mod.closeSocket(sock),
            .tls => |*conn| conn.close(),
            .unix_socket => |unix_conn| {
                // Close the socket first
                socket_mod.closeSocket(unix_conn.socket);

                // Clean up socket file if path is tracked
                if (unix_conn.path) |path| {
                    std.fs.cwd().deleteFile(path) catch |err| {
                        logging.logDebug("Failed to remove Unix socket file '{s}': {any}\n", .{ path, err });
                    };
                }
            },
        }
    }

    /// Get underlying socket descriptor for operations like poll() or setsockopt().
    /// WARNING: Do not read/write directly on TLS connection sockets.
    pub fn getSocket(self: *Connection) socket_mod.Socket {
        return switch (self.*) {
            .plain => |sock| sock,
            .tls => |*conn| switch (conn.backend) {
                .openssl => |openssl_tls| openssl_tls.socket,
                .disabled => unreachable,
            },
            .unix_socket => |unix_conn| unix_conn.socket,
        };
    }

    /// Create plain TCP connection from existing socket.
    /// Connection takes ownership of socket.
    pub fn fromSocket(sock: socket_mod.Socket) Connection {
        return .{ .plain = sock };
    }

    /// Create TLS connection from established handshake.
    /// Connection takes ownership of TLS connection and underlying socket.
    pub fn fromTls(conn: tls.TlsConnection) Connection {
        return .{ .tls = conn };
    }

    /// Create Unix domain socket connection from existing socket.
    /// Path parameter enables file cleanup via closeWithCleanup().
    pub fn fromUnixSocket(sock: socket_mod.Socket, path: ?[]const u8) Connection {
        return .{ .unix_socket = .{ .socket = sock, .path = path } };
    }

    /// Returns true if connection uses TLS encryption.
    pub fn isTls(self: *const Connection) bool {
        return switch (self.*) {
            .plain => false,
            .tls => true,
            .unix_socket => false,
        };
    }

    /// Returns true if connection uses Unix domain sockets.
    pub fn isUnixSocket(self: *const Connection) bool {
        return switch (self.*) {
            .plain => false,
            .tls => false,
            .unix_socket => true,
        };
    }

    /// Returns the connection type enum value.
    pub fn getType(self: *const Connection) ConnectionType {
        return switch (self.*) {
            .plain => .tcp_plain,
            .tls => .tcp_tls,
            .unix_socket => .unix_socket,
        };
    }
};
</file>

<file path="net/sctp.zig">
const std = @import("std");
const net = @import("socket.zig");
const posix = std.posix;

pub fn openSctpClient(host: []const u8, port: u16, timeout: i32) !net.Socket {
    const family = net.detectAddressFamily(host);
    const sock = try net.createSctpSocket(family);
    errdefer net.closeSocket(sock);

    try net.setNonBlocking(sock);

    const address = try std.net.resolveIp(host, port);
    _ = posix.connect(sock, &address.any, address.getOsSocklen()) catch |err| {
        if (err == error.InProgress) {
            // Wait for connection with timeout
            const pollfd = posix.pollfd{
                .fd = sock,
                .events = posix.POLL.OUT,
                .revents = 0,
            };

            const ready = try posix.poll(&[_]posix.pollfd{pollfd}, timeout);
            if (ready == 0) {
                return error.ConnectionTimedOut;
            }

            // Check for connection error
            var so_error: c_int = 0;
            var len = @sizeOf(@TypeOf(so_error));
            try posix.getsockopt(sock, posix.SOL.SOCKET, posix.SO.ERROR, std.mem.asBytes(&so_error), &len);

            if (so_error != 0) {
                return std.os.unexpectedErrno(so_error);
            }
        } else {
            return err;
        }
    };

    return sock;
}

pub fn openSctpServer(bind_addr_str: []const u8, port: u16) !net.Socket {
    const family = net.detectAddressFamily(bind_addr_str);
    const sock = try net.createSctpSocket(family);
    errdefer net.closeSocket(sock);

    try net.setReuseAddr(sock);
    try net.setReusePort(sock);

    const bind_addr = try std.net.resolveIp(bind_addr_str, port);
    try posix.bind(sock, &bind_addr.any, bind_addr.getOsSocklen());

    try posix.listen(sock, 128);

    return sock;
}
</file>

<file path="net/socket.zig">
//! Cross-platform socket abstraction layer for Zigcat.
//!
//! This module provides a unified interface for socket operations across Windows and Unix platforms,
//! handling critical platform differences:
//!
//! ## Platform Differences
//!
//! ### Socket Types
//! - **Windows**: Socket is `std.os.windows.ws2_32.SOCKET` (usize)
//! - **Unix/POSIX**: Socket is `posix.socket_t` (i32)
//!
//! ### Initialization
//! - **Windows**: Requires `WSAStartup()` before any socket operations, cleanup with `WSACleanup()`
//! - **Unix/POSIX**: No initialization required, sockets available immediately
//!
//! ### Non-blocking Mode
//! - **Windows**: Uses `ioctlsocket()` with `FIONBIO` flag
//! - **Unix/POSIX**: Uses `fcntl()` with `O_NONBLOCK` flag
//!
//! ### Socket Closure
//! - **Windows**: Uses `closesocket()` from WinSock API
//! - **Unix/POSIX**: Uses standard `close()` POSIX call
//!
//! ## Usage Pattern
//!
//! ```zig
//! // Initialize platform networking (Windows only, no-op on Unix)
//! try socket.initPlatform();
//! defer socket.deinitPlatform();
//!
//! // Create and configure socket
//! const sock = try socket.createTcpSocket(.ipv4);
//! defer socket.closeSocket(sock);
//!
//! try socket.setReuseAddr(sock);
//! try socket.setNonBlocking(sock);
//! ```
//!
//! ## Memory Safety
//! All socket operations use `errdefer` cleanup patterns. Callers must ensure sockets are closed
//! either explicitly via `closeSocket()` or through `defer` statements.

const std = @import("std");
const builtin = @import("builtin");
const posix = std.posix;
const logging = @import("../util/logging.zig");

/// Platform-specific socket type.
/// Windows uses SOCKET (usize), Unix uses socket_t (i32).
pub const Socket = if (builtin.os.tag == .windows) std.os.windows.ws2_32.SOCKET else posix.socket_t;

/// Initialize platform-specific networking subsystem.
///
/// **Windows**: Calls `WSAStartup()` to initialize WinSock 2.2 library.
/// **Unix/POSIX**: No-op, returns immediately without error.
///
/// ## Requirements
/// - Must be called before any socket operations on Windows
/// - Must be paired with `deinitPlatform()` cleanup
/// - Safe to call multiple times (WSAStartup is reference-counted on Windows)
///
/// ## Errors
/// - `error.WSAStartupFailed`: Windows failed to initialize WinSock library
///
/// ## Example
/// ```zig
/// try socket.initPlatform();
/// defer socket.deinitPlatform();
/// ```
pub fn initPlatform() !void {
    if (builtin.os.tag == .windows) {
        const windows = std.os.windows;
        var wsa_data: windows.ws2_32.WSADATA = undefined;
        const result = windows.ws2_32.WSAStartup(0x0202, &wsa_data);
        if (result != 0) {
            return error.WSAStartupFailed;
        }
    }
}

/// Cleanup platform-specific networking subsystem.
///
/// **Windows**: Calls `WSACleanup()` to decrement WinSock reference count.
/// **Unix/POSIX**: No-op, returns immediately.
///
/// ## Requirements
/// - Should be called after all sockets are closed
/// - Must be paired with `initPlatform()` initialization
/// - Safe to call even if init failed (no-op on Unix, decrements on Windows)
///
/// ## Platform Notes
/// On Windows, WSACleanup is reference-counted, so each WSAStartup must have
/// a matching WSACleanup call.
pub fn deinitPlatform() void {
    if (builtin.os.tag == .windows) {
        _ = std.os.windows.ws2_32.WSACleanup();
    }
}

/// Create a TCP socket with specified address family.
///
/// ## Parameters
/// - `family`: Address family (.ipv4 or .ipv6)
///
/// ## Returns
/// Platform-specific socket descriptor (usize on Windows, i32 on Unix)
///
/// ## Errors
/// - `error.AddressFamilyNotSupported`: System doesn't support the requested address family
/// - `error.ProtocolFamilyNotAvailable`: TCP protocol not available
/// - `error.SystemResources`: Out of file descriptors or memory
/// - Other POSIX socket creation errors
///
/// ## Memory Safety
/// Caller must ensure socket is closed via `closeSocket()` or use `defer`/`errdefer`.
///
/// ## Example
/// ```zig
/// const sock = try createTcpSocket(.ipv4);
/// errdefer closeSocket(sock);
/// ```
pub fn createTcpSocket(family: AddressFamily) !Socket {
    const af: u32 = switch (family) {
        .ipv4 => posix.AF.INET,
        .ipv6 => posix.AF.INET6,
    };

    return posix.socket(
        af,
        posix.SOCK.STREAM,
        posix.IPPROTO.TCP,
    ) catch |err| {
        logging.logDebug("Failed to create TCP socket: {any}\n", .{err});
        return err;
    };
}

/// Create a UDP socket with specified address family.
///
/// ## Parameters
/// - `family`: Address family (.ipv4 or .ipv6)
///
/// ## Returns
/// Platform-specific socket descriptor (usize on Windows, i32 on Unix)
///
/// ## Errors
/// - `error.AddressFamilyNotSupported`: System doesn't support the requested address family
/// - `error.ProtocolFamilyNotAvailable`: UDP protocol not available
/// - `error.SystemResources`: Out of file descriptors or memory
/// - Other POSIX socket creation errors
///
/// ## Memory Safety
/// Caller must ensure socket is closed via `closeSocket()` or use `defer`/`errdefer`.
///
/// ## Example
/// ```zig
/// const sock = try createUdpSocket(.ipv4);
/// errdefer closeSocket(sock);
/// ```
pub fn createUdpSocket(family: AddressFamily) !Socket {
    const af: u32 = switch (family) {
        .ipv4 => posix.AF.INET,
        .ipv6 => posix.AF.INET6,
    };

    return posix.socket(
        af,
        posix.SOCK.DGRAM,
        posix.IPPROTO.UDP,
    ) catch |err| {
        logging.logDebug("Failed to create UDP socket: {any}\n", .{err});
        return err;
    };
}

/// Create an SCTP socket with specified address family.
///
/// ## Parameters
/// - `family`: Address family (.ipv4 or .ipv6)
///
/// ## Returns
/// Platform-specific socket descriptor (usize on Windows, i32 on Unix)
///
/// ## Errors
/// - `error.SctpNotSupported`: SCTP is not supported on this platform
/// - `error.AddressFamilyNotSupported`: System doesn't support the requested address family
/// - `error.ProtocolFamilyNotAvailable`: SCTP protocol not available
/// - `error.SystemResources`: Out of file descriptors or memory
/// - Other POSIX socket creation errors
///
/// ## Platform Support
/// - **Linux**: Supported
/// - **FreeBSD**: Supported
/// - **macOS**: Deprecated, may not be available
/// - **Windows**: Not supported
pub fn createSctpSocket(family: AddressFamily) !Socket {
    if (builtin.os.tag != .linux and builtin.os.tag != .freebsd and builtin.os.tag != .macos) {
        return error.SctpNotSupported;
    }

    const af: u32 = switch (family) {
        .ipv4 => posix.AF.INET,
        .ipv6 => posix.AF.INET6,
    };

    const IPPROTO_SCTP = 132;

    return posix.socket(
        af,
        posix.SOCK.SEQPACKET,
        IPPROTO_SCTP,
    ) catch |err| {
        logging.logDebug("Failed to create SCTP socket: {any}\n", .{err});
        if (err == error.ProtocolNotSupported) {
            return error.SctpNotSupported;
        }
        return err;
    };
}

/// Enable SO_REUSEADDR socket option.
///
/// Allows binding to an address that is in TIME_WAIT state, useful for server restart scenarios.
///
/// ## Parameters
/// - `sock`: Socket descriptor to configure
///
/// ## Errors
/// - `error.PermissionDenied`: Insufficient privileges to set option
/// - `error.InvalidArgument`: Invalid socket or option value
/// - Other POSIX setsockopt errors
///
/// ## Platform Behavior
/// - **Unix**: Allows immediate rebind of address in TIME_WAIT
/// - **Windows**: Similar behavior, allows address reuse
///
/// ## Example
/// ```zig
/// const sock = try createTcpSocket(.ipv4);
/// try setReuseAddr(sock);  // Allow quick server restart
/// ```
pub fn setReuseAddr(sock: Socket) !void {
    const enable: c_int = 1;
    try posix.setsockopt(
        sock,
        posix.SOL.SOCKET,
        posix.SO.REUSEADDR,
        std.mem.asBytes(&enable),
    );
}

/// Enable SO_REUSEPORT socket option (platform-specific, optional).
///
/// Allows multiple sockets to bind to the same port for load balancing.
/// This is an OPTIONAL operation that fails gracefully on unsupported platforms.
///
/// ## Parameters
/// - `sock`: Socket descriptor to configure
///
/// ## Platform Support
/// - **Linux**: Supported (SO_REUSEPORT = 15), enables kernel load balancing
/// - **macOS**: Supported (SO_REUSEPORT = 0x0200)
/// - **Windows**: Not supported, function returns without error
/// - **Other Unix**: May not be available, logs warning and continues
///
/// ## Errors
/// This function does NOT propagate errors. If SO_REUSEPORT is unavailable,
/// a warning is printed to stderr and execution continues.
///
/// ## Use Case
/// Primarily for server applications that want to run multiple instances
/// on the same port with kernel-level load balancing.
pub fn setReusePort(sock: Socket) !void {
    if (builtin.os.tag == .linux or builtin.os.tag == .macos) {
        const enable: c_int = 1;
        const SO_REUSEPORT = if (builtin.os.tag == .linux) 15 else 0x0200;
        posix.setsockopt(
            sock,
            posix.SOL.SOCKET,
            @intCast(SO_REUSEPORT),
            std.mem.asBytes(&enable),
        ) catch |err| {
            // SO_REUSEPORT is optional, don't fail if not available
            logging.logDebug("Warning: SO_REUSEPORT not available: {any}\n", .{err});
        };
    }
}

/// Set socket to non-blocking mode.
///
/// CRITICAL for timeout-aware I/O operations. Non-blocking sockets return immediately
/// from read/write operations instead of blocking indefinitely.
///
/// ## Parameters
/// - `sock`: Socket descriptor to configure
///
/// ## Errors
/// - **Windows**: `error.IoctlFailed` if `ioctlsocket()` fails
/// - **Unix**: POSIX fcntl errors (PermissionDenied, InvalidArgument, etc.)
///
/// ## Platform Implementation
/// - **Windows**: Uses `ioctlsocket()` with `FIONBIO` flag
/// - **Unix**: Uses `fcntl(F_GETFL)` to read flags, then `fcntl(F_SETFL)` with `O_NONBLOCK (0x0004)`
///
/// ## Usage Pattern
/// Non-blocking mode is MANDATORY for all timeout-aware operations. After setting,
/// operations must use `std.posix.poll()` to wait for readiness with timeout.
///
/// ## Example
/// ```zig
/// const sock = try createTcpSocket(.ipv4);
/// try setNonBlocking(sock);  // Required for timeout enforcement
///
/// // Now use with poll() for timeout control
/// var pollfds = [_]posix.pollfd{.{ .fd = sock, .events = POLL.OUT, .revents = 0 }};
/// const ready = try posix.poll(&pollfds, timeout_ms);
/// ```
///
/// See `/docs/TIMEOUT_SAFETY.md` for complete timeout patterns.
pub fn setNonBlocking(sock: Socket) !void {
    if (builtin.os.tag == .windows) {
        var mode: c_ulong = 1;
        const result = std.os.windows.ws2_32.ioctlsocket(sock, std.os.windows.ws2_32.FIONBIO, &mode);
        if (result != 0) return error.IoctlFailed;
    } else {
        const flags = try posix.fcntl(sock, posix.F.GETFL, 0);
        const NONBLOCK: u32 = 0x0004; // O_NONBLOCK on most Unix systems
        _ = try posix.fcntl(sock, posix.F.SETFL, flags | NONBLOCK);
    }
}

/// Close a socket and release system resources.
///
/// This function handles platform-specific socket cleanup. Always use this instead
/// of direct `close()` calls for cross-platform compatibility.
///
/// ## Parameters
/// - `sock`: Socket descriptor to close
///
/// ## Platform Implementation
/// - **Windows**: Uses `closesocket()` from WinSock API
/// - **Unix/POSIX**: Uses standard `close()` system call
///
/// ## Memory Safety
/// - Safe to call multiple times on the same socket (close is idempotent on most platforms)
/// - Does NOT return errors (failures are silently ignored)
/// - Should be called in `defer` or `errdefer` blocks for automatic cleanup
///
/// ## Example
/// ```zig
/// const sock = try createTcpSocket(.ipv4);
/// defer closeSocket(sock);  // Automatic cleanup
/// ```
pub fn closeSocket(sock: Socket) void {
    if (builtin.os.tag == .windows) {
        _ = std.os.windows.ws2_32.closesocket(sock);
    } else {
        posix.close(sock);
    }
}

/// Address family enumeration for socket creation.
pub const AddressFamily = enum {
    /// IPv4 address family (AF_INET)
    ipv4,
    /// IPv6 address family (AF_INET6)
    ipv6,
};

/// Detect address family from hostname or IP address string.
///
/// Uses simple heuristic: presence of ':' indicates IPv6, otherwise IPv4.
///
/// ## Parameters
/// - `host`: Hostname or IP address string
///
/// ## Returns
/// - `.ipv6` if string contains ':' (e.g., "::1", "2001:db8::1")
/// - `.ipv4` otherwise (e.g., "127.0.0.1", "example.com")
///
/// ## Limitations
/// This is a HEURISTIC, not a validator. It does not:
/// - Validate IP address format
/// - Resolve hostnames
/// - Handle IPv6 addresses with port notation (e.g., "[::1]:8080")
///
/// ## Example
/// ```zig
/// const family = detectAddressFamily("192.168.1.1");  // .ipv4
/// const family6 = detectAddressFamily("::1");         // .ipv6
/// ```
pub fn detectAddressFamily(host: []const u8) AddressFamily {
    // Simple heuristic: if it contains ':', assume IPv6
    if (std.mem.indexOf(u8, host, ":")) |_| {
        return .ipv6;
    }
    return .ipv4;
}
</file>

<file path="net/tcp.zig">
//! TCP connection utilities with timeout-aware I/O.
//!
//! This module provides TCP client and server functionality with:
//! - Non-blocking connect with poll() timeout
//! - Address family detection (IPv4/IPv6)
//! - Multiple address fallback (tries all resolved addresses)
//! - SO_ERROR checking after poll() (critical for connection validation)
//! - TLS wrapper functions for encrypted connections
//!
//! Timeout safety:
//! - All connect operations use non-blocking sockets
//! - poll() enforces timeout in milliseconds
//! - SO_ERROR checked after poll returns to detect async connection failures
//! - See TIMEOUT_SAFETY.md for complete timeout patterns
//!
//! Critical pattern (from CLAUDE.md):
//! ```zig
//! socket.setNonBlocking(sock);
//! const result = posix.connect(sock, &addr, len);
//! // Handle WouldBlock/InProgress
//! const ready = try poll_wrapper.poll(&pollfds, timeout_ms);
//! if (ready == 0) return error.ConnectionTimeout;
//! // CRITICAL: Check SO_ERROR after poll
//! ```

const std = @import("std");
const posix = std.posix;
const socket = @import("socket.zig");
const tls_mod = @import("../tls/tls.zig");
const TlsConfig = tls_mod.TlsConfig;
const poll_wrapper = @import("../util/poll_wrapper.zig");
const TlsConnection = tls_mod.TlsConnection;
const proxy = @import("proxy/mod.zig");
const config = @import("../config.zig");
const logging = @import("../util/logging.zig");

/// Open a TCP connection to host:port with timeout.
///
/// Implements robust connection logic:
/// 1. Resolve hostname to list of addresses (IPv4/IPv6)
/// 2. Try each address in order until one succeeds
/// 3. For each attempt:
///    a. Create non-blocking socket
///    b. Initiate connect (expect WouldBlock/InProgress)
///    c. Poll with timeout for writability
///    d. Check SO_ERROR to verify connection success
///
/// Timeout enforcement:
/// - Uses poll() with timeout_ms for each connection attempt
/// - Returns ConnectionTimeout if poll times out
/// - Tries next address on timeout or connection error
///
/// Address family handling:
/// - Automatically detects IPv4 vs IPv6 from resolved addresses
/// - Creates appropriate socket type for each address
///
/// Parameters:
///   host: Hostname or IP address to connect to
///   port: TCP port number
///   timeout_ms: Connect timeout in milliseconds
///
/// Returns: Connected socket or error (UnknownHost, ConnectionTimeout, ConnectionFailed)
pub fn openTcpClient(host: []const u8, port: u16, timeout_ms: u32) !socket.Socket {
    // Resolve addresses first
    const addr_list = try std.net.getAddressList(
        std.heap.page_allocator,
        host,
        port,
    );
    defer addr_list.deinit();

    if (addr_list.addrs.len == 0) {
        return error.UnknownHost;
    }

    var last_error: ?anyerror = null;
    for (addr_list.addrs) |addr| {
        // Create a fresh socket for each address attempt
        const family = if (addr.any.family == posix.AF.INET)
            socket.AddressFamily.ipv4
        else
            socket.AddressFamily.ipv6;

        const sock = socket.createTcpSocket(family) catch |err| {
            last_error = err;
            continue;
        };
        errdefer socket.closeSocket(sock);

        // Set non-blocking for timeout support
        socket.setNonBlocking(sock) catch |err| {
            socket.closeSocket(sock);
            last_error = err;
            continue;
        };

        const result = posix.connect(sock, &addr.any, addr.getOsSockLen());

        if (result) {
            // Connected immediately
            return sock;
        } else |err| {
            if (err == error.WouldBlock or err == error.InProgress) {
                // Wait for connection with timeout
                if (try waitForConnect(sock, timeout_ms)) {
                    return sock;
                }
                socket.closeSocket(sock);
                last_error = error.ConnectionTimeout;
            } else {
                socket.closeSocket(sock);
                last_error = err;
            }
        }
    }

    return last_error orelse error.ConnectionFailed;
}

/// Wait for socket to become writable (connected) with timeout.
///
/// CRITICAL: This function implements the mandatory poll() + SO_ERROR pattern
/// for reliable non-blocking connect. From CLAUDE.md:
/// "Check SO_ERROR after poll (connection can fail even if poll returns ready)"
///
/// Process:
/// 1. Poll socket for writability (POLL.OUT event)
/// 2. If poll returns 0, connection timed out
/// 3. If poll returns ready, check SO_ERROR to verify success
/// 4. Return true only if SO_ERROR == 0 (connection succeeded)
///
/// Why SO_ERROR check is critical:
/// - poll() may return ready even if async connect failed
/// - SO_ERROR contains the actual connection result
/// - Skipping this check causes silent connection failures
///
/// Parameters:
///   sock: Non-blocking socket with connect() in progress
///   timeout_ms: Timeout in milliseconds for poll()
///
/// Returns: true if connected, false if timed out, error on poll failure
fn waitForConnect(sock: socket.Socket, timeout_ms: u32) !bool {
    var pollfds = [_]poll_wrapper.pollfd{.{
        .fd = sock,
        .events = poll_wrapper.POLL.OUT,
        .revents = 0,
    }};

    const ready = try poll_wrapper.poll(&pollfds, @intCast(timeout_ms));
    if (ready == 0) return false; // Timeout

    // Check if connection succeeded
    var err: i32 = undefined;
    const len: posix.socklen_t = @sizeOf(i32);
    try posix.getsockopt(sock, posix.SOL.SOCKET, posix.SO.ERROR, std.mem.asBytes(&err)[0..len]);

    return err == 0;
}

/// Create a TCP listening socket with SO_REUSEADDR and SO_REUSEPORT.
///
/// Server socket creation:
/// 1. Detect address family from bind address string
/// 2. Create TCP socket for detected family
/// 3. Set SO_REUSEADDR for quick restart after close
/// 4. Set SO_REUSEPORT for multi-process binding (Unix)
/// 5. Bind to specified address and port
/// 6. Listen with backlog of 128 connections
///
/// Address family detection:
/// - Automatically handles IPv4, IPv6, or wildcard (0.0.0.0/::)
/// - Uses socket.detectAddressFamily() helper
///
/// Parameters:
///   bind_addr: Address to bind to (e.g., "0.0.0.0", "::", "192.168.1.1")
///   port: TCP port number to listen on
///
/// Returns: Listening socket ready for accept() calls
pub fn openTcpListener(bind_addr: []const u8, port: u16) !socket.Socket {
    const family = socket.detectAddressFamily(bind_addr);
    const sock = try socket.createTcpSocket(family);
    errdefer socket.closeSocket(sock);

    try socket.setReuseAddr(sock);
    try socket.setReusePort(sock);

    // Parse bind address
    const addr = try std.net.Address.parseIp(bind_addr, port);

    // Bind
    try posix.bind(sock, &addr.any, addr.getOsSockLen());

    // Listen
    try posix.listen(sock, 128);

    return sock;
}

/// Accept a connection from a listening socket with optional timeout.
///
/// Implements timeout-aware accept using poll():
/// - If timeout_ms > 0: poll first, then accept
/// - If timeout_ms == 0: blocking accept (no timeout)
///
/// Timeout enforcement:
/// - poll() waits for incoming connection (POLL.IN event)
/// - Returns Timeout error if poll times out
/// - Only calls accept() after poll confirms connection available
///
/// Parameters:
///   listener: Listening socket from openTcpListener()
///   timeout_ms: Accept timeout in milliseconds (0 = no timeout)
///
/// Returns: Connected client socket or Timeout error
pub fn acceptConnection(listener: socket.Socket, timeout_ms: u32) !socket.Socket {
    if (timeout_ms > 0) {
        var pollfds = [_]poll_wrapper.pollfd{.{
            .fd = listener,
            .events = poll_wrapper.POLL.IN,
            .revents = 0,
        }};

        const ready = try poll_wrapper.poll(&pollfds, @intCast(timeout_ms));
        if (ready == 0) return error.Timeout;
    }

    var addr: posix.sockaddr = undefined;
    var addr_len: posix.socklen_t = @sizeOf(posix.sockaddr);

    return posix.accept(listener, &addr, &addr_len, 0) catch |err| {
        logging.logDebug("Accept failed: {any}\n", .{err});
        return err;
    };
}

/// Connect to a TLS server
pub fn connectTls(
    allocator: std.mem.Allocator,
    host: []const u8,
    port: u16,
    timeout_ms: u32,
    tls_config: TlsConfig,
) !TlsConnection {
    // First establish TCP connection
    const sock = try openTcpClient(host, port, timeout_ms);
    errdefer socket.closeSocket(sock);

    // Wrap with TLS
    return tls_mod.connectTls(allocator, sock, tls_config) catch |err| {
        socket.closeSocket(sock);
        return err;
    };
}

/// Accept a TLS connection
pub fn acceptTls(
    allocator: std.mem.Allocator,
    listener: socket.Socket,
    timeout_ms: u32,
    tls_config: TlsConfig,
) !TlsConnection {
    // Accept TCP connection
    const sock = try acceptConnection(listener, timeout_ms);
    errdefer socket.closeSocket(sock);

    // Wrap with TLS
    return tls_mod.acceptTls(allocator, sock, tls_config) catch |err| {
        socket.closeSocket(sock);
        return err;
    };
}

/// Open a TCP connection through a proxy
pub fn openTcpClientWithProxy(
    allocator: std.mem.Allocator,
    cfg: *const config.Config,
    host: []const u8,
    port: u16,
) !socket.Socket {
    return try proxy.connectThroughProxy(allocator, cfg, host, port);
}

/// Open a TCP connection with specific source port (--keep-source-port flag).
///
/// This function binds to a specific source port before connecting, ensuring
/// the client uses the requested port for outgoing connections. This is useful
/// for firewall rules, port-based authentication, or debugging.
///
/// Implementation:
/// 1. Create non-blocking socket
/// 2. Bind to source port (0.0.0.0:source_port or :::source_port)
/// 3. Connect to target with timeout
/// 4. Check SO_ERROR after poll
///
/// Note: Binding to a specific source port may fail if:
/// - Port is already in use
/// - Port is privileged (<1024) and process lacks permissions
/// - Multiple connections share the same source port (without SO_REUSEADDR)
///
/// Parameters:
///   host: Target hostname or IP address
///   port: Target TCP port
///   timeout_ms: Connect timeout in milliseconds
///   source_port: Source port to bind to (0 = auto-assign)
///
/// Returns: Connected socket or error
pub fn openTcpClientWithSourcePort(
    host: []const u8,
    port: u16,
    timeout_ms: u32,
    source_port: u16,
) !socket.Socket {
    // Resolve target addresses first
    const addr_list = try std.net.getAddressList(
        std.heap.page_allocator,
        host,
        port,
    );
    defer addr_list.deinit();

    if (addr_list.addrs.len == 0) {
        return error.UnknownHost;
    }

    var last_error: ?anyerror = null;
    for (addr_list.addrs) |addr| {
        // Create socket matching target address family
        const family = if (addr.any.family == posix.AF.INET)
            socket.AddressFamily.ipv4
        else
            socket.AddressFamily.ipv6;

        const sock = socket.createTcpSocket(family) catch |err| {
            last_error = err;
            continue;
        };
        errdefer socket.closeSocket(sock);

        // Enable SO_REUSEADDR to allow quick rebinding
        socket.setReuseAddr(sock) catch |err| {
            socket.closeSocket(sock);
            last_error = err;
            continue;
        };

        // Bind to specific source port
        const bind_addr = if (family == socket.AddressFamily.ipv4)
            try std.net.Address.parseIp("0.0.0.0", source_port)
        else
            try std.net.Address.parseIp("::", source_port);

        posix.bind(sock, &bind_addr.any, bind_addr.getOsSockLen()) catch |err| {
            socket.closeSocket(sock);
            last_error = err;
            continue;
        };

        // Set non-blocking for timeout support
        socket.setNonBlocking(sock) catch |err| {
            socket.closeSocket(sock);
            last_error = err;
            continue;
        };

        const result = posix.connect(sock, &addr.any, addr.getOsSockLen());

        if (result) {
            // Connected immediately
            return sock;
        } else |err| {
            if (err == error.WouldBlock or err == error.InProgress) {
                // Wait for connection with timeout
                if (try waitForConnect(sock, timeout_ms)) {
                    return sock;
                }
                socket.closeSocket(sock);
                last_error = error.ConnectionTimeout;
            } else {
                socket.closeSocket(sock);
                last_error = err;
            }
        }
    }

    return last_error orelse error.ConnectionFailed;
}
</file>

<file path="net/udp.zig">
//! UDP socket operations for Zigcat.
//!
//! This module provides UDP (User Datagram Protocol) socket functionality for both
//! client and server modes. UDP is a connectionless protocol, so "connections" are
//! virtual associations that set default destination addresses.
//!
//! ## UDP vs TCP
//!
//! - **Connectionless**: No handshake, packets sent independently
//! - **Unreliable**: No delivery guarantees, packets may be lost, duplicated, or reordered
//! - **Message-oriented**: Preserves message boundaries (unlike TCP's byte stream)
//! - **Lower overhead**: No connection state, minimal header overhead
//!
//! ## Client Mode
//!
//! UDP "client connections" use `connect()` to associate a default destination:
//! ```zig
//! const sock = try openUdpClient("example.com", 8080);
//! defer socket.closeSocket(sock);
//! _ = try sendUdp(sock, "hello");  // Sent to example.com:8080
//! ```
//!
//! ## Server Mode
//!
//! UDP servers bind to a local address and receive from any source:
//! ```zig
//! const sock = try openUdpServer("0.0.0.0", 8080);
//! defer socket.closeSocket(sock);
//! var buf: [1024]u8 = undefined;
//! const result = try recvFromUdp(sock, &buf);  // result.addr has sender info
//! ```
//!
//! ## Memory Safety
//! All UDP operations return socket descriptors that must be closed via `socket.closeSocket()`.

const std = @import("std");
const posix = std.posix;
const socket = @import("socket.zig");
const logging = @import("../util/logging.zig");

/// Open a UDP "connection" by creating socket and associating with remote address.
///
/// UDP is connectionless, but calling `connect()` on a UDP socket sets the default
/// destination address for `send()` operations and filters incoming packets.
///
/// ## Parameters
/// - `host`: Remote hostname or IP address
/// - `port`: Remote port number
///
/// ## Returns
/// Socket descriptor associated with the remote endpoint
///
/// ## Errors
/// - `error.UnknownHost`: DNS resolution failed for hostname
/// - Socket creation errors (see `socket.createUdpSocket()`)
/// - `error.ConnectionRefused`: ICMP port unreachable received (rare for UDP)
///
/// ## Memory Safety
/// Caller must close socket via `socket.closeSocket()` or use `defer`/`errdefer`.
///
/// ## Example
/// ```zig
/// const sock = try openUdpClient("dns.google", 53);
/// defer socket.closeSocket(sock);
/// ```
pub fn openUdpClient(host: []const u8, port: u16) !socket.Socket {
    const family = socket.detectAddressFamily(host);
    const sock = try socket.createUdpSocket(family);
    errdefer socket.closeSocket(sock);

    // For UDP client, we "connect" to set the default destination
    const addr_list = try std.net.getAddressList(
        std.heap.page_allocator,
        host,
        port,
    );
    defer addr_list.deinit();

    if (addr_list.addrs.len == 0) {
        return error.UnknownHost;
    }

    // Connect UDP socket (sets default destination)
    try posix.connect(sock, &addr_list.addrs[0].any, addr_list.addrs[0].getOsSockLen());

    return sock;
}

/// Create a UDP server socket bound to local address.
///
/// Creates, configures, and binds a UDP socket for receiving datagrams.
/// Automatically enables SO_REUSEADDR and SO_REUSEPORT for server scenarios.
///
/// ## Parameters
/// - `bind_addr`: Local IP address to bind (use "0.0.0.0" for all IPv4 interfaces, "::" for IPv6)
/// - `port`: Local port number
///
/// ## Returns
/// Socket descriptor bound and ready to receive datagrams
///
/// ## Errors
/// - `error.AddressInUse`: Port already in use (even with SO_REUSEADDR)
/// - `error.AddressNotAvailable`: Invalid bind address for this system
/// - `error.PermissionDenied`: Insufficient privileges (ports < 1024 require root)
/// - Socket creation errors (see `socket.createUdpSocket()`)
///
/// ## Socket Configuration
/// - SO_REUSEADDR: Enabled (allows quick restart)
/// - SO_REUSEPORT: Enabled if platform supports (allows multiple servers on same port)
///
/// ## Memory Safety
/// Caller must close socket via `socket.closeSocket()` or use `defer`/`errdefer`.
///
/// ## Example
/// ```zig
/// const sock = try openUdpServer("0.0.0.0", 8080);
/// defer socket.closeSocket(sock);
/// ```
pub fn openUdpServer(bind_addr: []const u8, port: u16) !socket.Socket {
    const family = socket.detectAddressFamily(bind_addr);
    const sock = try socket.createUdpSocket(family);
    errdefer socket.closeSocket(sock);

    try socket.setReuseAddr(sock);
    try socket.setReusePort(sock);

    const addr = try std.net.Address.parseIp(bind_addr, port);
    try posix.bind(sock, &addr.any, addr.getOsSockLen());

    return sock;
}

/// Send data over connected UDP socket.
///
/// Sends datagram to the default destination set by `connect()` or `openUdpClient()`.
/// For unconnected sockets, use `sendToUdp()` instead.
///
/// ## Parameters
/// - `sock`: UDP socket (must be "connected" via connect() or openUdpClient())
/// - `data`: Data buffer to send
///
/// ## Returns
/// Number of bytes sent (may be less than data.len on some platforms)
///
/// ## Errors
/// - `error.WouldBlock`: Socket is non-blocking and send buffer is full
/// - `error.NetworkUnreachable`: No route to destination
/// - `error.MessageTooBig`: Datagram exceeds MTU (typically ~1500 bytes)
/// - Other POSIX send errors
///
/// ## UDP Delivery
/// - **No guarantees**: Packet may be lost, duplicated, or reordered
/// - **Atomic**: Entire datagram sent or none (no partial sends for UDP)
/// - **Size limits**: Practical limit ~1400 bytes to avoid IP fragmentation
///
/// ## Example
/// ```zig
/// const sock = try openUdpClient("example.com", 8080);
/// const sent = try sendUdp(sock, "hello");
/// ```
pub fn sendUdp(sock: socket.Socket, data: []const u8) !usize {
    return posix.send(sock, data, 0) catch |err| {
        logging.logDebug("UDP send failed: {any}\n", .{err});
        return err;
    };
}

/// Receive data from connected UDP socket.
///
/// Receives datagram from the associated remote endpoint (set by connect()).
/// For receiving from any source, use `recvFromUdp()` instead.
///
/// ## Parameters
/// - `sock`: UDP socket (should be "connected" via connect())
/// - `buffer`: Buffer to store received data
///
/// ## Returns
/// Number of bytes received (0 is valid for zero-length datagrams)
///
/// ## Errors
/// - `error.WouldBlock`: Socket is non-blocking and no data available
/// - `error.ConnectionRefused`: ICMP port unreachable received
/// - Other POSIX recv errors
///
/// ## UDP Message Boundaries
/// - **Preserves boundaries**: Each recv() returns exactly one complete datagram
/// - **Truncation**: If buffer too small, excess data is DISCARDED (MSG_TRUNC behavior)
/// - **Recommended**: Use buffers >= 1500 bytes to avoid truncation
///
/// ## Example
/// ```zig
/// var buf: [1500]u8 = undefined;
/// const received = try recvUdp(sock, &buf);
/// const data = buf[0..received];
/// ```
pub fn recvUdp(sock: socket.Socket, buffer: []u8) !usize {
    return posix.recv(sock, buffer, 0) catch |err| {
        logging.logDebug("UDP recv failed: {any}\n", .{err});
        return err;
    };
}

/// Receive data with source address information from any sender.
///
/// Used for server sockets to receive datagrams from any source and identify the sender.
/// Essential for UDP server reply logic.
///
/// ## Parameters
/// - `sock`: UDP socket (typically bound via `openUdpServer()`)
/// - `buffer`: Buffer to store received data
///
/// ## Returns
/// Anonymous struct containing:
/// - `bytes`: Number of bytes received
/// - `addr`: Source address (IP + port) of sender
///
/// ## Errors
/// - `error.WouldBlock`: Socket is non-blocking and no data available
/// - Other POSIX recvfrom errors
///
/// ## Usage Pattern
/// This is the standard server pattern for UDP request-response:
/// ```zig
/// const sock = try openUdpServer("0.0.0.0", 8080);
/// var buf: [1500]u8 = undefined;
/// const result = try recvFromUdp(sock, &buf);
/// const request = buf[0..result.bytes];
/// // Process request...
/// _ = try sendToUdp(sock, response, result.addr);  // Reply to sender
/// ```
///
/// ## Example
/// ```zig
/// var buf: [1500]u8 = undefined;
/// const result = try recvFromUdp(sock, &buf);
/// std.debug.print("Received {} bytes from {}\n", .{result.bytes, result.addr});
/// ```
pub fn recvFromUdp(sock: socket.Socket, buffer: []u8) !struct { bytes: usize, addr: std.net.Address } {
    var addr: posix.sockaddr = undefined;
    var addr_len: posix.socklen_t = @sizeOf(posix.sockaddr);

    const bytes = try posix.recvfrom(sock, buffer, 0, &addr, &addr_len);

    const net_addr = std.net.Address.initPosix(@alignCast(&addr));

    return .{ .bytes = bytes, .addr = net_addr };
}

/// Send data to specific address without "connecting" socket.
///
/// Used for server reply scenarios or client sockets that need to send to multiple destinations.
/// Can be used on any UDP socket, connected or not.
///
/// ## Parameters
/// - `sock`: UDP socket (any state)
/// - `data`: Data buffer to send
/// - `addr`: Destination address (IP + port)
///
/// ## Returns
/// Number of bytes sent (typically equals data.len for UDP)
///
/// ## Errors
/// - `error.WouldBlock`: Socket is non-blocking and send buffer is full
/// - `error.NetworkUnreachable`: No route to destination
/// - `error.MessageTooBig`: Datagram exceeds MTU
/// - Other POSIX sendto errors
///
/// ## Usage Pattern
/// Server reply scenario:
/// ```zig
/// const result = try recvFromUdp(sock, &buf);  // Get request + sender addr
/// const response = "ACK";
/// _ = try sendToUdp(sock, response, result.addr);  // Reply to sender
/// ```
///
/// ## Example
/// ```zig
/// const addr = try std.net.Address.parseIp("192.168.1.100", 8080);
/// const sent = try sendToUdp(sock, "hello", addr);
/// ```
pub fn sendToUdp(sock: socket.Socket, data: []const u8, addr: std.net.Address) !usize {
    return posix.sendto(sock, data, 0, &addr.any, addr.getOsSockLen()) catch |err| {
        logging.logDebug("UDP sendto failed: {any}\n", .{err});
        return err;
    };
}
</file>

<file path="net/unixsock.zig">
//! Unix Domain Sockets implementation for local inter-process communication.
//!
//! This module provides a unified interface for Unix socket operations by
//! re-exporting specialized client, server, and utility modules.
//!
//! Platform support: Linux, macOS, BSD variants (not Windows)
//!
//! ## Module Organization
//!
//! - `client.zig` - Client-side operations (connect)
//! - `server.zig` - Server-side operations (bind, listen, accept)
//! - `utils.zig` - Shared utilities (validation, error handling, cleanup)

const std = @import("std");
const client = @import("unixsock/client.zig");
const server = @import("unixsock/server.zig");
const utils = @import("unixsock/utils.zig");

// Re-export public types
pub const UnixSocket = struct {
    inner: union(enum) {
        client: client.UnixClient,
        server: server.UnixServer,
    },

    /// Initialize Unix socket client for connecting to existing socket.
    pub fn initClient(allocator: std.mem.Allocator, path: []const u8) !UnixSocket {
        return UnixSocket{
            .inner = .{ .client = try client.UnixClient.init(allocator, path) },
        };
    }

    /// Initialize Unix socket server. Creates parent directories and removes
    /// existing socket files as needed. Automatically starts listening.
    pub fn initServer(allocator: std.mem.Allocator, path: []const u8) !UnixSocket {
        return UnixSocket{
            .inner = .{ .server = try server.UnixServer.init(allocator, path) },
        };
    }

    /// Connect to Unix socket server (client mode only).
    pub fn connect(self: *UnixSocket) !void {
        switch (self.inner) {
            .client => |*c| try c.connect(),
            .server => return error.InvalidOperation,
        }
    }

    /// Accept incoming connection (server mode only).
    /// Returns new socket representing the client connection.
    pub fn accept(self: *UnixSocket) !UnixSocket {
        switch (self.inner) {
            .server => |*s| {
                const sock = try s.accept();
                return UnixSocket{
                    .inner = .{ .client = client.UnixClient{
                        .socket = sock,
                        .path = "",
                        .allocator = s.allocator,
                        .path_owned = false,
                    } },
                };
            },
            .client => return error.InvalidOperation,
        }
    }

    /// Close socket without removing socket file. Use cleanup() for servers.
    pub fn close(self: *UnixSocket) void {
        switch (self.inner) {
            .client => |*c| c.close(),
            .server => |*s| s.close(),
        }
    }

    /// Close socket and remove socket file (server mode) with comprehensive error handling.
    pub fn cleanup(self: *UnixSocket) void {
        switch (self.inner) {
            .server => |*s| s.cleanup(),
            .client => |*c| c.close(),
        }
    }

    /// Close socket and remove socket file with detailed error reporting.
    pub fn cleanupVerbose(self: *UnixSocket, force_cleanup: bool) void {
        switch (self.inner) {
            .server => |*s| s.cleanupVerbose(force_cleanup),
            .client => |*c| c.close(),
        }
    }

    pub fn setNonBlocking(self: *UnixSocket) !void {
        switch (self.inner) {
            .client => |*c| try c.setNonBlocking(),
            .server => |*s| try s.setNonBlocking(),
        }
    }

    pub fn getSocket(self: *const UnixSocket) @import("socket.zig").Socket {
        return switch (self.inner) {
            .client => |*c| c.getSocket(),
            .server => |*s| s.getSocket(),
        };
    }

    pub fn getPath(self: *const UnixSocket) []const u8 {
        return switch (self.inner) {
            .client => |*c| c.getPath(),
            .server => |*s| s.getPath(),
        };
    }

    pub fn isServer(self: *const UnixSocket) bool {
        return switch (self.inner) {
            .server => true,
            .client => false,
        };
    }
};

// Re-export utilities
pub const unix_socket_supported = utils.unix_socket_supported;
pub const UnixSocketError = utils.UnixSocketError;
pub const UnixAddress = utils.UnixAddress;
pub const validatePath = utils.validatePath;
pub const checkSupport = utils.checkSupport;
pub const handleSocketError = utils.handleSocketError;
pub const getErrorMessage = utils.getErrorMessage;
pub const handleUnixSocketError = utils.handleUnixSocketError;
pub const validateUnixSocketConfiguration = utils.validateUnixSocketConfiguration;
pub const createTempPath = utils.createTempPath;

// =============================================================================
// Comprehensive Error Handling Tests
// =============================================================================

const testing = std.testing;

test "Unix socket error mapping and messages" {
    // Test error message generation
    const path_msg = getErrorMessage(UnixSocketError.PathTooLong, "/test/path", "create");
    try testing.expect(path_msg.len > 0);

    const perm_msg = getErrorMessage(UnixSocketError.PermissionDenied, "/test/path", "connect");
    try testing.expect(perm_msg.len > 0);

    const platform_msg = getErrorMessage(UnixSocketError.PlatformNotSupported, "/test/path", "init");
    try testing.expect(platform_msg.len > 0);
}

test "Unix socket error handling" {
    // Test error handling function doesn't crash
    handleUnixSocketError(UnixSocketError.PathTooLong, "/test/path", "test", true);
    handleUnixSocketError(UnixSocketError.PermissionDenied, "/test/path", "test", false);
    handleUnixSocketError(UnixSocketError.PlatformNotSupported, "/test/path", "test", true);
}

test "Unix socket path validation comprehensive" {
    // Test empty path
    try testing.expectError(UnixSocketError.InvalidPath, validatePath(""));

    // Test path too long
    const long_path = "a" ** 110;
    try testing.expectError(UnixSocketError.PathTooLong, validatePath(long_path));

    // Test path with null bytes
    const null_path = "/tmp/test\x00socket";
    try testing.expectError(UnixSocketError.PathContainsNull, validatePath(null_path));

    // Test path with control characters
    const ctrl_path = "/tmp/test\x01socket";
    try testing.expectError(UnixSocketError.InvalidPathCharacters, validatePath(ctrl_path));

    // Test valid path (may fail if directory doesn't exist, but shouldn't crash)
    validatePath("/tmp/test.sock") catch {};
}

test "Unix socket configuration validation" {
    const config = @import("../config.zig");
    var cfg = config.Config.init(testing.allocator);
    defer cfg.deinit(testing.allocator);

    // Test valid configuration
    validateUnixSocketConfiguration("/tmp/test.sock", &cfg, false) catch {};

    // Test with verbose mode
    validateUnixSocketConfiguration("/tmp/test.sock", &cfg, true) catch {};

    // Test invalid path
    validateUnixSocketConfiguration("", &cfg, true) catch {};
}

test "Unix socket error recovery" {
    // Test socket error mapping
    const mapped_err = handleSocketError(error.AccessDenied, "test");
    try testing.expectEqual(UnixSocketError.PermissionDenied, mapped_err);

    const network_err = handleSocketError(error.ConnectionRefused, "test");
    try testing.expectEqual(UnixSocketError.ConnectionRefused, network_err);

    const resource_err = handleSocketError(error.SystemResources, "test");
    try testing.expectEqual(UnixSocketError.ResourceExhausted, resource_err);
}

test "Unix socket support detection" {
    const builtin = @import("builtin");
    // Test platform support detection
    const expected_support = switch (builtin.os.tag) {
        .linux, .macos, .freebsd, .openbsd, .netbsd, .dragonfly => true,
        else => false,
    };

    try testing.expectEqual(expected_support, unix_socket_supported);

    // Test support check function
    if (unix_socket_supported) {
        try checkSupport();
    } else {
        try testing.expectError(UnixSocketError.PlatformNotSupported, checkSupport());
    }
}
</file>

<file path="protocol/telnet_connection.zig">
//! TelnetConnection wrapper providing unified read/write interface with Telnet protocol processing.

const std = @import("std");
const Connection = @import("../net/connection.zig").Connection;
const TelnetProcessor = @import("telnet_processor.zig").TelnetProcessor;
const telnet = @import("telnet.zig");

const TelnetCommand = telnet.TelnetCommand;
const TelnetOption = telnet.TelnetOption;
const TelnetError = telnet.TelnetError;

/// Wraps an existing Connection with Telnet protocol processing.
pub const TelnetConnection = struct {
    inner: Connection,
    processor: TelnetProcessor,
    read_buffer: std.ArrayList(u8),
    write_buffer: std.ArrayList(u8),
    allocator: std.mem.Allocator,
    pending_data: std.ArrayList(u8),
    pending_response: std.ArrayList(u8),

    const BUFFER_SIZE = 4096;

    /// Initialize TelnetConnection from an existing Connection.
    /// Takes ownership of the connection.
    pub fn init(
        connection: Connection,
        allocator: std.mem.Allocator,
        terminal_type: ?[]const u8,
        window_width: ?u16,
        window_height: ?u16,
    ) !TelnetConnection {
        const term_type = terminal_type orelse "UNKNOWN";
        const width = window_width orelse 80;
        const height = window_height orelse 24;

        return TelnetConnection{
            .inner = connection,
            .processor = TelnetProcessor.init(allocator, term_type, width, height),
            .read_buffer = try std.ArrayList(u8).initCapacity(allocator, BUFFER_SIZE),
            .write_buffer = try std.ArrayList(u8).initCapacity(allocator, BUFFER_SIZE),
            .allocator = allocator,
            .pending_data = try std.ArrayList(u8).initCapacity(allocator, BUFFER_SIZE),
            .pending_response = try std.ArrayList(u8).initCapacity(allocator, BUFFER_SIZE),
        };
    }

    /// Clean up resources and close the underlying connection.
    pub fn deinit(self: *TelnetConnection) void {
        self.processor.deinit();
        self.read_buffer.deinit(self.allocator);
        self.write_buffer.deinit(self.allocator);
        self.pending_data.deinit(self.allocator);
        self.pending_response.deinit(self.allocator);
        self.inner.close();
    }

    /// Read application data, filtering out Telnet protocol sequences.
    /// Returns number of bytes read (0 indicates EOF).
    pub fn read(self: *TelnetConnection, buffer: []u8) !usize {
        // Return pending application data first
        if (self.pending_data.items.len > 0) {
            const bytes_to_copy = @min(buffer.len, self.pending_data.items.len);
            @memcpy(buffer[0..bytes_to_copy], self.pending_data.items[0..bytes_to_copy]);

            const remaining = self.pending_data.items[bytes_to_copy..];
            std.mem.copyForwards(u8, self.pending_data.items, remaining);
            self.pending_data.shrinkRetainingCapacity(remaining.len);

            return bytes_to_copy;
        }

        try self.flushPendingResponses();

        self.read_buffer.clearRetainingCapacity();
        try self.read_buffer.resize(self.allocator, BUFFER_SIZE);

        const bytes_read = try self.inner.read(self.read_buffer.items);
        if (bytes_read == 0) {
            return 0;
        }

        self.read_buffer.shrinkRetainingCapacity(bytes_read);

        const result = try self.processor.processInput(self.read_buffer.items);
        defer {
            self.allocator.free(result.data);
            self.allocator.free(result.response);
        }

        if (result.response.len > 0) {
            try self.pending_response.appendSlice(self.allocator, result.response);
        }

        if (result.data.len == 0) {
            // No application data - recursively read more
            return self.read(buffer);
        }
        const bytes_to_return = @min(buffer.len, result.data.len);
        @memcpy(buffer[0..bytes_to_return], result.data[0..bytes_to_return]);

        if (result.data.len > bytes_to_return) {
            try self.pending_data.appendSlice(self.allocator, result.data[bytes_to_return..]);
        }

        return bytes_to_return;
    }

    /// Write application data, escaping IAC bytes as needed.
    /// Returns number of application bytes written.
    pub fn write(self: *TelnetConnection, data: []const u8) !usize {
        try self.flushPendingResponses();

        const processed_data = try self.processor.processOutput(data, null);
        defer self.allocator.free(processed_data);

        const bytes_written = try self.inner.write(processed_data);

        // Calculate application bytes written (approximate due to IAC escaping)
        if (processed_data.len == 0) {
            return 0;
        }

        const app_bytes_written = (data.len * bytes_written) / processed_data.len;
        return @min(app_bytes_written, data.len);
    }

    /// Close the connection and release resources.
    pub fn close(self: *TelnetConnection) void {
        self.flushPendingResponses() catch {};
        self.inner.close();
    }

    /// Get underlying socket descriptor for poll() or setsockopt().
    /// WARNING: Do not read/write directly - use TelnetConnection methods.
    pub fn getSocket(self: *TelnetConnection) @import("../net/socket.zig").Socket {
        return self.inner.getSocket();
    }

    /// Returns true if connection uses TLS encryption.
    pub fn isTls(self: *const TelnetConnection) bool {
        return self.inner.isTls();
    }

    /// Returns true if connection uses Unix domain sockets.
    pub fn isUnixSocket(self: *const TelnetConnection) bool {
        return self.inner.isUnixSocket();
    }

    /// Send a Telnet command to the remote peer.
    /// For negotiation commands (WILL/WONT/DO/DONT), option parameter is required.
    pub fn sendCommand(self: *TelnetConnection, command: TelnetCommand, option: ?TelnetOption) !void {
        const cmd_data = try self.processor.createCommand(command, option);
        defer self.allocator.free(cmd_data);

        _ = try self.inner.write(cmd_data);
    }

    /// Initiate option negotiation with the remote peer.
    pub fn negotiateOption(self: *TelnetConnection, option: TelnetOption, enable: bool) !void {
        const command: TelnetCommand = if (enable) .will else .wont;
        try self.sendCommand(command, option);
    }

    /// Get current negotiation state of a Telnet option.
    pub fn getOptionState(self: *const TelnetConnection, option: TelnetOption) @import("telnet_processor.zig").OptionState {
        return self.processor.getOptionState(option);
    }

    /// Update terminal window size and send NAWS negotiation if enabled.
    pub fn updateWindowSize(self: *TelnetConnection, width: u16, height: u16) !bool {
        const response_data = try self.processor.updateWindowSize(width, height);
        defer self.allocator.free(response_data);

        if (response_data.len > 0) {
            _ = try self.inner.write(response_data);
            return true;
        }

        return false;
    }

    /// Perform initial Telnet negotiation for client mode.
    /// Client requests server capabilities and offers its own.
    /// Typically called after connection establishment in client mode.
    pub fn performInitialNegotiation(self: *TelnetConnection) !void {
        try self.sendCommand(.do, .suppress_ga); // Request server suppress go-ahead
        try self.sendCommand(.will, .terminal_type); // Offer to provide terminal type
        try self.sendCommand(.will, .naws); // Offer to provide window size
    }

    /// Perform initial Telnet negotiation for server mode.
    /// Server offers capabilities and requests client information.
    /// Typically called after accepting connection in server mode.
    ///
    /// Server-side negotiation differs from client:
    /// - Server announces WILL ECHO (server will echo client input)
    /// - Server announces WILL SUPPRESS_GA (server suppresses go-ahead)
    /// - Server requests DO TERMINAL_TYPE (asks client for terminal type)
    /// - Server requests DO NAWS (asks client for window size)
    pub fn performServerNegotiation(self: *TelnetConnection) !void {
        try self.sendCommand(.will, .echo); // Announce server will echo
        try self.sendCommand(.will, .suppress_ga); // Announce server suppresses go-ahead
        try self.sendCommand(.do, .terminal_type); // Request client terminal type
        try self.sendCommand(.do, .naws); // Request client window size
    }

    /// Reset Telnet negotiation state to initial conditions.
    pub fn resetNegotiation(self: *TelnetConnection) void {
        self.processor.resetNegotiation();
        self.pending_data.clearRetainingCapacity();
        self.pending_response.clearRetainingCapacity();
    }

    /// Flush pending Telnet responses to the remote peer.
    fn flushPendingResponses(self: *TelnetConnection) !void {
        if (self.pending_response.items.len > 0) {
            _ = try self.inner.write(self.pending_response.items);
            self.pending_response.clearRetainingCapacity();
        }
    }
};

/// Create TelnetConnection with default settings.
pub fn fromConnection(connection: Connection, allocator: std.mem.Allocator) !TelnetConnection {
    return TelnetConnection.init(connection, allocator, null, null, null);
}

/// Create TelnetConnection with custom terminal configuration.
pub fn fromConnectionWithConfig(
    connection: Connection,
    allocator: std.mem.Allocator,
    terminal_type: []const u8,
    window_width: u16,
    window_height: u16,
) !TelnetConnection {
    return TelnetConnection.init(connection, allocator, terminal_type, window_width, window_height);
}
</file>

<file path="protocol/telnet_options.zig">
//! Telnet option handlers covering RFC 857 (echo), RFC 858 (suppress go-ahead),
//! RFC 1073 (NAWS), RFC 1091 (terminal type), and RFC 1184 (linemode).
//! These helpers encapsulate the WILL/WONT/DO/DONT exchange for each option so
//! the state machine can stay lean. Adding a new option typically means writing
//! a handler that appends the appropriate negotiation bytes and wiring it into
//! the registry below.

const std = @import("std");
const telnet = @import("telnet.zig");

const TelnetCommand = telnet.TelnetCommand;
const TelnetOption = telnet.TelnetOption;
const TelnetError = telnet.TelnetError;

/// Echo option handler implementing RFC 857 echo negotiation
pub const EchoHandler = struct {
    /// Handle WILL echo from remote side - server will echo, client should disable local echo
    pub fn handleWill(allocator: std.mem.Allocator, response: *std.ArrayList(u8)) !void {
        try response.appendSlice(allocator, &[_]u8{
            @intFromEnum(TelnetCommand.iac),
            @intFromEnum(TelnetCommand.do),
            @intFromEnum(TelnetOption.echo),
        });
    }

    /// Handle DO echo request from remote side - client should enable local echo
    pub fn handleDo(allocator: std.mem.Allocator, response: *std.ArrayList(u8)) !void {
        try response.appendSlice(allocator, &[_]u8{
            @intFromEnum(TelnetCommand.iac),
            @intFromEnum(TelnetCommand.will),
            @intFromEnum(TelnetOption.echo),
        });
    }

    /// Handle WONT echo from remote side - we should handle echo locally
    pub fn handleWont(allocator: std.mem.Allocator, response: *std.ArrayList(u8)) !void {
        try response.appendSlice(allocator, &[_]u8{
            @intFromEnum(TelnetCommand.iac),
            @intFromEnum(TelnetCommand.dont),
            @intFromEnum(TelnetOption.echo),
        });
    }

    /// Handle DONT echo from remote side - remote doesn't want us to echo
    pub fn handleDont(allocator: std.mem.Allocator, response: *std.ArrayList(u8)) !void {
        try response.appendSlice(allocator, &[_]u8{
            @intFromEnum(TelnetCommand.iac),
            @intFromEnum(TelnetCommand.wont),
            @intFromEnum(TelnetOption.echo),
        });
    }
};

/// Terminal type handler implementing RFC 1091 with subnegotiation support
pub const TerminalTypeHandler = struct {
    terminal_type: []const u8,

    const SEND: u8 = 1;
    const IS: u8 = 0;

    /// Initialize terminal type handler with specified terminal type string
    pub fn init(terminal_type: []const u8) TerminalTypeHandler {
        return TerminalTypeHandler{
            .terminal_type = terminal_type,
        };
    }

    /// Handle WILL terminal type from remote side
    pub fn handleWill(allocator: std.mem.Allocator, response: *std.ArrayList(u8)) !void {
        try response.appendSlice(allocator, &[_]u8{
            @intFromEnum(TelnetCommand.iac),
            @intFromEnum(TelnetCommand.do),
            @intFromEnum(TelnetOption.terminal_type),
        });
    }

    /// Handle DO terminal type request from remote side
    pub fn handleDo(allocator: std.mem.Allocator, response: *std.ArrayList(u8)) !void {
        try response.appendSlice(allocator, &[_]u8{
            @intFromEnum(TelnetCommand.iac),
            @intFromEnum(TelnetCommand.will),
            @intFromEnum(TelnetOption.terminal_type),
        });
    }

    /// Handle WONT terminal type from remote side
    pub fn handleWont(allocator: std.mem.Allocator, response: *std.ArrayList(u8)) !void {
        try response.appendSlice(allocator, &[_]u8{
            @intFromEnum(TelnetCommand.iac),
            @intFromEnum(TelnetCommand.dont),
            @intFromEnum(TelnetOption.terminal_type),
        });
    }

    /// Handle DONT terminal type from remote side
    pub fn handleDont(allocator: std.mem.Allocator, response: *std.ArrayList(u8)) !void {
        try response.appendSlice(allocator, &[_]u8{
            @intFromEnum(TelnetCommand.iac),
            @intFromEnum(TelnetCommand.wont),
            @intFromEnum(TelnetOption.terminal_type),
        });
    }

    /// Handle terminal type subnegotiation - responds to SEND requests with configured terminal type
    /// 
    /// Parameters:
    /// - data: Subnegotiation data received from remote
    /// - response: Buffer to append response commands
    pub fn handleSubnegotiation(self: *const TerminalTypeHandler, allocator: std.mem.Allocator, data: []const u8, response: *std.ArrayList(u8)) !void {
        if (data.len == 0) return;

        switch (data[0]) {
            SEND => {
                try response.appendSlice(allocator, &[_]u8{
                    @intFromEnum(TelnetCommand.iac),
                    @intFromEnum(TelnetCommand.sb),
                    @intFromEnum(TelnetOption.terminal_type),
                    IS,
                });
                try response.appendSlice(allocator, self.terminal_type);
                try response.appendSlice(allocator, &[_]u8{
                    @intFromEnum(TelnetCommand.iac),
                    @intFromEnum(TelnetCommand.se),
                });
            },
            IS => {
                // Remote is providing their terminal type - store if needed
            },
            else => {
                // Unknown subnegotiation command
            },
        }
    }
};

/// NAWS (Negotiate About Window Size) handler implementing RFC 1073
pub const NAWSHandler = struct {
    width: u16,
    height: u16,

    /// Initialize NAWS handler with specified window dimensions
    pub fn init(width: u16, height: u16) NAWSHandler {
        return NAWSHandler{
            .width = width,
            .height = height,
        };
    }

    /// Handle WILL NAWS from remote side
    pub fn handleWill(allocator: std.mem.Allocator, response: *std.ArrayList(u8)) !void {
        try response.appendSlice(allocator, &[_]u8{
            @intFromEnum(TelnetCommand.iac),
            @intFromEnum(TelnetCommand.do),
            @intFromEnum(TelnetOption.naws),
        });
    }

    /// Handle DO NAWS request from remote side - immediately sends current window size
    pub fn handleDo(self: *const NAWSHandler, allocator: std.mem.Allocator, response: *std.ArrayList(u8)) !void {
        try response.appendSlice(allocator, &[_]u8{
            @intFromEnum(TelnetCommand.iac),
            @intFromEnum(TelnetCommand.will),
            @intFromEnum(TelnetOption.naws),
        });

        try self.sendWindowSize(allocator, response);
    }

    /// Handle WONT NAWS from remote side
    pub fn handleWont(allocator: std.mem.Allocator, response: *std.ArrayList(u8)) !void {
        try response.appendSlice(allocator, &[_]u8{
            @intFromEnum(TelnetCommand.iac),
            @intFromEnum(TelnetCommand.dont),
            @intFromEnum(TelnetOption.naws),
        });
    }

    /// Handle DONT NAWS from remote side
    pub fn handleDont(allocator: std.mem.Allocator, response: *std.ArrayList(u8)) !void {
        try response.appendSlice(allocator, &[_]u8{
            @intFromEnum(TelnetCommand.iac),
            @intFromEnum(TelnetCommand.wont),
            @intFromEnum(TelnetOption.naws),
        });
    }

    /// Send window size information via subnegotiation
    /// Encodes width and height as 16-bit big-endian values
    pub fn sendWindowSize(self: *const NAWSHandler, allocator: std.mem.Allocator, response: *std.ArrayList(u8)) !void {
        try response.appendSlice(allocator, &[_]u8{
            @intFromEnum(TelnetCommand.iac),
            @intFromEnum(TelnetCommand.sb),
            @intFromEnum(TelnetOption.naws),
        });

        // Width (16-bit big-endian)
        try response.append(allocator, @intCast(self.width >> 8));
        try response.append(allocator, @intCast(self.width & 0xFF));

        // Height (16-bit big-endian)
        try response.append(allocator, @intCast(self.height >> 8));
        try response.append(allocator, @intCast(self.height & 0xFF));

        try response.appendSlice(allocator, &[_]u8{
            @intFromEnum(TelnetCommand.iac),
            @intFromEnum(TelnetCommand.se),
        });
    }

    /// Parse NAWS subnegotiation data to extract window dimensions
    /// Returns window size struct or null if data is malformed
    pub fn handleSubnegotiation(data: []const u8) ?struct { width: u16, height: u16 } {
        if (data.len < 4) return null;

        const width = (@as(u16, data[0]) << 8) | @as(u16, data[1]);
        const height = (@as(u16, data[2]) << 8) | @as(u16, data[3]);

        return .{ .width = width, .height = height };
    }

    /// Update stored window size and send NAWS subnegotiation
    pub fn updateWindowSize(self: *NAWSHandler, allocator: std.mem.Allocator, width: u16, height: u16, response: *std.ArrayList(u8)) !void {
        self.width = width;
        self.height = height;
        try self.sendWindowSize(allocator, response);
    }
};

/// Suppress Go Ahead handler implementing RFC 858
pub const SuppressGoAheadHandler = struct {
    /// Handle WILL suppress go ahead from remote side
    pub fn handleWill(allocator: std.mem.Allocator, response: *std.ArrayList(u8)) !void {
        try response.appendSlice(allocator, &[_]u8{
            @intFromEnum(TelnetCommand.iac),
            @intFromEnum(TelnetCommand.do),
            @intFromEnum(TelnetOption.suppress_ga),
        });
    }

    /// Handle DO suppress go ahead request from remote side
    pub fn handleDo(allocator: std.mem.Allocator, response: *std.ArrayList(u8)) !void {
        try response.appendSlice(allocator, &[_]u8{
            @intFromEnum(TelnetCommand.iac),
            @intFromEnum(TelnetCommand.will),
            @intFromEnum(TelnetOption.suppress_ga),
        });
    }

    /// Handle WONT suppress go ahead from remote side
    pub fn handleWont(allocator: std.mem.Allocator, response: *std.ArrayList(u8)) !void {
        try response.appendSlice(allocator, &[_]u8{
            @intFromEnum(TelnetCommand.iac),
            @intFromEnum(TelnetCommand.dont),
            @intFromEnum(TelnetOption.suppress_ga),
        });
    }

    /// Handle DONT suppress go ahead from remote side
    pub fn handleDont(allocator: std.mem.Allocator, response: *std.ArrayList(u8)) !void {
        try response.appendSlice(allocator, &[_]u8{
            @intFromEnum(TelnetCommand.iac),
            @intFromEnum(TelnetCommand.wont),
            @intFromEnum(TelnetOption.suppress_ga),
        });
    }
};

/// Linemode handler implementing RFC 1184 for line-oriented terminal operation
pub const LinemodeHandler = struct {
    const MODE: u8 = 1;
    const FORWARDMASK: u8 = 2;
    const SLC: u8 = 3;

    const MODE_EDIT: u8 = 0x01;
    const MODE_TRAPSIG: u8 = 0x02;
    const MODE_ACK: u8 = 0x04;
    const MODE_SOFT_TAB: u8 = 0x08;
    const MODE_LIT_ECHO: u8 = 0x10;

    /// Handle WILL linemode from remote side
    pub fn handleWill(allocator: std.mem.Allocator, response: *std.ArrayList(u8)) !void {
        try response.appendSlice(allocator, &[_]u8{
            @intFromEnum(TelnetCommand.iac),
            @intFromEnum(TelnetCommand.do),
            @intFromEnum(TelnetOption.linemode),
        });
    }

    /// Handle DO linemode request from remote side - sends preferred linemode settings
    pub fn handleDo(allocator: std.mem.Allocator, response: *std.ArrayList(u8)) !void {
        try response.appendSlice(allocator, &[_]u8{
            @intFromEnum(TelnetCommand.iac),
            @intFromEnum(TelnetCommand.will),
            @intFromEnum(TelnetOption.linemode),
        });

        try LinemodeHandler.sendLinemodeSettings(allocator, response);
    }

    /// Handle WONT linemode from remote side
    pub fn handleWont(allocator: std.mem.Allocator, response: *std.ArrayList(u8)) !void {
        try response.appendSlice(allocator, &[_]u8{
            @intFromEnum(TelnetCommand.iac),
            @intFromEnum(TelnetCommand.dont),
            @intFromEnum(TelnetOption.linemode),
        });
    }

    /// Handle DONT linemode from remote side
    pub fn handleDont(allocator: std.mem.Allocator, response: *std.ArrayList(u8)) !void {
        try response.appendSlice(allocator, &[_]u8{
            @intFromEnum(TelnetCommand.iac),
            @intFromEnum(TelnetCommand.wont),
            @intFromEnum(TelnetOption.linemode),
        });
    }

    /// Send linemode settings enabling editing and signal trapping
    pub fn sendLinemodeSettings(allocator: std.mem.Allocator, response: *std.ArrayList(u8)) !void {
        try response.appendSlice(allocator, &[_]u8{
            @intFromEnum(TelnetCommand.iac),
            @intFromEnum(TelnetCommand.sb),
            @intFromEnum(TelnetOption.linemode),
            MODE,
            MODE_EDIT | MODE_TRAPSIG,
            @intFromEnum(TelnetCommand.iac),
            @intFromEnum(TelnetCommand.se),
        });
    }

    /// Handle linemode subnegotiation commands (MODE, FORWARDMASK, SLC)
    pub fn handleSubnegotiation(allocator: std.mem.Allocator, data: []const u8, response: *std.ArrayList(u8)) !void {
        if (data.len == 0) return;

        switch (data[0]) {
            MODE => {
                if (data.len >= 2) {
                    const mode_byte = data[1];
                    if (mode_byte & MODE_ACK == 0) {
                        // Send acknowledgment
                        try response.appendSlice(allocator, &[_]u8{
                            @intFromEnum(TelnetCommand.iac),
                            @intFromEnum(TelnetCommand.sb),
                            @intFromEnum(TelnetOption.linemode),
                            MODE,
                            mode_byte | MODE_ACK,
                            @intFromEnum(TelnetCommand.iac),
                            @intFromEnum(TelnetCommand.se),
                        });
                    }
                }
            },
            FORWARDMASK => {
                // Echo back the forward mask for acknowledgment
                if (data.len >= 33) {
                    try response.appendSlice(allocator, &[_]u8{
                        @intFromEnum(TelnetCommand.iac),
                        @intFromEnum(TelnetCommand.sb),
                        @intFromEnum(TelnetOption.linemode),
                        FORWARDMASK,
                    });
                    try response.appendSlice(allocator, data[1..33]);
                    try response.appendSlice(allocator, &[_]u8{
                        @intFromEnum(TelnetCommand.iac),
                        @intFromEnum(TelnetCommand.se),
                    });
                }
            },
            SLC => {
                // Special Line Character subnegotiation - minimal implementation
            },
            else => {
                // Unknown subnegotiation command
            },
        }
    }
};

/// Registry for dispatching Telnet option negotiations to appropriate handlers
/// Aggregates per-option handlers and serializes their negotiation responses.
/// The registry queues every generated command into a shared buffer so the peer
/// observes a coherent sequence (e.g. WILL echo followed by DO suppress-go-ahead).
/// Unsupported options fall through to the refusal helper, ensuring we respond
/// with RFC 1143-compliant mirror commands and never leave the state machine in
/// limbo.
pub const OptionHandlerRegistry = struct {
    echo_handler: EchoHandler,
    terminal_type_handler: TerminalTypeHandler,
    naws_handler: NAWSHandler,
    suppress_ga_handler: SuppressGoAheadHandler,
    linemode_handler: LinemodeHandler,

    /// Initialize option handler registry with terminal configuration
    /// 
    /// Parameters:
    /// - terminal_type: Terminal type string (e.g., "xterm", "vt100")
    /// - window_width: Initial terminal width in characters
    /// - window_height: Initial terminal height in characters
    pub fn init(terminal_type: []const u8, window_width: u16, window_height: u16) OptionHandlerRegistry {
        return OptionHandlerRegistry{
            .echo_handler = EchoHandler{},
            .terminal_type_handler = TerminalTypeHandler.init(terminal_type),
            .naws_handler = NAWSHandler.init(window_width, window_height),
            .suppress_ga_handler = SuppressGoAheadHandler{},
            .linemode_handler = LinemodeHandler{},
        };
    }

    /// Dispatch negotiation command to appropriate option handler
    /// Unsupported options are automatically refused with appropriate response
    pub fn handleNegotiation(self: *OptionHandlerRegistry, allocator: std.mem.Allocator, command: TelnetCommand, option: TelnetOption, response: *std.ArrayList(u8)) !void {
        switch (option) {
            .echo => switch (command) {
                .will => try EchoHandler.handleWill(allocator, response),
                .wont => try EchoHandler.handleWont(allocator, response),
                .do => try EchoHandler.handleDo(allocator, response),
                .dont => try EchoHandler.handleDont(allocator, response),
                else => {},
            },
            .terminal_type => switch (command) {
                .will => try TerminalTypeHandler.handleWill(allocator, response),
                .wont => try TerminalTypeHandler.handleWont(allocator, response),
                .do => try TerminalTypeHandler.handleDo(allocator, response),
                .dont => try TerminalTypeHandler.handleDont(allocator, response),
                else => {},
            },
            .naws => switch (command) {
                .will => try NAWSHandler.handleWill(allocator, response),
                .wont => try NAWSHandler.handleWont(allocator, response),
                .do => try self.naws_handler.handleDo(allocator, response),
                .dont => try NAWSHandler.handleDont(allocator, response),
                else => {},
            },
            .suppress_ga => switch (command) {
                .will => try SuppressGoAheadHandler.handleWill(allocator, response),
                .wont => try SuppressGoAheadHandler.handleWont(allocator, response),
                .do => try SuppressGoAheadHandler.handleDo(allocator, response),
                .dont => try SuppressGoAheadHandler.handleDont(allocator, response),
                else => {},
            },
            .linemode => switch (command) {
                .will => try LinemodeHandler.handleWill(allocator, response),
                .wont => try LinemodeHandler.handleWont(allocator, response),
                .do => try LinemodeHandler.handleDo(allocator, response),
                .dont => try LinemodeHandler.handleDont(allocator, response),
                else => {},
            },
            else => {
                // Refuse unsupported options
                // We map WILLDONT and DOWONT per RFC 1143's Q-method so
                // peers receive mirrored refusals and avoid negotiation loops.
                const refusal_cmd: TelnetCommand = switch (command) {
                    .will => .dont,
                    .do => .wont,
                    .wont, .dont => return,
                    else => return,
                };

                try response.appendSlice(allocator, &[_]u8{
                    @intFromEnum(TelnetCommand.iac),
                    @intFromEnum(refusal_cmd),
                    @intFromEnum(option),
                });
            },
        }
    }

    /// Dispatch subnegotiation to appropriate option handler
    pub fn handleSubnegotiation(self: *OptionHandlerRegistry, allocator: std.mem.Allocator, option: TelnetOption, data: []const u8, response: *std.ArrayList(u8)) !void {
        switch (option) {
            .terminal_type => try self.terminal_type_handler.handleSubnegotiation(allocator, data, response),
            .naws => {
                if (NAWSHandler.handleSubnegotiation(data)) |window_info| {
                    _ = window_info; // Store window size if needed
                }
            },
            .linemode => try LinemodeHandler.handleSubnegotiation(allocator, data, response),
            else => {
                // Ignore unsupported subnegotiation
            },
        }
    }

    /// Update window size and send NAWS subnegotiation to remote
    pub fn updateWindowSize(self: *OptionHandlerRegistry, allocator: std.mem.Allocator, width: u16, height: u16, response: *std.ArrayList(u8)) !void {
        try self.naws_handler.updateWindowSize(allocator, width, height, response);
    }
};
</file>

<file path="protocol/telnet_processor.zig">
//! Telnet protocol state machine that filters IAC sequences and brokers
//! option negotiation per RFC 854/855. The processor collaborates with
//! `OptionHandlerRegistry` so each option handler can emit responses while
//! the core loop focuses on state tracking, buffering, and allocator hygiene.
const std = @import("std");
const telnet = @import("telnet.zig");
const telnet_options = @import("telnet_options.zig");

const TelnetState = telnet.TelnetState;
const TelnetCommand = telnet.TelnetCommand;
const TelnetOption = telnet.TelnetOption;
const TelnetError = telnet.TelnetError;
const OptionHandlerRegistry = telnet_options.OptionHandlerRegistry;

/// Option negotiation state for each Telnet option
pub const OptionState = enum {
    no,
    yes,
    wantno,
    wantyes,
};

/// Telnet protocol processor with state machine
pub const TelnetProcessor = struct {
    state: TelnetState,
    option_states: std.EnumMap(TelnetOption, OptionState),
    sb_buffer: std.ArrayList(u8),
    current_option: ?TelnetOption,
    allocator: std.mem.Allocator,
    negotiation_count: std.EnumMap(TelnetOption, u32),
    partial_buffer: std.ArrayList(u8),
    option_handlers: OptionHandlerRegistry,

    const MAX_SUBNEGOTIATION_LENGTH = 1024; // Cap subnegotiations at 1KiB to match legacy ncat limits and avoid abuse.
    const MAX_NEGOTIATION_ATTEMPTS = 10; // Mirrors RFC 1143 guidance on breaking negotiation loops (Q-method).
    const MAX_PARTIAL_BUFFER_SIZE = 16; // Long enough for "IAC SB <option> ... IAC" fragments per RFC 854/1143.

    /// Initialize a new Telnet processor with all options disabled
    pub fn init(allocator: std.mem.Allocator, terminal_type: []const u8, window_width: u16, window_height: u16) TelnetProcessor {
        var option_states = std.EnumMap(TelnetOption, OptionState){};
        var negotiation_count = std.EnumMap(TelnetOption, u32){};

        inline for (std.meta.fields(TelnetOption)) |field| {
            const option = @field(TelnetOption, field.name);
            option_states.put(option, .no);
            negotiation_count.put(option, 0);
        }

        return TelnetProcessor{
            .state = .data,
            .option_states = option_states,
            .sb_buffer = std.ArrayList(u8).initCapacity(allocator, 0) catch unreachable,
            .current_option = null,
            .allocator = allocator,
            .negotiation_count = negotiation_count,
            .partial_buffer = std.ArrayList(u8).initCapacity(allocator, 0) catch unreachable,
            .option_handlers = OptionHandlerRegistry.init(terminal_type, window_width, window_height),
        };
    }

    /// Clean up allocated resources
    pub fn deinit(self: *TelnetProcessor) void {
        self.sb_buffer.deinit(self.allocator);
        self.partial_buffer.deinit(self.allocator);
    }

    pub const ProcessResult = struct {
        data: []u8,
        response: []u8,
    };

    /// Process input data through the Telnet state machine.
    /// Filters out Telnet IAC sequences and handles option negotiation.
    /// Maintains state across calls to handle partial sequences.
    ///
    /// Returns ProcessResult containing filtered application data and any
    /// negotiation responses to send to the peer. The caller owns both slices and
    /// must free them with the same allocator passed to `init`.
    pub fn processInput(self: *TelnetProcessor, input: []const u8) (TelnetError || std.mem.Allocator.Error)!ProcessResult {
        var app_data = try std.ArrayList(u8).initCapacity(self.allocator, 0);
        defer app_data.deinit(self.allocator);

        var response = try std.ArrayList(u8).initCapacity(self.allocator, 0);
        defer response.deinit(self.allocator);

        var combined_input = try std.ArrayList(u8).initCapacity(self.allocator, 0);
        defer combined_input.deinit(self.allocator);

        try combined_input.appendSlice(self.allocator, self.partial_buffer.items);
        try combined_input.appendSlice(self.allocator, input);
        self.partial_buffer.clearRetainingCapacity();

        var i: usize = 0;
        while (i < combined_input.items.len) {
            const byte = combined_input.items[i];
            const next_state = self.getNextState(byte) catch |err| {
                if (self.isIncompleteSequence(combined_input.items[i..])) {
                    const remaining = combined_input.items[i..];
                    if (remaining.len > MAX_PARTIAL_BUFFER_SIZE) {
                        return TelnetError.BufferOverflow;
                    }
                    try self.partial_buffer.appendSlice(self.allocator, remaining);
                    break;
                }
                return err;
            };

            try telnet.validateStateTransition(self.state, next_state, byte);
            try self.processByte(byte, next_state, &app_data, &response);
            self.state = next_state;
            i += 1;
        }

        return ProcessResult{
            .data = try app_data.toOwnedSlice(self.allocator),
            .response = try response.toOwnedSlice(self.allocator),
        };
    }

    fn isIncompleteSequence(self: *const TelnetProcessor, remaining: []const u8) bool {
        if (remaining.len == 0) return false;

        if (remaining[0] == @intFromEnum(TelnetCommand.iac)) {
            if (remaining.len == 1) return true;

            const command = TelnetCommand.fromByte(remaining[1]);
            if (command) |cmd| {
                if (telnet.commandRequiresOption(cmd) and remaining.len == 2) {
                    return true;
                }
            }
        }

        if (self.state == .sb_data or self.state == .sb_iac) {
            return true;
        }

        return false;
    }

    /// Process outgoing application data, escaping IAC bytes per RFC 854.
    /// Optionally injects Telnet commands before the data.
    pub fn processOutput(self: *TelnetProcessor, data: []const u8, inject_commands: ?[]const u8) std.mem.Allocator.Error![]u8 {
        var output = try std.ArrayList(u8).initCapacity(self.allocator, 0);
        defer output.deinit(self.allocator);

        if (inject_commands) |commands| {
            try output.appendSlice(self.allocator, commands);
        }

        for (data) |byte| {
            if (byte == @intFromEnum(TelnetCommand.iac)) {
                try output.appendSlice(self.allocator, &[_]u8{ @intFromEnum(TelnetCommand.iac), @intFromEnum(TelnetCommand.iac) });
            } else {
                try output.append(self.allocator, byte);
            }
        }

        return try output.toOwnedSlice(self.allocator);
    }

    /// Create a properly formatted Telnet command sequence.
    /// Option parameter is required for negotiation commands (WILL/WONT/DO/DONT/SB).
    pub fn createCommand(self: *TelnetProcessor, command: TelnetCommand, option: ?TelnetOption) (TelnetError || std.mem.Allocator.Error)![]u8 {
        var cmd_data = try std.ArrayList(u8).initCapacity(self.allocator, 0);
        defer cmd_data.deinit(self.allocator);

        try cmd_data.append(self.allocator, @intFromEnum(TelnetCommand.iac));
        try cmd_data.append(self.allocator, @intFromEnum(command));

        if (telnet.commandRequiresOption(command)) {
            const opt = option orelse return TelnetError.InvalidCommand;
            try cmd_data.append(self.allocator, @intFromEnum(opt));
        }

        return try cmd_data.toOwnedSlice(self.allocator);
    }

    fn getNextState(self: *const TelnetProcessor, byte: u8) TelnetError!TelnetState {
        // The transition table mirrors the RFC 854 state diagram so every byte keeps
        // the processor in a well-defined mode before validation/dispatch occur.
        return switch (self.state) {
            .data => if (byte == @intFromEnum(TelnetCommand.iac)) .iac else .data,
            .iac => switch (byte) {
                @intFromEnum(TelnetCommand.will) => .will,
                @intFromEnum(TelnetCommand.wont) => .wont,
                @intFromEnum(TelnetCommand.do) => .do,
                @intFromEnum(TelnetCommand.dont) => .dont,
                @intFromEnum(TelnetCommand.sb) => .sb,
                @intFromEnum(TelnetCommand.iac) => .data,
                else => if (telnet.isValidCommand(byte)) .data else return TelnetError.InvalidCommand,
            },
            .will, .wont, .do, .dont => .data,
            .sb => .sb_data,
            .sb_data => if (byte == @intFromEnum(TelnetCommand.iac)) .sb_iac else .sb_data,
            .sb_iac => switch (byte) {
                @intFromEnum(TelnetCommand.se) => .data,
                @intFromEnum(TelnetCommand.iac) => .sb_data,
                else => return TelnetError.MalformedSequence,
            },
        };
    }

    fn processByte(self: *TelnetProcessor, byte: u8, _: TelnetState, app_data: *std.ArrayList(u8), response: *std.ArrayList(u8)) (TelnetError || std.mem.Allocator.Error)!void {
        // Data states emit straight into app_data, while negotiation states funnel
        // through OptionHandlerRegistry so each RFC-specific handler can craft replies.
        switch (self.state) {
            .data => {
                if (byte != @intFromEnum(TelnetCommand.iac)) {
                    try app_data.append(self.allocator, byte);
                }
            },
            .iac => {
                if (byte == @intFromEnum(TelnetCommand.iac)) {
                    try app_data.append(self.allocator, byte);
                } else if (telnet.commandRequiresOption(TelnetCommand.fromByte(byte) orelse return TelnetError.InvalidCommand)) {} else {
                    try self.handleSimpleCommand(TelnetCommand.fromByte(byte) orelse return TelnetError.InvalidCommand, response);
                }
            },
            .will => {
                const option = TelnetOption.fromByte(byte);
                // Hand the negotiation off to the centralized option registry so each
                // handler can emit protocol-specific replies.
                try self.handleNegotiation(.will, option, response);
            },
            .wont => {
                const option = TelnetOption.fromByte(byte);
                try self.handleNegotiation(.wont, option, response);
            },
            .do => {
                const option = TelnetOption.fromByte(byte);
                try self.handleNegotiation(.do, option, response);
            },
            .dont => {
                const option = TelnetOption.fromByte(byte);
                try self.handleNegotiation(.dont, option, response);
            },
            .sb => {
                self.current_option = TelnetOption.fromByte(byte);
                self.sb_buffer.clearRetainingCapacity();
            },
            .sb_data => {
                if (byte != @intFromEnum(TelnetCommand.iac)) {
                    if (self.sb_buffer.items.len > MAX_SUBNEGOTIATION_LENGTH - 1) {
                        return TelnetError.SubnegotiationTooLong;
                    }
                    try self.sb_buffer.append(self.allocator, byte);
                }
            },
            .sb_iac => {
                if (byte == @intFromEnum(TelnetCommand.se)) {
                    try self.handleSubnegotiation(self.current_option, self.sb_buffer.items, response);
                    self.current_option = null;
                } else if (byte == @intFromEnum(TelnetCommand.iac)) {
                    if (self.sb_buffer.items.len > MAX_SUBNEGOTIATION_LENGTH - 1) {
                        return TelnetError.SubnegotiationTooLong;
                    }
                    try self.sb_buffer.append(self.allocator, byte);
                }
            },
        }
    }

    fn handleSimpleCommand(self: *TelnetProcessor, command: TelnetCommand, response: *std.ArrayList(u8)) (TelnetError || std.mem.Allocator.Error)!void {
        _ = self;
        _ = response;

        switch (command) {
            .nop => {},
            .dm => {},
            .brk => {},
            .ip => {},
            .ao => {},
            .ayt => {},
            .ec => {},
            .el => {},
            .ga => {},
            .se => return TelnetError.MalformedSequence,
            else => return TelnetError.InvalidCommand,
        }
    }

    fn handleNegotiation(self: *TelnetProcessor, command: TelnetCommand, option: ?TelnetOption, response: *std.ArrayList(u8)) (TelnetError || std.mem.Allocator.Error)!void {
        const opt = option orelse {
            const refusal_cmd: TelnetCommand = switch (command) {
                .will => .dont,
                .do => .wont,
                .wont, .dont => return,
                else => return TelnetError.InvalidCommand,
            };

            try response.appendSlice(self.allocator, &[_]u8{
                @intFromEnum(TelnetCommand.iac),
                @intFromEnum(refusal_cmd),
                0,
            });
            return;
        };

        const count = self.negotiation_count.get(opt) orelse 0;
        if (count >= MAX_NEGOTIATION_ATTEMPTS) {
            return TelnetError.NegotiationLoop;
        }
        self.negotiation_count.put(opt, count + 1);

        try self.processNegotiation(command, opt, response);
    }

    fn processNegotiation(self: *TelnetProcessor, command: TelnetCommand, option: TelnetOption, response: *std.ArrayList(u8)) (TelnetError || std.mem.Allocator.Error)!void {
        const current_state = self.option_states.get(option) orelse .no;

        // Use option handlers for supported options
        if (self.isOptionSupported(option)) {
            try self.option_handlers.handleNegotiation(self.allocator, command, option, response);

            // Update our internal state based on the negotiation
            switch (command) {
                .will => try self.handleWill(option, current_state, response),
                .wont => try self.handleWont(option, current_state, response),
                .do => try self.handleDo(option, current_state, response),
                .dont => try self.handleDont(option, current_state, response),
                else => return TelnetError.InvalidCommand,
            }
        } else {
            // For unsupported options, use default handling
            switch (command) {
                .will => try self.handleWill(option, current_state, response),
                .wont => try self.handleWont(option, current_state, response),
                .do => try self.handleDo(option, current_state, response),
                .dont => try self.handleDont(option, current_state, response),
                else => return TelnetError.InvalidCommand,
            }
        }
    }
    fn handleWill(self: *TelnetProcessor, option: TelnetOption, current_state: OptionState, response: *std.ArrayList(u8)) (TelnetError || std.mem.Allocator.Error)!void {
        switch (current_state) {
            .no => {
                self.option_states.put(option, .yes);
                try self.sendResponse(.do, option, response);
            },
            .yes => {},
            .wantno => {
                self.option_states.put(option, .yes);
            },
            .wantyes => {
                self.option_states.put(option, .yes);
            },
        }
    }

    fn handleWont(self: *TelnetProcessor, option: TelnetOption, current_state: OptionState, response: *std.ArrayList(u8)) (TelnetError || std.mem.Allocator.Error)!void {
        switch (current_state) {
            .no => {},
            .yes => {
                self.option_states.put(option, .no);
                try self.sendResponse(.dont, option, response);
            },
            .wantno => {
                self.option_states.put(option, .no);
            },
            .wantyes => {
                self.option_states.put(option, .no);
            },
        }
    }

    fn handleDo(self: *TelnetProcessor, option: TelnetOption, current_state: OptionState, response: *std.ArrayList(u8)) (TelnetError || std.mem.Allocator.Error)!void {
        switch (current_state) {
            .no => {
                if (self.isOptionSupported(option)) {
                    self.option_states.put(option, .yes);
                    try self.sendResponse(.will, option, response);
                } else {
                    try self.sendResponse(.wont, option, response);
                }
            },
            .yes => {},
            .wantno => {
                try self.sendResponse(.wont, option, response);
                self.option_states.put(option, .no);
            },
            .wantyes => {
                self.option_states.put(option, .yes);
            },
        }
    }

    fn handleDont(self: *TelnetProcessor, option: TelnetOption, current_state: OptionState, response: *std.ArrayList(u8)) (TelnetError || std.mem.Allocator.Error)!void {
        switch (current_state) {
            .no => {},
            .yes => {
                self.option_states.put(option, .no);
                try self.sendResponse(.wont, option, response);
            },
            .wantno => {
                self.option_states.put(option, .no);
            },
            .wantyes => {
                self.option_states.put(option, .no);
            },
        }
    }

    fn sendResponse(self: *TelnetProcessor, command: TelnetCommand, option: TelnetOption, response: *std.ArrayList(u8)) (TelnetError || std.mem.Allocator.Error)!void {
        try response.appendSlice(self.allocator, &[_]u8{
            @intFromEnum(TelnetCommand.iac),
            @intFromEnum(command),
            @intFromEnum(option),
        });
    }

    fn isOptionSupported(self: *const TelnetProcessor, option: TelnetOption) bool {
        _ = self;
        return switch (option) {
            .echo => true,
            .suppress_ga => true,
            .terminal_type => true,
            .naws => true,
            .linemode => true,
            else => false,
        };
    }

    fn handleSubnegotiation(self: *TelnetProcessor, option: ?TelnetOption, data: []const u8, response: *std.ArrayList(u8)) (TelnetError || std.mem.Allocator.Error)!void {
        const opt = option orelse return;

        // Use option handlers for subnegotiation
        try self.option_handlers.handleSubnegotiation(self.allocator, opt, data, response);
    }

    pub fn resetNegotiation(self: *TelnetProcessor) void {
        inline for (std.meta.fields(TelnetOption)) |field| {
            const option = @field(TelnetOption, field.name);
            self.option_states.put(option, .no);
            self.negotiation_count.put(option, 0);
        }
        self.state = .data;
        self.current_option = null;
        self.sb_buffer.clearRetainingCapacity();
    }

    pub fn clearBuffers(self: *TelnetProcessor) void {
        self.sb_buffer.clearRetainingCapacity();
        self.partial_buffer.clearRetainingCapacity();
    }

    /// Update window size and send NAWS subnegotiation if enabled
    pub fn updateWindowSize(self: *TelnetProcessor, width: u16, height: u16) std.mem.Allocator.Error![]u8 {
        var response = std.ArrayList(u8).init(self.allocator);
        defer response.deinit();

        // Only send if NAWS is enabled
        if (self.option_states.get(.naws) == .yes) {
            try self.option_handlers.updateWindowSize(self.allocator, width, height, &response);
        }

        return try response.toOwnedSlice();
    }

    /// Get the current state of a Telnet option
    pub fn getOptionState(self: *const TelnetProcessor, option: TelnetOption) OptionState {
        return self.option_states.get(option) orelse .no;
    }
};
</file>

<file path="protocol/telnet.zig">
//! Core Telnet enums, helpers, and validation utilities shared by the protocol
//! processor. These definitions mirror RFC854/855 terminology so the event
//! loop can reason about commands, options, and legal state transitions.
const std = @import("std");

/// Telnet protocol state machine states
pub const TelnetState = enum {
    data, // Normal data processing
    iac, // Received IAC (255)
    will, // Received IAC WILL
    wont, // Received IAC WONT
    do, // Received IAC DO
    dont, // Received IAC DONT
    sb, // Subnegotiation begin
    sb_data, // Subnegotiation data
    sb_iac, // IAC in subnegotiation
};

/// Telnet protocol commands as defined in RFC 854
pub const TelnetCommand = enum(u8) {
    se = 240, // End of subnegotiation
    nop = 241, // No operation
    dm = 242, // Data mark
    brk = 243, // Break
    ip = 244, // Interrupt process
    ao = 245, // Abort output
    ayt = 246, // Are you there
    ec = 247, // Erase character
    el = 248, // Erase line
    ga = 249, // Go ahead
    sb = 250, // Subnegotiation begin
    will = 251, // Will option
    wont = 252, // Won't option
    do = 253, // Do option
    dont = 254, // Don't option
    iac = 255, // Interpret as command

    /// Convert byte to TelnetCommand if valid
    pub fn fromByte(byte: u8) ?TelnetCommand {
        return switch (byte) {
            240...255 => @enumFromInt(byte),
            else => null,
        };
    }
};

/// Telnet options as defined in various RFCs
pub const TelnetOption = enum(u8) {
    echo = 1, // Echo (RFC 857)
    suppress_ga = 3, // Suppress go ahead (RFC 858)
    status = 5, // Status (RFC 859)
    timing_mark = 6, // Timing mark (RFC 860)
    terminal_type = 24, // Terminal type (RFC 1091)
    naws = 31, // Negotiate about window size (RFC 1073)
    terminal_speed = 32, // Terminal speed (RFC 1079)
    flow_control = 33, // Remote flow control (RFC 1372)
    linemode = 34, // Linemode (RFC 1184)
    environ = 36, // Environment variables (RFC 1408)

    /// Convert byte to TelnetOption if recognized
    pub fn fromByte(byte: u8) ?TelnetOption {
        return switch (byte) {
            1 => .echo,
            3 => .suppress_ga,
            5 => .status,
            6 => .timing_mark,
            24 => .terminal_type,
            31 => .naws,
            32 => .terminal_speed,
            33 => .flow_control,
            34 => .linemode,
            36 => .environ,
            else => null,
        };
    }
};
/// Telnet protocol errors
pub const TelnetError = error{
    InvalidCommand,
    InvalidOption,
    BufferOverflow,
    NegotiationLoop,
    MalformedSequence,
    SubnegotiationTooLong,
    InvalidStateTransition,
};

/// Ensure the state machine only follows RFC-sanctioned transitions.
/// Used by `TelnetProcessor` to guard each byte before it updates state.
pub fn validateStateTransition(current: TelnetState, next: TelnetState, input: u8) TelnetError!void {
    const valid = switch (current) {
        .data => switch (input) {
            @intFromEnum(TelnetCommand.iac) => next == .iac,
            else => next == .data,
        },
        .iac => switch (input) {
            @intFromEnum(TelnetCommand.will) => next == .will,
            @intFromEnum(TelnetCommand.wont) => next == .wont,
            @intFromEnum(TelnetCommand.do) => next == .do,
            @intFromEnum(TelnetCommand.dont) => next == .dont,
            @intFromEnum(TelnetCommand.sb) => next == .sb,
            @intFromEnum(TelnetCommand.iac) => next == .data, // Escaped IAC
            @intFromEnum(TelnetCommand.se), @intFromEnum(TelnetCommand.nop), @intFromEnum(TelnetCommand.dm), @intFromEnum(TelnetCommand.brk), @intFromEnum(TelnetCommand.ip), @intFromEnum(TelnetCommand.ao), @intFromEnum(TelnetCommand.ayt), @intFromEnum(TelnetCommand.ec), @intFromEnum(TelnetCommand.el), @intFromEnum(TelnetCommand.ga) => next == .data,
            else => false,
        },
        .will, .wont, .do, .dont => next == .data, // Option byte follows, then back to data
        .sb => next == .sb_data,
        .sb_data => switch (input) {
            @intFromEnum(TelnetCommand.iac) => next == .sb_iac,
            else => next == .sb_data,
        },
        .sb_iac => switch (input) {
            @intFromEnum(TelnetCommand.se) => next == .data,
            @intFromEnum(TelnetCommand.iac) => next == .sb_data, // Escaped IAC in subnegotiation
            else => false,
        },
    };

    if (!valid) {
        return TelnetError.InvalidStateTransition;
    }
}

/// Check if a command requires an option byte
pub fn commandRequiresOption(command: TelnetCommand) bool {
    return switch (command) {
        .will, .wont, .do, .dont, .sb => true,
        else => false,
    };
}

/// Check if a byte is a valid Telnet command
pub fn isValidCommand(byte: u8) bool {
    return TelnetCommand.fromByte(byte) != null;
}

/// Check if a byte is a recognized Telnet option
pub fn isRecognizedOption(byte: u8) bool {
    return TelnetOption.fromByte(byte) != null;
}
// Re-export TelnetProcessor for convenience
pub const TelnetProcessor = @import("telnet_processor.zig").TelnetProcessor;
</file>

<file path="server/broker/client_manager.zig">
//! Client Connection Pool for Broker/Chat Mode
//!
//! This module provides thread-safe management of multiple client connections for
//! ZigCat's broker and chat modes. It maintains a pool of active clients with
//! unique IDs and handles connection lifecycle management.
//!
//! ## Design Goals
//!
//! - **Thread Safety**: All operations are protected by mutex for concurrent access
//! - **Resource Management**: Automatic cleanup of client resources on removal
//! - **Unique IDs**: Each client gets a monotonically increasing unique identifier
//! - **Efficient Lookup**: HashMap-based storage for O(1) client access
//! - **Memory Safety**: Proper allocation/deallocation with arena allocators
//!
//! ## Usage Pattern
//!
//! ```zig
//! var pool = ClientPool.init(allocator);
//! defer pool.deinit();
//!
//! // Add new client
//! const client_id = try pool.addClient(connection);
//!
//! // Access client
//! if (pool.getClient(client_id)) |client| {
//!     // Use client...
//! }
//!
//! // Remove client (automatic cleanup)
//! pool.removeClient(client_id);
//! ```
//!
//! ## Thread Safety
//!
//! All public methods acquire the internal mutex, making the pool safe for
//! concurrent access from multiple threads (e.g., accept thread + I/O threads).

const std = @import("std");
const Connection = @import("../../net/connection.zig").Connection;

/// Statistics for a client connection
pub const ClientStatistics = struct {
    /// Client ID
    /// SECURITY FIX (2025-10-10): Changed from u32 to u64 to prevent overflow after 4.3B connections
    client_id: u64,
    /// Connection timestamp
    connect_time: i64,
    /// Last activity timestamp
    last_activity: i64,
    /// Total connection duration in seconds
    connection_duration: i64,
    /// Idle time in seconds
    idle_time: i64,
    /// Total bytes sent to client
    bytes_sent: u64,
    /// Total bytes received from client
    bytes_received: u64,
    /// Client nickname (chat mode only, caller owns memory)
    nickname: ?[]const u8,

    /// Free memory allocated for nickname
    pub fn deinit(self: *ClientStatistics, allocator: std.mem.Allocator) void {
        if (self.nickname) |nick| {
            allocator.free(nick);
            self.nickname = null;
        }
    }
};

/// Information about a connected client in broker/chat mode.
///
/// Contains all state needed to manage a client connection including
/// buffers, metadata, and chat-specific information.
pub const ClientInfo = struct {
    /// Unique client identifier (monotonically increasing)
    /// SECURITY FIX (2025-10-10): Changed from u32 to u64 to prevent overflow after 4.3B connections
    id: u64,

    /// Network connection (plain TCP or TLS)
    connection: Connection,

    /// Client nickname for chat mode (null for broker mode)
    nickname: ?[]const u8 = null,

    /// Timestamp of last activity (for timeout detection)
    last_activity: i64,

    /// Buffer for reading incoming data from client
    read_buffer: [4096]u8 = undefined,

    /// Dynamic buffer for outgoing data to client
    write_buffer: std.ArrayList(u8),

    /// Number of bytes currently in read buffer
    read_buffer_len: usize = 0,

    /// Client connection timestamp (for metrics/logging)
    connect_time: i64,

    /// Total bytes received from this client
    bytes_received: u64 = 0,

    /// Total bytes sent to this client
    bytes_sent: u64 = 0,

    /// Initialize a new ClientInfo with the given connection.
    ///
    /// ## Parameters
    /// - `allocator`: Memory allocator for dynamic buffers
    /// - `id`: Unique client identifier
    /// - `connection`: Network connection (takes ownership)
    ///
    /// ## Returns
    /// Initialized ClientInfo with current timestamp
    pub fn init(_: std.mem.Allocator, id: u64, connection: Connection) ClientInfo {
        const now = std.time.timestamp();
        return ClientInfo{
            .id = id,
            .connection = connection,
            .last_activity = now,
            .connect_time = now,
            .write_buffer = std.ArrayList(u8){},
        };
    }

    /// Clean up client resources and close connection.
    ///
    /// ## Parameters
    /// - `self`: Mutable reference to client info
    /// - `allocator`: Memory allocator used for dynamic buffers
    ///
    /// ## Behavior
    /// - Closes network connection
    /// - Frees nickname memory if allocated
    /// - Frees write buffer memory
    /// - Safe to call multiple times
    pub fn deinit(self: *ClientInfo, allocator: std.mem.Allocator) void {
        // Close network connection
        self.connection.close();

        // Free nickname if allocated
        if (self.nickname) |nick| {
            allocator.free(nick);
            self.nickname = null;
        }

        // Free write buffer
        self.write_buffer.deinit(allocator);
    }

    /// Update the last activity timestamp to current time.
    ///
    /// Should be called whenever data is received from or sent to the client.
    pub fn updateActivity(self: *ClientInfo) void {
        self.last_activity = std.time.timestamp();
    }

    /// Set the client's nickname (chat mode only).
    ///
    /// ## Parameters
    /// - `self`: Mutable reference to client info
    /// - `allocator`: Memory allocator for nickname storage
    /// - `new_nickname`: New nickname string (will be copied)
    ///
    /// ## Returns
    /// Error if memory allocation fails
    ///
    /// ## Behavior
    /// - Frees existing nickname if present
    /// - Allocates and copies new nickname
    /// - Updates activity timestamp
    pub fn setNickname(self: *ClientInfo, allocator: std.mem.Allocator, new_nickname: []const u8) !void {
        // Free existing nickname
        if (self.nickname) |old_nick| {
            allocator.free(old_nick);
        }

        // Allocate and copy new nickname
        self.nickname = try allocator.dupe(u8, new_nickname);
        self.updateActivity();
    }

    /// Check if client has been idle for longer than the specified timeout.
    ///
    /// ## Parameters
    /// - `self`: Const reference to client info
    /// - `timeout_seconds`: Idle timeout in seconds
    ///
    /// ## Returns
    /// True if client has been idle longer than timeout
    pub fn isIdle(self: *const ClientInfo, timeout_seconds: u32) bool {
        const now = std.time.timestamp();
        const idle_time = now - self.last_activity;
        return idle_time > timeout_seconds;
    }
};

/// Thread-safe pool for managing multiple client connections.
///
/// Provides concurrent access to client connections with unique IDs,
/// automatic resource management, and efficient lookup operations.
pub const ClientPool = struct {
    /// Memory allocator for client data structures
    allocator: std.mem.Allocator,

    /// HashMap storing active client connections by ID
    clients: std.AutoHashMap(u64, ClientInfo),

    /// Next client ID to assign (monotonically increasing)
    /// SECURITY FIX (2025-10-10): Changed from u32 to u64 to prevent overflow
    /// u32 wraps at 4,294,967,296 connections (reachable in long-running brokers)
    /// u64 wraps at 18,446,744,073,709,551,616 connections (practically infinite)
    next_id: u64 = 1,

    /// Mutex protecting concurrent access to the pool
    mutex: std.Thread.Mutex = .{},

    /// Initialize a new empty client pool.
    ///
    /// ## Parameters
    /// - `allocator`: Memory allocator for pool data structures
    ///
    /// ## Returns
    /// Initialized empty client pool
    pub fn init(allocator: std.mem.Allocator) ClientPool {
        return ClientPool{
            .allocator = allocator,
            .clients = std.AutoHashMap(u64, ClientInfo).init(allocator),
        };
    }

    /// Clean up all clients and free pool resources.
    ///
    /// ## Parameters
    /// - `self`: Mutable reference to client pool
    ///
    /// ## Behavior
    /// - Closes all client connections
    /// - Frees all client resources
    /// - Frees HashMap memory
    /// - Thread-safe (acquires mutex)
    pub fn deinit(self: *ClientPool) void {
        self.mutex.lock();
        defer self.mutex.unlock();

        // Clean up all clients
        var iterator = self.clients.iterator();
        while (iterator.next()) |entry| {
            entry.value_ptr.deinit(self.allocator);
        }

        // Free HashMap
        self.clients.deinit();
    }

    /// Add a new client to the pool.
    ///
    /// ## Parameters
    /// - `self`: Mutable reference to client pool
    /// - `connection`: Network connection (pool takes ownership)
    ///
    /// ## Returns
    /// Unique client ID for the new client
    ///
    /// ## Errors
    /// - `OutOfMemory`: If HashMap expansion fails
    ///
    /// ## Thread Safety
    /// This method is thread-safe and can be called concurrently.
    pub fn addClient(self: *ClientPool, connection: Connection) !u64 {
        self.mutex.lock();
        defer self.mutex.unlock();

        // Get unique ID and increment for next client
        const client_id = self.next_id;
        self.next_id += 1;

        // Create client info
        const client_info = ClientInfo.init(self.allocator, client_id, connection);

        // Add to HashMap
        try self.clients.put(client_id, client_info);

        return client_id;
    }

    /// Remove a client from the pool and clean up resources.
    ///
    /// ## Parameters
    /// - `self`: Mutable reference to client pool
    /// - `client_id`: ID of client to remove
    ///
    /// ## Behavior
    /// - Closes client connection (CRITICAL: closes socket FD)
    /// - Frees client resources (nickname, buffers)
    /// - Removes from HashMap
    /// - Safe to call with non-existent IDs (no-op)
    ///
    /// ## Thread Safety
    /// This method is thread-safe and can be called concurrently.
    ///
    /// ## Important
    /// This method closes the socket FD. Callers must remove the FD from any
    /// poll/select sets AFTER calling this to prevent use-after-free bugs.
    pub fn removeClient(self: *ClientPool, client_id: u64) void {
        self.mutex.lock();
        defer self.mutex.unlock();

        // Get client info and remove from HashMap
        if (self.clients.fetchRemove(client_id)) |kv| {
            var client_info = kv.value;
            // This closes the socket FD and frees all resources
            client_info.deinit(self.allocator);
        }
    }

    /// Get a reference to a client by ID.
    ///
    /// ## Parameters
    /// - `self`: Mutable reference to client pool
    /// - `client_id`: ID of client to retrieve
    ///
    /// ## Returns
    /// Pointer to ClientInfo if found, null otherwise
    ///
    /// ## Thread Safety
    /// This method is thread-safe. The returned pointer is valid only
    /// while the mutex is held by the calling thread.
    ///
    /// ## Warning
    /// The returned pointer becomes invalid if another thread modifies
    /// the pool (adds/removes clients). Use with caution in multi-threaded code.
    pub fn getClient(self: *ClientPool, client_id: u64) ?*ClientInfo {
        self.mutex.lock();
        defer self.mutex.unlock();

        return self.clients.getPtr(client_id);
    }

    /// Get a list of all active client IDs.
    ///
    /// ## Parameters
    /// - `self`: Mutable reference to client pool
    /// - `allocator`: Allocator for the returned array
    ///
    /// ## Returns
    /// Array of client IDs (caller owns memory)
    ///
    /// ## Errors
    /// - `OutOfMemory`: If array allocation fails
    ///
    /// ## Thread Safety
    /// This method is thread-safe and returns a snapshot of current client IDs.
    pub fn getAllClientIds(self: *ClientPool, allocator: std.mem.Allocator) ![]u64 {
        self.mutex.lock();
        defer self.mutex.unlock();

        // Allocate array for client IDs
        const client_ids = try allocator.alloc(u64, self.clients.count());

        // Copy client IDs
        var i: usize = 0;
        var iterator = self.clients.iterator();
        while (iterator.next()) |entry| {
            client_ids[i] = entry.key_ptr.*;
            i += 1;
        }

        return client_ids;
    }

    /// Get the current number of active clients.
    ///
    /// ## Parameters
    /// - `self`: Const reference to client pool
    ///
    /// ## Returns
    /// Number of clients currently in the pool
    ///
    /// ## Thread Safety
    /// This method is thread-safe and returns a snapshot of the current count.
    pub fn getClientCount(self: *const ClientPool) usize {
        // Note: We need to cast away const to acquire mutex
        // This is safe because we're only reading the count
        const self_mut = @constCast(self);
        self_mut.mutex.lock();
        defer self_mut.mutex.unlock();

        return self_mut.clients.count();
    }

    /// Remove all idle clients that exceed the specified timeout.
    ///
    /// ## Parameters
    /// - `self`: Mutable reference to client pool
    /// - `timeout_seconds`: Idle timeout in seconds
    ///
    /// ## Returns
    /// Number of clients removed due to timeout
    ///
    /// ## Thread Safety
    /// This method is thread-safe and can be called concurrently.
    pub fn removeIdleClients(self: *ClientPool, timeout_seconds: u32) usize {
        self.mutex.lock();
        defer self.mutex.unlock();

        var removed_count: usize = 0;
        var clients_to_remove = std.ArrayList(u64){};
        defer clients_to_remove.deinit(self.allocator);

        // Find idle clients
        var iterator = self.clients.iterator();
        while (iterator.next()) |entry| {
            if (entry.value_ptr.isIdle(timeout_seconds)) {
                clients_to_remove.append(self.allocator, entry.key_ptr.*) catch continue;
            }
        }

        // Remove idle clients
        for (clients_to_remove.items) |client_id| {
            if (self.clients.fetchRemove(client_id)) |kv| {
                var client_info = kv.value;
                client_info.deinit(self.allocator);
                removed_count += 1;
            }
        }

        return removed_count;
    }

    /// Remove clients that have failed connection health checks.
    ///
    /// ## Parameters
    /// - `self`: Mutable reference to client pool
    /// - `failed_client_ids`: Array of client IDs that have failed health checks
    ///
    /// ## Returns
    /// Number of clients actually removed
    ///
    /// ## Thread Safety
    /// This method is thread-safe and can be called concurrently.
    pub fn removeFailedClients(self: *ClientPool, failed_client_ids: []const u64) usize {
        self.mutex.lock();
        defer self.mutex.unlock();

        var removed_count: usize = 0;

        for (failed_client_ids) |client_id| {
            if (self.clients.fetchRemove(client_id)) |kv| {
                var client_info = kv.value;
                client_info.deinit(self.allocator);
                removed_count += 1;
            }
        }

        return removed_count;
    }

    /// Get statistics for all clients in the pool.
    ///
    /// ## Parameters
    /// - `self`: Mutable reference to client pool
    /// - `allocator`: Allocator for the returned statistics array
    ///
    /// ## Returns
    /// Array of client statistics (caller owns memory)
    ///
    /// ## Thread Safety
    /// This method is thread-safe and returns a snapshot of current statistics.
    pub fn getClientStatistics(self: *ClientPool, allocator: std.mem.Allocator) ![]ClientStatistics {
        self.mutex.lock();
        defer self.mutex.unlock();

        const stats = try allocator.alloc(ClientStatistics, self.clients.count());
        var i: usize = 0;

        var iterator = self.clients.iterator();
        while (iterator.next()) |entry| {
            const client = entry.value_ptr;
            const now = std.time.timestamp();

            stats[i] = ClientStatistics{
                .client_id = client.id,
                .connect_time = client.connect_time,
                .last_activity = client.last_activity,
                .connection_duration = now - client.connect_time,
                .idle_time = now - client.last_activity,
                .bytes_sent = client.bytes_sent,
                .bytes_received = client.bytes_received,
                .nickname = if (client.nickname) |nick| try allocator.dupe(u8, nick) else null,
            };
            i += 1;
        }

        return stats;
    }

    /// Execute a function for each client in the pool.
    ///
    /// ## Parameters
    /// - `self`: Mutable reference to client pool
    /// - `context`: User context passed to callback function
    /// - `callback`: Function to call for each client
    ///
    /// ## Callback Signature
    /// `fn(context: anytype, client_id: u32, client: *ClientInfo) void`
    ///
    /// ## Thread Safety
    /// This method is thread-safe. The callback is called while holding
    /// the pool mutex, so clients cannot be added/removed during iteration.
    pub fn forEachClient(self: *ClientPool, context: anytype, callback: fn (@TypeOf(context), u64, *ClientInfo) void) void {
        self.mutex.lock();
        defer self.mutex.unlock();

        var iterator = self.clients.iterator();
        while (iterator.next()) |entry| {
            callback(context, entry.key_ptr.*, entry.value_ptr);
        }
    }
};

// Tests for ClientPool functionality
test "ClientPool basic operations" {
    const testing = std.testing;
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    // Create a mock connection for testing
    // Use platform-safe invalid descriptor (-1) instead of fd 0 (STDIN)
    const mock_socket: std.posix.socket_t = @bitCast(@as(i32, -1));
    const mock_connection = Connection.fromSocket(mock_socket);

    var pool = ClientPool.init(allocator);
    defer pool.deinit();

    // Test empty pool
    try testing.expect(pool.getClientCount() == 0);
    try testing.expect(pool.getClient(1) == null);

    // Test adding client
    const client_id = try pool.addClient(mock_connection);
    try testing.expect(client_id == 1);
    try testing.expect(pool.getClientCount() == 1);

    // Test getting client
    const client = pool.getClient(client_id);
    try testing.expect(client != null);
    try testing.expect(client.?.id == client_id);

    // Manually clear the pool before deinit to avoid closing invalid fd
    // NOTE: This is a workaround for testing with mock fds.
    // Real usage with valid sockets works correctly.
    pool.mutex.lock();
    pool.clients.clearRetainingCapacity();
    pool.mutex.unlock();
}

// REMOVED: ClientPool multiple clients test
// This test triggers a Zig 0.15.1 test runner bug (BrokenPipe in server.receiveMessage())
// Even with `return error.SkipZigTest`, the test structure crashes the test harness
// Multi-client functionality is validated through integration tests instead
// See: tests/multi_client_integration_test.zig

test "ClientInfo nickname management" {
    const testing = std.testing;
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    // Use platform-safe invalid descriptor (-1) instead of fd 0 (STDIN)
    // to avoid crashes when test runner uses stdin
    const mock_socket: std.posix.socket_t = @bitCast(@as(i32, -1));
    const mock_connection = Connection.fromSocket(mock_socket);

    var client = ClientInfo.init(allocator, 1, mock_connection);

    // Test initial state
    try testing.expect(client.nickname == null);

    // Test setting nickname
    try client.setNickname(allocator, "testuser");
    try testing.expect(client.nickname != null);
    try testing.expectEqualStrings("testuser", client.nickname.?);

    // Test changing nickname
    try client.setNickname(allocator, "newname");
    try testing.expectEqualStrings("newname", client.nickname.?);

    // Manually clean up without closing socket (avoid crash with invalid fd)
    if (client.nickname) |nick| {
        allocator.free(nick);
    }
    client.write_buffer.deinit(allocator);
}

test "ClientInfo idle detection" {
    const testing = std.testing;
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    // Use platform-safe invalid descriptor (-1) instead of fd 0 (STDIN)
    const mock_socket: std.posix.socket_t = @bitCast(@as(i32, -1));
    const mock_connection = Connection.fromSocket(mock_socket);

    var client = ClientInfo.init(allocator, 1, mock_connection);

    // Test not idle initially
    try testing.expect(!client.isIdle(1));

    // Simulate old activity by manually setting timestamp
    client.last_activity = std.time.timestamp() - 10; // 10 seconds ago

    // Test idle detection
    try testing.expect(client.isIdle(5)); // 5 second timeout
    try testing.expect(!client.isIdle(15)); // 15 second timeout

    // Manually clean up without closing socket
    if (client.nickname) |nick| {
        allocator.free(nick);
    }
    client.write_buffer.deinit(allocator);
}

// REMOVED: ClientPool failed client removal test
// This test requires calling removeFailedClients() which internally calls
// client.deinit() -> connection.close() on the mock invalid fd (-1),
// causing a crash. The function is validated through integration tests with real sockets.
// See: tests/multi_client_integration_test.zig

test "ClientPool statistics" {
    const testing = std.testing;
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    var pool = ClientPool.init(allocator);
    defer pool.deinit();

    // Add a client
    // Use platform-safe invalid descriptor (-1) instead of fd 0 (STDIN)
    const mock_socket: std.posix.socket_t = @bitCast(@as(i32, -1));
    const mock_connection = Connection.fromSocket(mock_socket);
    const client_id = try pool.addClient(mock_connection);

    // Set some statistics
    if (pool.getClient(client_id)) |client| {
        client.bytes_sent = 100;
        client.bytes_received = 200;
        try client.setNickname(allocator, "testuser");
    }

    // Get statistics
    const stats = try pool.getClientStatistics(allocator);
    defer {
        for (stats) |*stat| {
            stat.deinit(allocator);
        }
        allocator.free(stats);
    }

    try testing.expect(stats.len == 1);
    try testing.expect(stats[0].client_id == client_id);
    try testing.expect(stats[0].bytes_sent == 100);
    try testing.expect(stats[0].bytes_received == 200);
    try testing.expect(stats[0].nickname != null);
    try testing.expectEqualStrings("testuser", stats[0].nickname.?);

    // Manually clean up to avoid closing invalid fd
    pool.mutex.lock();
    var iterator = pool.clients.iterator();
    while (iterator.next()) |entry| {
        if (entry.value_ptr.nickname) |nick| {
            allocator.free(nick);
        }
        entry.value_ptr.write_buffer.deinit(allocator);
    }
    pool.clients.clearRetainingCapacity();
    pool.mutex.unlock();
}
</file>

<file path="server/broker/message_handler.zig">
const std = @import("std");
const broker = @import("../broker.zig");
const ClientPool = @import("client_manager.zig").ClientPool;
const logging = @import("../../util/logging.zig");

pub fn handleClientData(self: *broker.BrokerServer, client_id: u32) !void {
    const client = self.clients.getClient(client_id) orelse return broker.BrokerError.ClientNotFound;

    if (client.read_buffer_len >= client.read_buffer.len) {
        const error_msg = "ERROR: Line too long (max 4096 bytes)\r\n";
        _ = client.connection.write(error_msg) catch {};
        logging.logWarning("Client {}: Message exceeds buffer size, closing connection\n", .{client_id});
        return error.MessageTooLong;
    }

    if (self.config.idle_timeout > 0) {
        const idle_seconds = self.config.idle_timeout / 1000;
        if (client.isIdle(@intCast(idle_seconds))) {
            logging.logDebug("Client {} idle timeout ({}s), disconnecting\n", .{ client_id, idle_seconds });
            return broker.BrokerError.ClientSocketError;
        }
    }

    const bytes_read = client.connection.read(client.read_buffer[client.read_buffer_len..]) catch |err| {
        logging.logDebug("Client {} read error: {}\n", .{ client_id, err });
        switch (err) {
            error.WouldBlock => {
                logging.logTrace("Client {} read would block (non-blocking I/O)\n", .{client_id});
                return;
            },
            error.ConnectionResetByPeer => {
                logging.logDebug("Client {} connection reset by peer\n", .{client_id});
            },
            else => {
                logging.logError(err, "client read");
            },
        }
        return broker.BrokerError.ClientSocketError;
    };

    if (bytes_read == 0) {
        logging.logDebug("Client {} sent EOF (graceful disconnect)\n", .{client_id});
        return broker.BrokerError.ClientSocketError;
    }

    client.updateActivity();
    client.bytes_received += bytes_read;
    client.read_buffer_len += bytes_read;

    logging.logDebug("Client {} sent {} bytes (total received: {}\n", .{ client_id, bytes_read, client.bytes_received });

    if (self.config.verbose_level >= 3) {
        const received_data = client.read_buffer[client.read_buffer_len - bytes_read .. client.read_buffer_len];
        logging.logHexDump(received_data, "Client Data");
    }

    switch (self.mode) {
        .broker => {
            const data = client.read_buffer[0..client.read_buffer_len];
            logging.logTrace("Broker mode: relaying {} bytes from client {}\n", .{ data.len, client_id });
            try self.relayToClients(data, client_id);
            client.read_buffer_len = 0;
        },
        .chat => {
            logging.logTrace("Chat mode: processing {} bytes from client {}\n", .{ bytes_read, client_id });
            try processChatData(self, client_id);
        },
    }
}

pub fn processChatData(self: *broker.BrokerServer, client_id: u32) !void {
    const client = self.clients.getClient(client_id) orelse return broker.BrokerError.ClientNotFound;

    var start: usize = 0;
    var lines_processed: usize = 0;

    while (start < client.read_buffer_len) {
        if (lines_processed >= broker.MAX_LINES_PER_TICK) {
            if (self.config.verbose) {
                logging.logDebug("Client {} hit line limit ({} lines), deferring remaining work to next tick\n", .{ client_id, broker.MAX_LINES_PER_TICK });
            }
            break;
        }

        const line_end = std.mem.indexOfScalarPos(u8, client.read_buffer[0..client.read_buffer_len], start, '\n');
        if (line_end == null) {
            break;
        }

        const end = line_end.?;
        var line = client.read_buffer[start..end];

        if (line.len > 0 and line[line.len - 1] == '\r') {
            line = line[0 .. line.len - 1];
        }

        try processChatLine(self, client_id, line);

        start = end + 1;

        lines_processed += 1;
    }

    if (start > 0) {
        const remaining = client.read_buffer_len - start;
        if (remaining > 0) {
            std.mem.copyForwards(u8, client.read_buffer[0..remaining], client.read_buffer[start..client.read_buffer_len]);
        }
        client.read_buffer_len = remaining;
    }

    if (client.read_buffer_len >= client.read_buffer.len) {
        const error_msg = "ERROR: Line too long (max 4096 bytes)\r\n";
        _ = client.connection.write(error_msg) catch {};
        logging.logWarning("Client {}: Chat message exceeds buffer size, closing connection\n", .{client_id});
        return error.MessageTooLong;
    }
}

pub fn processChatLine(self: *broker.BrokerServer, client_id: u32, line: []const u8) !void {
    const client = self.clients.getClient(client_id) orelse return broker.BrokerError.ClientNotFound;

    if (client.nickname == null) {
        const trimmed_nick = std.mem.trim(u8, line, " \t");

        logging.logTrace("Client {} attempting to set nickname: '{s}'\n", .{ client_id, trimmed_nick });

        if (trimmed_nick.len == 0) {
            const prompt = "Please enter a valid nickname: ";
            const bytes_sent = client.connection.write(prompt) catch |err| {
                logging.logError(err, "nickname prompt");
                return;
            };
            client.bytes_sent += bytes_sent;
            logging.logTrace("Sent nickname prompt to client {} ({} bytes)\n", .{ client_id, bytes_sent });
            return;
        }

        if (trimmed_nick.len > self.config.chat_max_nickname_len) {
            const error_msg = try std.fmt.allocPrint(self.allocator, "*** Nickname too long (max {} characters), please try again\n", .{self.config.chat_max_nickname_len});
            defer self.allocator.free(error_msg);

            const bytes_sent = client.connection.write(error_msg) catch |err| {
                logging.logError(err, "nickname length error");
                return;
            };
            client.bytes_sent += bytes_sent;
            logging.logDebug("Client {} nickname too long: '{}' chars\n", .{ client_id, trimmed_nick.len });
            return;
        }

        if (self.isChatNicknameTaken(trimmed_nick, client_id)) {
            const error_msg = "*** Nickname already taken, please choose another\n";
            const bytes_sent = client.connection.write(error_msg) catch |err| {
                logging.logError(err, "nickname taken message");
                return;
            };
            client.bytes_sent += bytes_sent;
            logging.logDebug("Client {} attempted duplicate nickname '{}'\n", .{ client_id, trimmed_nick });
            return;
        }

        self.registerChatNickname(trimmed_nick, client_id) catch |err| {
            const error_msg = "*** Failed to set nickname, please try again\n";
            const bytes_sent = client.connection.write(error_msg) catch |write_err| {
                logging.logError(write_err, "nickname registry error message");
                return;
            };
            client.bytes_sent += bytes_sent;
            logging.logError(err, "register nickname");
            return;
        };

        client.setNickname(self.allocator, trimmed_nick) catch |err| {
            self.unregisterChatNickname(trimmed_nick);
            const error_msg = "*** Failed to set nickname, please try again\n";
            const bytes_sent = client.connection.write(error_msg) catch |write_err| {
                logging.logError(write_err, "nickname error message");
                return;
            };
            client.bytes_sent += bytes_sent;
            logging.logError(err, "set nickname");
            return;
        };

        const confirm_msg = try std.fmt.allocPrint(self.allocator, "*** You are now known as {s}\n", .{trimmed_nick});
        defer self.allocator.free(confirm_msg);

        const bytes_sent = client.connection.write(confirm_msg) catch |err| {
            logging.logError(err, "nickname confirmation");
            return;
        };
        client.bytes_sent += bytes_sent;

        const join_msg = try std.fmt.allocPrint(self.allocator, "*** {s} joined the chat\n", .{trimmed_nick});
        defer self.allocator.free(join_msg);

        try self.relayToClients(join_msg, client_id);

        logging.log(1, "Client {} set nickname: {s}\n", .{ client_id, trimmed_nick });
        logging.logTrace("Nickname confirmation sent to client {} ({} bytes)\n", .{ client_id, bytes_sent });
        logging.logDebug("Relayed join announcement for {s} to other clients\n", .{trimmed_nick});
    } else {
        if (line.len == 0) {
            logging.logTrace("Client {} sent empty message, ignoring\n", .{client_id});
            return;
        }

        if (line.len > self.config.chat_max_message_len) {
            const error_msg = try std.fmt.allocPrint(self.allocator, "*** Message too long (max {} characters)\n", .{self.config.chat_max_message_len});
            defer self.allocator.free(error_msg);

            const bytes_sent = client.connection.write(error_msg) catch |err| {
                logging.logError(err, "message length error");
                return;
            };
            client.bytes_sent += bytes_sent;
            logging.logDebug("Client {} message too long: {} chars\n", .{ client_id, line.len });
            return;
        }

        const formatted_msg = try std.fmt.allocPrint(
            self.allocator,
            "[{s}] {s}\n",
            .{ client.nickname.?, line },
        );
        defer self.allocator.free(formatted_msg);

        try self.relayToClients(formatted_msg, client_id);

        logging.logDebug("Chat message from {s}: {s}\n", .{ client.nickname.?, line });
        logging.logTrace("Relayed {}-byte message from client {}\n", .{ formatted_msg.len, client_id });
    }
}
</file>

<file path="server/broker/protocols.zig">
const std = @import("std");
const broker = @import("../broker.zig");
const logging = @import("../../util/logging.zig");

pub fn initializeChatClient(self: *broker.BrokerServer, client_id: u32) !void {
    const client = self.clients.getClient(client_id) orelse return broker.BrokerError.ClientNotFound;

    const welcome_msg = "Welcome to ZigCat chat! Please enter your nickname: ";
    const bytes_sent = client.connection.write(welcome_msg) catch |err| {
        logging.logError(err, "chat welcome message");
        return broker.BrokerError.ClientSocketError;
    };

    client.bytes_sent += bytes_sent;
    client.updateActivity();

    logging.logDebug("Sent welcome message to client {} ({} bytes)\n", .{ client_id, bytes_sent });
    logging.logTrace("Chat client {} initialized, awaiting nickname\n", .{client_id});
}
</file>

<file path="server/broker.zig">
//! Core Broker Server Module with I/O Multiplexing
//!
//! This module implements the central broker server that manages multiple client
//! connections and provides data relay functionality for both broker and chat modes.
//!
//! ## Design Goals
//!
//! - **I/O Multiplexing**: Non-blocking I/O using poll() for efficient multi-client handling
//! - **Event-Driven**: Main event loop processes accept, read, and write events
//! - **Per-Client Isolation**: Client errors don't affect other clients
//! - **Resource Management**: Automatic cleanup of failed/disconnected clients
//! - **Integration**: Works with existing listen socket and access control
//!
//! ## Architecture
//!
//! ```
//!         
//!    Listen               Broker                Client        
//!    Socket           Server            Pool          
//!                         (Event Loop)                        
//!         
//!                                                        
//!                                                        
//!         
//!    Accept               I/O                   Message       
//!    New Clients          Multiplexing          Relay         
//!                         (poll/select)         Engine        
//!         
//! ```
//!
//! ## Event Loop
//!
//! 1. **Poll Events**: Wait for I/O events on listen socket and client sockets
//! 2. **Accept**: Handle new client connections with access control
//! 3. **Read**: Process incoming data from clients
//! 4. **Relay**: Distribute data to other clients (excluding sender)
//! 5. **Cleanup**: Remove failed/disconnected clients
//!
//! ## Thread Safety
//!
//! The broker server runs in a single thread with event-driven I/O multiplexing.
//! The client pool provides thread-safe operations for potential future multi-threading.

const std = @import("std");
const builtin = @import("builtin");
const Connection = @import("../net/connection.zig").Connection;
const ClientPool = @import("broker/client_manager.zig").ClientPool;
const BufferPool = @import("buffer_pool.zig").BufferPool;
const BufferPoolConfig = @import("buffer_pool.zig").BufferPoolConfig;
const FlowControlManager = @import("flow_control.zig").FlowControlManager;
const FlowControlConfig = @import("flow_control.zig").FlowControlConfig;
const PerformanceMonitor = @import("performance_monitor.zig").PerformanceMonitor;
const PerformanceConfig = @import("performance_monitor.zig").PerformanceConfig;
const allowlist = @import("../net/allowlist.zig");
const Config = @import("../config.zig").Config;
const tls = @import("../tls/tls.zig");
const logging = @import("../util/logging.zig");
const message_handler = @import("broker/message_handler.zig");
const protocols = @import("broker/protocols.zig");
const main_common = @import("../main/common.zig");

/// Broker operation modes
pub const BrokerMode = enum {
    /// Raw data relay mode - forwards all data as-is
    broker,
    /// Line-oriented chat mode with nicknames and formatting
    chat,
};

/// Broker server errors
pub const BrokerError = error{
    /// Maximum number of clients reached
    MaxClientsReached,
    /// Client not found in pool
    ClientNotFound,
    /// Failed to relay data to clients
    RelayFailed,
    /// I/O multiplexing error (poll/select failed)
    MultiplexingError,
    /// Listen socket error
    ListenSocketError,
    /// Client socket error
    ClientSocketError,
    /// Memory allocation error
    OutOfMemory,
    /// Configuration error
    InvalidConfiguration,
    /// Message exceeds maximum buffer size
    MessageTooLong,
};

/// DoS Protection: Maximum lines to process per poll tick
/// Prevents unbounded message processing that can freeze the server
/// with rapid message flooding (e.g., 5000 newlines causing 41-second freeze).
/// Remaining lines stay buffered for next poll event.
const MAX_LINES_PER_TICK: usize = 100;

/// Poll context for I/O multiplexing
const PollContext = struct {
    /// Listen socket poll descriptor
    listen_fd: std.posix.pollfd,
    /// Client socket poll descriptors
    client_fds: std.ArrayList(std.posix.pollfd),
    /// Mapping from socket descriptor to client ID
    client_id_map: std.AutoHashMap(std.posix.socket_t, u32),
    /// Persistent cache for poll array (optimization to avoid repeated allocations)
    /// This cache is reused across poll() calls, only reallocating when growing
    poll_fds_cache: std.ArrayList(std.posix.pollfd),
    /// Allocator for dynamic arrays
    allocator: std.mem.Allocator,

    /// Initialize poll context with listen socket
    pub fn init(allocator: std.mem.Allocator, listen_socket: std.posix.socket_t) PollContext {
        return PollContext{
            .listen_fd = std.posix.pollfd{
                .fd = listen_socket,
                .events = std.posix.POLL.IN,
                .revents = 0,
            },
            .client_fds = std.ArrayList(std.posix.pollfd){},
            .client_id_map = std.AutoHashMap(std.posix.socket_t, u32).init(allocator),
            .poll_fds_cache = std.ArrayList(std.posix.pollfd){},
            .allocator = allocator,
        };
    }

    /// Clean up poll context resources
    pub fn deinit(self: *PollContext) void {
        self.client_fds.deinit(self.allocator);
        self.client_id_map.deinit();
        self.poll_fds_cache.deinit(self.allocator);
    }

    /// Add a client socket to the poll set
    pub fn addClient(self: *PollContext, socket: std.posix.socket_t, client_id: u32) !void {
        // Add to poll descriptor list
        try self.client_fds.append(self.allocator, std.posix.pollfd{
            .fd = socket,
            .events = std.posix.POLL.IN,
            .revents = 0,
        });

        // Add to socket-to-ID mapping
        try self.client_id_map.put(socket, client_id);
    }

    /// Update poll events for a client socket (add/remove POLL.OUT)
    pub fn updateClientEvents(self: *PollContext, socket: std.posix.socket_t, enable_write: bool) void {
        for (self.client_fds.items) |*client_fd| {
            if (client_fd.fd == socket) {
                if (enable_write) {
                    // Enable both read and write events
                    client_fd.events = std.posix.POLL.IN | std.posix.POLL.OUT;
                } else {
                    // Only read events (default)
                    client_fd.events = std.posix.POLL.IN;
                }
                return;
            }
        }
    }

    /// Remove a client socket from the poll set
    pub fn removeClient(self: *PollContext, socket: std.posix.socket_t) void {
        // Remove from socket-to-ID mapping
        _ = self.client_id_map.remove(socket);

        // Remove from poll descriptor list
        var i: usize = 0;
        while (i < self.client_fds.items.len) {
            if (self.client_fds.items[i].fd == socket) {
                _ = self.client_fds.swapRemove(i);
                break;
            }
            i += 1;
        }
    }

    /// Perform poll operation on all sockets
    /// OPTIMIZATION: Uses persistent cache to avoid allocating new poll array on every iteration
    /// This reduces CPU overhead by 5-10% at high connection rates (10K-20K polls/second)
    pub fn poll(self: *PollContext, timeout_ms: i32) !i32 {
        // Create combined poll array: [listen_fd, ...client_fds]
        const total_fds = 1 + self.client_fds.items.len;

        // Reuse cache - only reallocates if growing beyond current capacity
        try self.poll_fds_cache.resize(self.allocator, total_fds);
        const poll_fds = self.poll_fds_cache.items;

        // Add listen socket
        poll_fds[0] = self.listen_fd;

        // Add client sockets
        for (self.client_fds.items, 0..) |client_fd, i| {
            poll_fds[i + 1] = client_fd;
        }

        // Perform poll operation
        const result = std.posix.poll(poll_fds, timeout_ms) catch {
            return BrokerError.MultiplexingError;
        };

        // Update revents in our structures
        self.listen_fd.revents = poll_fds[0].revents;
        for (self.client_fds.items, 0..) |*client_fd, i| {
            client_fd.revents = poll_fds[i + 1].revents;
        }

        return @intCast(result);
    }

    /// Get client ID from socket descriptor
    pub fn getClientId(self: *PollContext, socket: std.posix.socket_t) ?u32 {
        return self.client_id_map.get(socket);
    }
};

/// Core broker server managing multiple client connections
pub const BrokerServer = struct {
    /// Memory allocator
    allocator: std.mem.Allocator,
    /// Listen socket for accepting new connections
    listen_socket: std.posix.socket_t,
    /// Client connection pool
    clients: ClientPool,
    /// Buffer pool for efficient memory management
    buffer_pool: BufferPool,
    /// Flow control manager for resource management
    flow_control: FlowControlManager,
    /// Performance monitor for metrics and optimization
    performance_monitor: PerformanceMonitor,
    /// Broker operation mode
    mode: BrokerMode,
    /// Configuration reference
    config: *const Config,
    /// Access control list
    access_list: *allowlist.AccessList,
    /// I/O multiplexing context
    poll_context: PollContext,
    /// Server running flag
    running: bool = false,
    /// Maximum number of clients allowed
    max_clients: u32,
    /// Active nicknames for chat mode duplicate detection
    chat_nicknames: std.StringHashMap(u32),

    /// Initialize broker server
    ///
    /// ## Parameters
    /// - `allocator`: Memory allocator for server resources
    /// - `listen_socket`: Pre-configured listen socket
    /// - `mode`: Broker operation mode (broker or chat)
    /// - `config`: Configuration reference
    /// - `access_list`: Access control list for client filtering
    ///
    /// ## Returns
    /// Initialized broker server ready to run
    pub fn init(
        allocator: std.mem.Allocator,
        listen_socket: std.posix.socket_t,
        mode: BrokerMode,
        config: *const Config,
        access_list: *allowlist.AccessList,
    ) !BrokerServer {
        // Configure buffer pool based on expected load
        const buffer_config = BufferPoolConfig{
            .buffer_size = 4096,
            .initial_pool_size = 32,
            .max_pool_size = @min(config.max_clients * 4, 512), // 4 buffers per client, max 512
            .max_memory_usage = 32 * 1024 * 1024, // 32MB default
            .flow_control_threshold = 0.8,
            .cleanup_threshold = 0.9,
        };

        // Configure flow control based on system resources
        const flow_config = FlowControlConfig{
            .max_memory_usage = buffer_config.max_memory_usage,
            .flow_control_threshold = 0.75,
            .throttle_threshold = 0.85,
            .emergency_threshold = 0.95,
            .max_bytes_per_second_per_client = 1024 * 1024, // 1MB/s per client
            .max_pending_bytes_per_client = 64 * 1024, // 64KB pending
            .adaptive_flow_control = true,
        };

        // Configure performance monitoring
        const perf_config = PerformanceConfig{
            .monitoring_interval_ms = 1000,
            .history_size = 300, // 5 minutes of history
            .enable_memory_monitoring = true,
            .enable_cpu_monitoring = true,
            .enable_network_monitoring = true,
            .memory_alert_threshold = 85.0,
            .cpu_alert_threshold = 90.0,
        };

        return BrokerServer{
            .allocator = allocator,
            .listen_socket = listen_socket,
            .clients = ClientPool.init(allocator),
            .buffer_pool = try BufferPool.init(allocator, buffer_config),
            .flow_control = FlowControlManager.init(allocator, flow_config),
            .performance_monitor = try PerformanceMonitor.init(allocator, perf_config),
            .mode = mode,
            .config = config,
            .access_list = access_list,
            .poll_context = PollContext.init(allocator, listen_socket),
            .max_clients = if (config.max_conns > 0) config.max_conns else 50, // Default to 50 clients
            .chat_nicknames = std.StringHashMap(u32).init(allocator),
        };
    }

    /// Clean up broker server resources
    pub fn deinit(self: *BrokerServer) void {
        self.clearChatNicknames();
        self.chat_nicknames.deinit();
        self.clients.deinit();
        self.buffer_pool.deinit();
        self.flow_control.deinit();
        self.performance_monitor.deinit();
        self.poll_context.deinit();
    }

    /// Main broker server event loop with enhanced logging and timeout handling
    ///
    /// Runs the main event loop that:
    /// 1. Polls for I/O events on all sockets
    /// 2. Accepts new client connections
    /// 3. Reads data from clients
    /// 4. Relays data to other clients
    /// 5. Handles client disconnections
    ///
    /// ## Returns
    /// Error if server cannot continue operation
    pub fn run(self: *BrokerServer) !void {
        self.running = true;

        // Set logging verbosity from config
        logging.setVerbosity(self.config.verbose_level);

        // Log server startup with comprehensive information
        logging.log(1, "Broker server starting in {any} mode (max {} clients, TLS: {}, Access control: {})\n", .{ self.mode, self.max_clients, self.config.ssl, self.access_list.allow_rules.items.len > 0 or self.access_list.deny_rules.items.len > 0 });

        logging.logDebug("Server configuration: connect_timeout={}ms, idle_timeout={}ms\n", .{
            self.config.connect_timeout,
            self.config.idle_timeout,
        });

        while (self.running and !main_common.shutdown_requested.load(.seq_cst)) {
            // Update performance monitoring
            self.performance_monitor.update();

            // Update flow control with current resource usage
            const memory_info = self.buffer_pool.getMemoryInfo();
            self.flow_control.updateResourceInfo(memory_info.current_usage);

            // Calculate poll timeout based on configuration and flow control
            var poll_timeout_ms = if (self.config.idle_timeout > 0)
                @min(1000, self.config.idle_timeout / 2) // Check for idle clients more frequently
            else
                1000; // Default 1 second timeout

            // Reduce timeout under high load for more responsive flow control
            const flow_level = self.flow_control.getCurrentLevel();
            poll_timeout_ms = switch (flow_level) {
                .normal => poll_timeout_ms,
                .light => @min(poll_timeout_ms, 500),
                .moderate => @min(poll_timeout_ms, 250),
                .heavy => @min(poll_timeout_ms, 100),
                .emergency => @min(poll_timeout_ms, 50),
            };

            // Poll for I/O events
            const events = self.poll_context.poll(@intCast(poll_timeout_ms)) catch |err| {
                logging.logError(err, "poll");
                logging.logDebug("Poll error, continuing: {}\n", .{err});
                self.performance_monitor.recordError();
                continue;
            };

            if (events == 0) {
                // Timeout - perform maintenance tasks
                logging.logTrace("Poll timeout, performing maintenance (flow level: {})\n", .{flow_level});
                self.performMaintenance();
                continue;
            }

            logging.logTrace("Poll returned {} events\n", .{events});

            // Check for new client connections
            if (self.poll_context.listen_fd.revents & std.posix.POLL.IN != 0) {
                logging.logTrace("New client connection available\n", .{});
                self.acceptNewClient() catch |err| {
                    logging.logError(err, "accept");
                    logging.logDebug("Accept error: {}\n", .{err});
                };
            }

            // Check for client data and connection events
            for (self.poll_context.client_fds.items) |client_fd| {
                if (client_fd.revents & std.posix.POLL.IN != 0) {
                    if (self.poll_context.getClientId(client_fd.fd)) |client_id| {
                        logging.logTrace("Data available from client {}\n", .{client_id});
                        message_handler.handleClientData(self, client_id) catch |err| {
                            logging.logError(err, "client data handling");
                            logging.logDebug("Client {} data error: {}\n", .{ client_id, err });
                            // Remove problematic client
                            self.removeClient(client_id);
                        };
                    }
                }

                // Check for client disconnection or errors
                if (client_fd.revents & (std.posix.POLL.HUP | std.posix.POLL.ERR | std.posix.POLL.NVAL) != 0) {
                    if (self.poll_context.getClientId(client_fd.fd)) |client_id| {
                        // Log the specific type of disconnection with enhanced detail
                        const event_type = if (client_fd.revents & std.posix.POLL.HUP != 0)
                            "hangup"
                        else if (client_fd.revents & std.posix.POLL.ERR != 0)
                            "error"
                        else
                            "invalid";

                        logging.logDebug("Client {} disconnected ({s})\n", .{ client_id, event_type });
                        logging.logTrace("Client {} poll events: HUP={}, ERR={}, NVAL={}\n", .{
                            client_id,
                            client_fd.revents & std.posix.POLL.HUP != 0,
                            client_fd.revents & std.posix.POLL.ERR != 0,
                            client_fd.revents & std.posix.POLL.NVAL != 0,
                        });

                        self.removeClient(client_id);
                    }
                }

                // Check for write readiness (for clients with pending data)
                if (client_fd.revents & std.posix.POLL.OUT != 0) {
                    if (self.poll_context.getClientId(client_fd.fd)) |client_id| {
                        logging.logTrace("Client {} ready for write\n", .{client_id});
                        self.flushWriteBuffer(client_id) catch |err| {
                            logging.logError(err, "write buffer flush");
                            logging.logDebug("Client {} flush error: {}\n", .{ client_id, err });
                            // Remove problematic client
                            self.removeClient(client_id);
                        };
                    }
                }
            }
        }

        // Check if shutdown was requested
        if (main_common.shutdown_requested.load(.seq_cst)) {
            logging.log(1, "Broker server received shutdown signal\n", .{});
        }

        logging.log(1, "Broker server shutting down\n", .{});
        logging.logDebug("Final client count: {}\n", .{self.clients.getClientCount()});

        // Send shutdown notification to all clients
        if (self.mode == .chat) {
            const shutdown_msg = "*** Server is shutting down\n";
            self.relayToClients(shutdown_msg, 0) catch |err| {
                logging.logError(err, "shutdown notification");
            };
        }

        // Log final performance summary
        const perf_summary = self.performance_monitor.getPerformanceSummary();
        logging.log(1, "Performance summary: {d:.1}% memory, {d:.1}% CPU, {d:.1} msg/s, {} errors\n", .{
            perf_summary.memory_usage_percent,
            perf_summary.cpu_usage_percent,
            perf_summary.messages_per_second,
            perf_summary.relay_errors,
        });
    }

    /// Accept a new client connection with access control, TLS support, and comprehensive logging
    fn acceptNewClient(self: *BrokerServer) !void {
        // Check client limit before accepting
        const current_clients = self.clients.getClientCount();
        if (current_clients >= self.max_clients) {
            // Accept and immediately close to clear the pending connection
            var client_addr: std.posix.sockaddr = undefined;
            var client_addr_len: std.posix.socklen_t = @sizeOf(std.posix.sockaddr);

            const client_socket = std.posix.accept(
                self.listen_socket,
                &client_addr,
                &client_addr_len,
                0,
            ) catch {
                return BrokerError.ListenSocketError;
            };

            // Convert sockaddr to std.net.Address for logging
            const client_address = std.net.Address.initPosix(@alignCast(&client_addr));

            // Log the rejected connection with verbosity-aware logging
            logging.logDebug("Client limit reached ({}/{}), connection from {any} rejected\n", .{ current_clients, self.max_clients, client_address });
            if (self.config.verbose) {
                logging.logWarning("Client limit reached, connection rejected from {any}\n", .{client_address});
            }

            std.posix.close(client_socket);
            return BrokerError.MaxClientsReached;
        }

        // Accept the connection
        var client_addr: std.posix.sockaddr = undefined;
        var client_addr_len: std.posix.socklen_t = @sizeOf(std.posix.sockaddr);

        const client_socket = std.posix.accept(
            self.listen_socket,
            &client_addr,
            &client_addr_len,
            0,
        ) catch {
            logging.logError(error.ListenSocketError, "accept");
            return BrokerError.ListenSocketError;
        };

        // Convert sockaddr to std.net.Address for access control and logging
        const client_address = std.net.Address.initPosix(@alignCast(&client_addr));

        // Check access control with enhanced logging
        if (!self.access_list.isAllowed(client_address)) {
            logging.logConnection(client_address, "DENIED");
            logging.logDebug("Access control denied connection from {any}\n", .{client_address});
            std.posix.close(client_socket);
            return;
        }

        // Apply connection timeout if configured
        if (self.config.connect_timeout > 0) {
            const timeout_ms = self.config.connect_timeout;
            logging.logTrace("Setting connection timeout to {}ms for client socket\n", .{timeout_ms});

            // Set socket timeout options using struct timeval (required on macOS/Unix)
            const timeval = std.posix.timeval{
                .sec = @intCast(timeout_ms / 1000),
                .usec = @intCast((timeout_ms % 1000) * 1000),
            };

            // Set receive timeout
            std.posix.setsockopt(client_socket, std.posix.SOL.SOCKET, std.posix.SO.RCVTIMEO, std.mem.asBytes(&timeval)) catch |err| {
                logging.logDebug("Failed to set receive timeout: {}\n", .{err});
            };

            // Set send timeout
            std.posix.setsockopt(client_socket, std.posix.SOL.SOCKET, std.posix.SO.SNDTIMEO, std.mem.asBytes(&timeval)) catch |err| {
                logging.logDebug("Failed to set send timeout: {}\n", .{err});
            };
        }

        // Create connection wrapper (plain or TLS)
        var connection = if (self.config.ssl) blk: {
            logging.logTrace("Establishing TLS connection for client from {any}\n", .{client_address});

            // Create TLS configuration for server
            const tls_config = tls.TlsConfig{
                .cert_file = self.config.ssl_cert,
                .key_file = self.config.ssl_key,
                .verify_peer = false, // Server doesn't verify client certs by default
                .server_name = null,
            };

            // Perform TLS handshake
            const tls_conn = tls.acceptTls(self.allocator, client_socket, tls_config) catch |err| {
                logging.logError(err, "TLS handshake");
                logging.logDebug("TLS handshake failed for client from {any}: {}\n", .{ client_address, err });
                std.posix.close(client_socket);
                return err;
            };

            logging.logDebug("TLS handshake completed for client from {any}\n", .{client_address});
            break :blk Connection.fromTls(tls_conn);
        } else Connection.fromSocket(client_socket);

        // Add client to pool
        const client_id = self.clients.addClient(connection) catch |err| {
            logging.logError(err, "client pool add");
            connection.close();
            return err;
        };

        // Add to flow control tracking
        self.flow_control.addClient(client_id) catch |err| {
            logging.logError(err, "flow control add");
            self.clients.removeClient(client_id);
            return err;
        };

        // Add to poll context
        self.poll_context.addClient(client_socket, client_id) catch |err| {
            logging.logError(err, "poll context add");
            self.flow_control.removeClient(client_id);
            self.clients.removeClient(client_id);
            return err;
        };

        // Log successful connection with appropriate verbosity
        logging.logConnection(client_address, "ACCEPT");
        logging.logDebug("Client {} connected from {any} (TLS: {}, Total clients: {})\n", .{ client_id, client_address, connection.isTls(), current_clients + 1 });

        // Handle mode-specific client initialization
        switch (self.mode) {
            .broker => {
                logging.logTrace("Client {} initialized in broker mode\n", .{client_id});
            },
            .chat => {
                // Chat mode - send welcome message and prompt for nickname
                protocols.initializeChatClient(self, client_id) catch |err| {
                    logging.logError(err, "chat initialization");
                    logging.logDebug("Chat initialization failed for client {}: {}\n", .{ client_id, err });
                    self.removeClient(client_id);
                };
            },
        }
    }

    /// Remove a client from the server with comprehensive cleanup and enhanced logging
    fn removeClient(self: *BrokerServer, client_id: u32) void {
        // Get client info before removal for chat mode cleanup and statistics
        var client_nickname: ?[]const u8 = null;
        var client_stats: ?struct {
            connect_time: i64,
            bytes_sent: u64,
            bytes_received: u64,
            was_tls: bool,
        } = null;
        var client_socket: ?std.posix.socket_t = null;

        if (self.clients.getClient(client_id)) |client| {
            // Save nickname for chat mode announcement
            if (client.nickname) |nick| {
                client_nickname = self.allocator.dupe(u8, nick) catch null;
            }

            if (self.mode == .chat) {
                self.unregisterChatNicknameById(client_id);
            }

            // Save statistics for logging
            client_stats = .{
                .connect_time = client.connect_time,
                .bytes_sent = client.bytes_sent,
                .bytes_received = client.bytes_received,
                .was_tls = client.connection.isTls(),
            };

            // Save socket FD for poll context removal
            client_socket = client.connection.getSocket();
        }

        // Remove from flow control tracking
        self.flow_control.removeClient(client_id);

        // Remove from client pool (this closes the connection and frees resources)
        self.clients.removeClient(client_id);
        logging.logTrace("Removed client {} from client pool\n", .{client_id});

        // Remove from poll context AFTER closing connection to prevent use-after-free
        if (client_socket) |socket| {
            self.poll_context.removeClient(socket);
            logging.logTrace("Removed client {} socket from poll context\n", .{client_id});
        }

        // Handle chat mode leave announcement
        if (self.mode == .chat and client_nickname != null) {
            const leave_msg = std.fmt.allocPrint(
                self.allocator,
                "*** {s} left the chat\n",
                .{client_nickname.?},
            ) catch {
                // If we can't allocate for the message, just clean up and continue
                if (client_nickname) |nick| {
                    self.allocator.free(nick);
                }
                logging.logError(error.OutOfMemory, "chat leave message");
                return;
            };
            defer self.allocator.free(leave_msg);
            defer if (client_nickname) |nick| self.allocator.free(nick);

            // Relay leave message (no sender to exclude)
            self.relayToClients(leave_msg, 0) catch |err| {
                logging.logError(err, "chat leave relay");
            };

            // Log chat client disconnection with enhanced details
            logging.log(1, "Client {} ({s}) left the chat", .{ client_id, client_nickname.? });
            if (client_stats) |stats| {
                const now = std.time.timestamp();
                const duration = now - stats.connect_time;
                logging.log(1, " ({}s, {}/{} bytes, TLS: {})", .{ duration, stats.bytes_sent, stats.bytes_received, stats.was_tls });
            }
            logging.log(1, "\n", .{});
        } else {
            // Log regular client disconnection
            logging.logDebug("Client {} disconnected", .{client_id});
            if (client_stats) |stats| {
                const now = std.time.timestamp();
                const duration = now - stats.connect_time;
                logging.logDebug(" ({}s, {}/{} bytes, TLS: {})", .{ duration, stats.bytes_sent, stats.bytes_received, stats.was_tls });
            }
            logging.logDebug("\n", .{});
        }

        // Log current client count after removal
        const remaining_clients = self.clients.getClientCount();
        logging.logDebug("Active clients after removal: {} / {} max\n", .{ remaining_clients, self.max_clients });

        // Log capacity utilization for trace level
        if (self.config.verbose_level >= 3) {
            const utilization = @as(f64, @floatFromInt(remaining_clients)) / @as(f64, @floatFromInt(self.max_clients)) * 100.0;
            logging.logTrace("Server capacity utilization: {d:.1}%\n", .{utilization});
        }
    }

    /// Log detailed client statistics for debugging
    fn logClientStatistics(self: *BrokerServer) void {
        const stats = self.clients.getClientStatistics(self.allocator) catch {
            logging.logError(error.OutOfMemory, "client statistics");
            return;
        };
        defer {
            for (stats) |*stat| {
                stat.deinit(self.allocator);
            }
            self.allocator.free(stats);
        }

        logging.logTrace("=== Client Statistics ===\n", .{});
        for (stats) |stat| {
            logging.logTrace("Client {}: ", .{stat.client_id});
            if (stat.nickname) |nick| {
                logging.logTrace("'{s}' ", .{nick});
            }
            logging.logTrace("({}s connected, {}s idle, {}/{} bytes)\n", .{
                stat.connection_duration,
                stat.idle_time,
                stat.bytes_sent,
                stat.bytes_received,
            });
        }
        logging.logTrace("=== End Statistics ===\n", .{});
    }

    /// Perform periodic maintenance tasks with enhanced logging
    fn performMaintenance(self: *BrokerServer) void {
        logging.logTrace("Performing maintenance tasks\n", .{});

        // Remove idle clients if timeout is configured
        if (self.config.idle_timeout > 0) {
            const timeout_seconds = self.config.idle_timeout / 1000; // Convert ms to seconds
            const removed = self.clients.removeIdleClients(@intCast(timeout_seconds));
            if (removed > 0) {
                logging.logDebug("Removed {} idle clients (timeout: {}s)\n", .{ removed, timeout_seconds });
            }
        }

        // Perform connection health checks
        self.performConnectionHealthCheck();

        // Log client statistics periodically
        const client_count = self.clients.getClientCount();
        if (client_count > 0) {
            logging.logTrace("Active clients: {} / {} max\n", .{ client_count, self.max_clients });

            // Log detailed client statistics if very verbose
            if (self.config.verbose_level >= 4) {
                self.logClientStatistics();
            }
        }
    }

    /// Check if an error indicates a connection failure that should trigger client removal
    fn isConnectionError(self: *BrokerServer, err: anyerror) bool {
        _ = self; // Suppress unused parameter warning
        return switch (err) {
            error.BrokenPipe,
            error.ConnectionResetByPeer,
            error.ConnectionAborted,
            error.NetworkUnreachable,
            error.HostUnreachable,
            error.ConnectionTimedOut,
            error.NotConnected,
            => true,
            else => false,
        };
    }

    /// Perform connection health checks on all clients with enhanced logging
    fn performConnectionHealthCheck(self: *BrokerServer) void {
        const client_ids = self.clients.getAllClientIds(self.allocator) catch {
            logging.logError(error.OutOfMemory, "health check client list");
            return;
        };
        defer self.allocator.free(client_ids);

        if (client_ids.len == 0) return;

        logging.logTrace("Performing health check on {} clients\n", .{client_ids.len});

        var failed_clients = std.ArrayList(u32){};
        defer failed_clients.deinit(self.allocator);

        for (client_ids) |client_id| {
            if (self.clients.getClient(client_id)) |client| {
                // Check if connection is still valid by attempting to get socket status
                const socket = client.connection.getSocket();

                // Use SO_ERROR to check for socket errors
                var error_code: i32 = 0;
                const error_bytes = std.mem.asBytes(&error_code);

                std.posix.getsockopt(socket, std.posix.SOL.SOCKET, std.posix.SO.ERROR, error_bytes) catch |err| {
                    // If getsockopt fails, assume socket is bad
                    logging.logTrace("Client {} health check failed (getsockopt): {}\n", .{ client_id, err });
                    error_code = 1;
                };

                if (error_code != 0) {
                    logging.logDebug("Client {} failed health check (socket error: {})\n", .{ client_id, error_code });
                    failed_clients.append(self.allocator, client_id) catch {};
                } else {
                    logging.logTrace("Client {} health check passed\n", .{client_id});
                }
            }
        }

        // Remove failed clients
        const removed_count = self.clients.removeFailedClients(failed_clients.items);
        if (removed_count > 0) {
            logging.logDebug("Health check removed {} failed clients\n", .{removed_count});
        }
    }

    /// Get performance and resource information
    pub fn getPerformanceInfo(self: *const BrokerServer) struct {
        client_count: usize,
        memory_usage_percent: f32,
        flow_control_level: @import("flow_control.zig").FlowControlLevel,
        messages_per_second: f32,
        bytes_per_second: f32,
        active_alerts: usize,
    } {
        const perf_summary = self.performance_monitor.getPerformanceSummary();
        const memory_info = self.buffer_pool.getMemoryInfo();

        return .{
            .client_count = self.clients.getClientCount(),
            .memory_usage_percent = memory_info.usage_percent,
            .flow_control_level = self.flow_control.getCurrentLevel(),
            .messages_per_second = perf_summary.messages_per_second,
            .bytes_per_second = perf_summary.bytes_per_second,
            .active_alerts = perf_summary.active_alerts,
        };
    }

    /// Relay data to all clients except the sender
    ///
    /// Broadcasts the given data to all connected clients, excluding the sender.
    /// This is used for both broker mode (raw relay) and chat mode (formatted messages).
    ///
    /// ## Parameters
    /// - `data`: Data to relay to clients
    /// - `exclude_client_id`: Client ID to exclude from relay (typically the sender), or 0 for broadcast to all
    ///
    /// ## Returns
    /// Error if relay fails critically (individual client failures are logged but don't stop relay)
    fn relayToClients(self: *BrokerServer, data: []const u8, exclude_client_id: u32) !void {
        if (data.len == 0) {
            logging.logTrace("Relay called with empty data, skipping\n", .{});
            return;
        }

        const client_ids = self.clients.getAllClientIds(self.allocator) catch {
            logging.logError(error.OutOfMemory, "relay client list");
            return error.OutOfMemory;
        };
        defer self.allocator.free(client_ids);

        var successful_relays: usize = 0;
        var failed_relays: usize = 0;

        for (client_ids) |client_id| {
            // Skip the sender
            if (client_id == exclude_client_id) {
                continue;
            }

            if (self.clients.getClient(client_id)) |client| {
                const bytes_written = client.connection.write(data) catch |err| {
                    logging.logDebug("Failed to relay to client {}: {}\n", .{ client_id, err });
                    failed_relays += 1;

                    // If it's a connection error, mark client for removal
                    if (self.isConnectionError(err)) {
                        logging.logTrace("Client {} connection error during relay, will be removed\n", .{client_id});
                    }
                    continue;
                };

                client.bytes_sent += bytes_written;
                client.updateActivity();
                successful_relays += 1;

                logging.logTrace("Relayed {} bytes to client {}\n", .{ bytes_written, client_id });
            }
        }

        // Record relay statistics
        self.performance_monitor.recordRelay(data.len, successful_relays);
        if (failed_relays > 0) {
            logging.logDebug("Relay complete: {} successful, {} failed\n", .{ successful_relays, failed_relays });
        } else {
            logging.logTrace("Relay complete: {} clients\n", .{successful_relays});
        }
    }

    fn isChatNicknameTaken(self: *BrokerServer, nickname: []const u8, exclude_client_id: u32) bool {
        if (self.mode != .chat) return false;

        if (self.chat_nicknames.get(nickname)) |existing_id| {
            return existing_id != exclude_client_id;
        }

        return false;
    }

    fn registerChatNickname(self: *BrokerServer, nickname: []const u8, client_id: u32) !void {
        if (self.mode != .chat) return;

        if (self.chat_nicknames.fetchRemove(nickname)) |kv| {
            self.allocator.free(@constCast(kv.key));
        }

        const nickname_copy = try self.allocator.dupe(u8, nickname);
        errdefer self.allocator.free(nickname_copy);

        try self.chat_nicknames.put(nickname_copy, client_id);
    }

    fn unregisterChatNickname(self: *BrokerServer, nickname: []const u8) void {
        if (self.chat_nicknames.fetchRemove(nickname)) |kv| {
            self.allocator.free(@constCast(kv.key));
        }
    }

    fn unregisterChatNicknameById(self: *BrokerServer, client_id: u32) void {
        var it = self.chat_nicknames.iterator();
        while (it.next()) |entry| {
            if (entry.value_ptr.* == client_id) {
                const key = entry.key_ptr.*;
                if (self.chat_nicknames.fetchRemove(key)) |kv| {
                    self.allocator.free(@constCast(kv.key));
                }
                return;
            }
        }
    }

    fn clearChatNicknames(self: *BrokerServer) void {
        var it = self.chat_nicknames.iterator();
        while (it.next()) |entry| {
            self.allocator.free(@constCast(entry.key_ptr.*));
        }
        self.chat_nicknames.clearRetainingCapacity();
    }

    /// Flush pending write data for a client
    ///
    /// Called when a client socket becomes writable (POLL.OUT event).
    /// Currently a no-op placeholder as the implementation uses direct writes.
    /// Future enhancement: Implement write buffering for flow control.
    ///
    /// ## Parameters
    /// - `client_id`: Client ID to flush
    ///
    /// ## Returns
    /// Error if flush fails critically
    fn flushWriteBuffer(self: *BrokerServer, client_id: u32) !void {
        // Placeholder for write buffer flushing
        // Future enhancement: Implement buffered writes with flow control
        _ = self;

        logging.logTrace("Write buffer flush called for client {} (currently a no-op)\n", .{client_id});

        // TODO: Implement write buffering:
        // 1. Maintain per-client write buffers
        // 2. Queue data when socket would block
        // 3. Flush on POLL.OUT events
        // 4. Implement backpressure for slow clients
    }

    /// Gracefully shutdown the broker server with enhanced logging
    pub fn shutdown(self: *BrokerServer) void {
        self.running = false;

        logging.log(1, "Broker server shutdown requested\n", .{});
        logging.logDebug("Shutting down with {} active clients\n", .{self.clients.getClientCount()});

        // Send shutdown notification to all clients in chat mode
        if (self.mode == .chat) {
            const shutdown_msg = "*** Server is shutting down\n";
            self.relayToClients(shutdown_msg, 0) catch |err| {
                logging.logError(err, "shutdown notification");
            };
            logging.logDebug("Sent shutdown notification to chat clients\n", .{});
        }

        // Log final statistics and performance summary
        if (self.config.verbose_level >= 2) {
            self.logClientStatistics();
        }

        // Log final performance summary
        const perf_summary = self.performance_monitor.getPerformanceSummary();
        logging.log(1, "Performance summary: {d:.1}% memory, {d:.1}% CPU, {d:.1} msg/s, {} errors\n", .{
            perf_summary.memory_usage_percent,
            perf_summary.cpu_usage_percent,
            perf_summary.messages_per_second,
            perf_summary.relay_errors,
        });
    }
};

// Tests
test "BrokerServer initialization" {
    const testing = std.testing;
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    // Create mock configuration
    var config = Config.init(allocator);
    defer config.deinit(allocator);

    // Create mock access list
    var access_list = allowlist.AccessList.init(allocator);
    defer access_list.deinit();

    // Create broker server (using invalid socket for testing)
    const mock_socket: std.posix.socket_t = 0;
    var server = try BrokerServer.init(allocator, mock_socket, .broker, &config, &access_list);
    defer server.deinit();

    try testing.expect(server.mode == .broker);
    try testing.expect(server.max_clients == 50); // Default value
    try testing.expect(!server.running);
}

test "PollContext operations" {
    const testing = std.testing;
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    const mock_listen_socket: std.posix.socket_t = 1;
    var poll_ctx = PollContext.init(allocator, mock_listen_socket);
    defer poll_ctx.deinit();

    // Test initial state
    try testing.expect(poll_ctx.listen_fd.fd == mock_listen_socket);
    try testing.expect(poll_ctx.client_fds.items.len == 0);

    // Test adding client
    const mock_client_socket: std.posix.socket_t = 2;
    try poll_ctx.addClient(mock_client_socket, 1);

    try testing.expect(poll_ctx.client_fds.items.len == 1);
    try testing.expect(poll_ctx.client_fds.items[0].fd == mock_client_socket);
    try testing.expect(poll_ctx.getClientId(mock_client_socket) == 1);

    // Test removing client
    poll_ctx.removeClient(mock_client_socket);
    try testing.expect(poll_ctx.client_fds.items.len == 0);
    try testing.expect(poll_ctx.getClientId(mock_client_socket) == null);
}

test "BrokerServer connection error detection" {
    const testing = std.testing;
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    // Create mock configuration
    var config = Config.init(allocator);
    defer config.deinit(allocator);

    // Create mock access list
    var access_list = allowlist.AccessList.init(allocator);
    defer access_list.deinit();

    // Create broker server
    const mock_socket: std.posix.socket_t = 0;
    var server = try BrokerServer.init(allocator, mock_socket, .broker, &config, &access_list);
    defer server.deinit();

    // Test connection error detection
    try testing.expect(server.isConnectionError(error.ConnectionResetByPeer));
    try testing.expect(server.isConnectionError(error.BrokenPipe));
    try testing.expect(server.isConnectionError(error.ConnectionAborted));
    try testing.expect(!server.isConnectionError(error.OutOfMemory));
    try testing.expect(!server.isConnectionError(error.InvalidArgument));
}
</file>

<file path="server/buffer_pool.zig">
//! Buffer Pool Manager for Efficient Memory Management
//!
//! This module provides memory pooling for client I/O operations in broker/chat mode.
//! It implements efficient buffer allocation, reuse, and flow control to prevent
//! memory exhaustion under high data rates.
//!
//! ## Design Goals
//!
//! - **Memory Pooling**: Reuse buffers to reduce allocation overhead
//! - **Flow Control**: Prevent memory exhaustion with backpressure mechanisms
//! - **Resource Monitoring**: Track memory usage and implement limits
//! - **Graceful Degradation**: Handle memory pressure without crashing
//! - **Thread Safety**: Support concurrent access from multiple threads
//!
//! ## Architecture
//!
//! ```
//!         
//!    Buffer               Buffer                Flow          
//!    Pool             Manager           Control       
//!                                                             
//!         
//!                                                        
//!                                                        
//!         
//!    Memory               Resource              Backpressure  
//!    Allocation           Monitoring            Management    
//!                                                             
//!         
//! ```

const std = @import("std");
const builtin = @import("builtin");

/// Buffer pool configuration
pub const BufferPoolConfig = struct {
    /// Size of each buffer in bytes
    buffer_size: usize = 4096,
    /// Initial number of buffers to pre-allocate
    initial_pool_size: usize = 32,
    /// Maximum number of buffers in the pool
    max_pool_size: usize = 256,
    /// Maximum total memory usage in bytes (0 = unlimited)
    max_memory_usage: usize = 16 * 1024 * 1024, // 16MB default
    /// Enable flow control when memory usage exceeds this threshold
    flow_control_threshold: f32 = 0.8, // 80% of max memory
    /// Enable aggressive cleanup when memory usage exceeds this threshold
    cleanup_threshold: f32 = 0.9, // 90% of max memory
};

/// Buffer pool statistics
pub const BufferPoolStats = struct {
    /// Total buffers allocated
    total_allocated: u64 = 0,
    /// Buffers currently in use
    buffers_in_use: u64 = 0,
    /// Buffers available in pool
    buffers_available: u64 = 0,
    /// Total memory usage in bytes
    memory_usage: u64 = 0,
    /// Number of allocation requests
    allocation_requests: u64 = 0,
    /// Number of successful allocations from pool
    pool_hits: u64 = 0,
    /// Number of allocations that required new memory
    pool_misses: u64 = 0,
    /// Number of times flow control was triggered
    flow_control_triggers: u64 = 0,
    /// Number of buffers reclaimed during cleanup
    buffers_reclaimed: u64 = 0,

    /// Calculate pool hit rate as percentage
    pub fn hitRate(self: *const BufferPoolStats) f32 {
        if (self.allocation_requests == 0) return 0.0;
        return @as(f32, @floatFromInt(self.pool_hits)) / @as(f32, @floatFromInt(self.allocation_requests)) * 100.0;
    }

    /// Calculate memory usage as percentage of maximum
    pub fn memoryUsagePercent(self: *const BufferPoolStats, max_memory: usize) f32 {
        if (max_memory == 0) return 0.0;
        return @as(f32, @floatFromInt(self.memory_usage)) / @as(f32, @floatFromInt(max_memory)) * 100.0;
    }
};

/// Managed buffer with metadata
pub const ManagedBuffer = struct {
    /// Buffer data
    data: []u8,
    /// Buffer capacity
    capacity: usize,
    /// Current data length
    len: usize = 0,
    /// Reference count for shared usage
    ref_count: u32 = 1,
    /// Timestamp when buffer was allocated
    allocated_at: i64,
    /// Timestamp of last access
    last_accessed: i64,

    /// Initialize a managed buffer
    pub fn init(data: []u8) ManagedBuffer {
        const now = std.time.timestamp();
        return ManagedBuffer{
            .data = data,
            .capacity = data.len,
            .allocated_at = now,
            .last_accessed = now,
        };
    }

    /// Update last accessed timestamp
    pub fn touch(self: *ManagedBuffer) void {
        self.last_accessed = std.time.timestamp();
    }

    /// Get writable slice of buffer
    pub fn getWritable(self: *ManagedBuffer) []u8 {
        self.touch();
        return self.data[self.len..];
    }

    /// Get readable slice of buffer
    pub fn getReadable(self: *const ManagedBuffer) []const u8 {
        return self.data[0..self.len];
    }

    /// Advance the buffer length after writing data
    pub fn advance(self: *ManagedBuffer, bytes: usize) void {
        self.len = @min(self.len + bytes, self.capacity);
        self.touch();
    }

    /// Reset buffer for reuse
    pub fn reset(self: *ManagedBuffer) void {
        self.len = 0;
        self.ref_count = 1;
        self.touch();
    }

    /// Check if buffer is idle (not accessed recently)
    pub fn isIdle(self: *const ManagedBuffer, idle_threshold_seconds: i64) bool {
        const now = std.time.timestamp();
        return (now - self.last_accessed) > idle_threshold_seconds;
    }
};

/// Buffer pool for efficient memory management
pub const BufferPool = struct {
    /// Memory allocator
    allocator: std.mem.Allocator,
    /// Pool configuration
    config: BufferPoolConfig,
    /// Available buffers
    available_buffers: std.ArrayList(*ManagedBuffer),
    /// All allocated buffers (for tracking)
    all_buffers: std.ArrayList(*ManagedBuffer),
    /// Pool statistics
    stats: BufferPoolStats = BufferPoolStats{},
    /// Mutex for thread safety
    mutex: std.Thread.Mutex = .{},
    /// Flow control enabled flag
    flow_control_active: bool = false,

    /// Initialize buffer pool
    pub fn init(allocator: std.mem.Allocator, config: BufferPoolConfig) !BufferPool {
        var pool = BufferPool{
            .allocator = allocator,
            .config = config,
            .available_buffers = std.ArrayList(*ManagedBuffer){},
            .all_buffers = std.ArrayList(*ManagedBuffer){},
        };

        // Pre-allocate initial buffers
        try pool.preallocateBuffers();

        return pool;
    }

    /// Clean up buffer pool
    pub fn deinit(self: *BufferPool) void {
        self.mutex.lock();
        defer self.mutex.unlock();

        // Free all buffers
        for (self.all_buffers.items) |buffer| {
            self.allocator.free(buffer.data);
            self.allocator.destroy(buffer);
        }

        self.available_buffers.deinit(self.allocator);
        self.all_buffers.deinit(self.allocator);
    }

    /// Pre-allocate initial buffers
    fn preallocateBuffers(self: *BufferPool) !void {
        for (0..self.config.initial_pool_size) |_| {
            const buffer = try self.createBuffer();
            try self.available_buffers.append(self.allocator, buffer);
            try self.all_buffers.append(self.allocator, buffer);
            self.stats.buffers_available += 1;
            self.stats.total_allocated += 1;
            self.stats.memory_usage += self.config.buffer_size + @sizeOf(ManagedBuffer);
        }
    }

    /// Create a new buffer
    fn createBuffer(self: *BufferPool) !*ManagedBuffer {
        const data = try self.allocator.alloc(u8, self.config.buffer_size);
        const buffer = try self.allocator.create(ManagedBuffer);
        buffer.* = ManagedBuffer.init(data);
        return buffer;
    }

    /// Acquire a buffer from the pool
    pub fn acquire(self: *BufferPool) !*ManagedBuffer {
        self.mutex.lock();
        defer self.mutex.unlock();

        self.stats.allocation_requests += 1;

        // Check flow control
        if (self.shouldTriggerFlowControl()) {
            self.flow_control_active = true;
            self.stats.flow_control_triggers += 1;
            return error.FlowControlActive;
        }

        // Try to get buffer from pool
        if (self.available_buffers.items.len > 0) {
            const buffer = self.available_buffers.pop() orelse unreachable; // Safe: checked len > 0
            buffer.reset();
            self.stats.buffers_available -= 1;
            self.stats.buffers_in_use += 1;
            self.stats.pool_hits += 1;
            return buffer;
        }

        // Pool is empty, check if we can allocate new buffer
        if (self.canAllocateNewBuffer()) {
            const buffer = try self.createBuffer();
            try self.all_buffers.append(self.allocator, buffer);
            self.stats.total_allocated += 1;
            self.stats.buffers_in_use += 1;
            self.stats.memory_usage += self.config.buffer_size + @sizeOf(ManagedBuffer);
            self.stats.pool_misses += 1;
            return buffer;
        }

        // Cannot allocate, trigger cleanup and try again
        const reclaimed = self.performCleanup();
        self.stats.buffers_reclaimed += reclaimed;

        if (self.available_buffers.items.len > 0) {
            const buffer = self.available_buffers.pop() orelse unreachable; // Safe: checked len > 0
            buffer.reset();
            self.stats.buffers_available -= 1;
            self.stats.buffers_in_use += 1;
            self.stats.pool_hits += 1;
            return buffer;
        }

        return error.OutOfMemory;
    }

    /// Release a buffer back to the pool
    pub fn release(self: *BufferPool, buffer: *ManagedBuffer) void {
        self.mutex.lock();
        defer self.mutex.unlock();

        // Decrement reference count
        if (buffer.ref_count > 1) {
            buffer.ref_count -= 1;
            return;
        }

        // Reset buffer and return to pool
        buffer.reset();
        self.available_buffers.append(self.allocator, buffer) catch {
            // If we can't add to pool, just leave it allocated
            return;
        };

        self.stats.buffers_in_use -= 1;
        self.stats.buffers_available += 1;

        // Check if we can disable flow control
        if (self.flow_control_active and !self.shouldTriggerFlowControl()) {
            self.flow_control_active = false;
        }
    }

    /// Check if flow control should be triggered
    fn shouldTriggerFlowControl(self: *const BufferPool) bool {
        if (self.config.max_memory_usage == 0) return false;

        const usage_ratio = @as(f32, @floatFromInt(self.stats.memory_usage)) / @as(f32, @floatFromInt(self.config.max_memory_usage));
        return usage_ratio >= self.config.flow_control_threshold;
    }

    /// Check if we can allocate a new buffer
    fn canAllocateNewBuffer(self: *const BufferPool) bool {
        // Check pool size limit
        if (self.all_buffers.items.len >= self.config.max_pool_size) {
            return false;
        }

        // Check memory limit
        if (self.config.max_memory_usage > 0) {
            const new_usage = self.stats.memory_usage + self.config.buffer_size + @sizeOf(ManagedBuffer);
            if (new_usage > self.config.max_memory_usage) {
                return false;
            }
        }

        return true;
    }

    /// Perform cleanup to reclaim idle buffers
    fn performCleanup(self: *BufferPool) u64 {
        const idle_threshold: i64 = 300; // 5 minutes
        var reclaimed: u64 = 0;

        // Find idle buffers in available pool
        var i: usize = 0;
        while (i < self.available_buffers.items.len) {
            const buffer = self.available_buffers.items[i];
            if (buffer.isIdle(idle_threshold)) {
                // Remove from available pool
                _ = self.available_buffers.swapRemove(i);

                // Remove from all buffers and free
                for (self.all_buffers.items, 0..) |all_buffer, j| {
                    if (all_buffer == buffer) {
                        _ = self.all_buffers.swapRemove(j);
                        break;
                    }
                }

                self.allocator.free(buffer.data);
                self.allocator.destroy(buffer);

                self.stats.buffers_available -= 1;
                self.stats.total_allocated -= 1;
                self.stats.memory_usage -= self.config.buffer_size + @sizeOf(ManagedBuffer);
                reclaimed += 1;
            } else {
                i += 1;
            }
        }

        return reclaimed;
    }

    /// Get current statistics
    pub fn getStats(self: *const BufferPool) BufferPoolStats {
        // Note: We need to cast away const to acquire mutex
        const self_mut = @constCast(self);
        self_mut.mutex.lock();
        defer self_mut.mutex.unlock();

        return self_mut.stats;
    }

    /// Check if flow control is active
    pub fn isFlowControlActive(self: *const BufferPool) bool {
        const self_mut = @constCast(self);
        self_mut.mutex.lock();
        defer self_mut.mutex.unlock();

        return self_mut.flow_control_active;
    }

    /// Force cleanup of idle buffers
    pub fn forceCleanup(self: *BufferPool) u64 {
        self.mutex.lock();
        defer self.mutex.unlock();

        const reclaimed = self.performCleanup();
        self.stats.buffers_reclaimed += reclaimed;
        return reclaimed;
    }

    /// Get memory usage information
    pub fn getMemoryInfo(self: *const BufferPool) struct {
        current_usage: usize,
        max_usage: usize,
        usage_percent: f32,
        flow_control_active: bool,
    } {
        const self_mut = @constCast(self);
        self_mut.mutex.lock();
        defer self_mut.mutex.unlock();

        return .{
            .current_usage = @intCast(self_mut.stats.memory_usage),
            .max_usage = self_mut.config.max_memory_usage,
            .usage_percent = if (self_mut.config.max_memory_usage > 0)
                @as(f32, @floatFromInt(self_mut.stats.memory_usage)) / @as(f32, @floatFromInt(self_mut.config.max_memory_usage)) * 100.0
            else
                0.0,
            .flow_control_active = self_mut.flow_control_active,
        };
    }
};

// Tests
test "BufferPool basic operations" {
    const testing = std.testing;
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    const config = BufferPoolConfig{
        .buffer_size = 1024,
        .initial_pool_size = 4,
        .max_pool_size = 8,
        .max_memory_usage = 16384,
    };

    var pool = try BufferPool.init(allocator, config);
    defer pool.deinit();

    // Test initial state
    const initial_stats = pool.getStats();
    try testing.expect(initial_stats.total_allocated == 4);
    try testing.expect(initial_stats.buffers_available == 4);
    try testing.expect(initial_stats.buffers_in_use == 0);

    // Test buffer acquisition
    const buffer1 = try pool.acquire();
    try testing.expect(buffer1.capacity == 1024);
    try testing.expect(buffer1.len == 0);

    const stats_after_acquire = pool.getStats();
    try testing.expect(stats_after_acquire.buffers_in_use == 1);
    try testing.expect(stats_after_acquire.buffers_available == 3);

    // Test buffer release
    pool.release(buffer1);
    const stats_after_release = pool.getStats();
    try testing.expect(stats_after_release.buffers_in_use == 0);
    try testing.expect(stats_after_release.buffers_available == 4);
}

test "BufferPool flow control" {
    const testing = std.testing;
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    const config = BufferPoolConfig{
        .buffer_size = 1024,
        .initial_pool_size = 2,
        .max_pool_size = 10, // Increased to allow enough allocations for flow control
        .max_memory_usage = 5120, // Adjusted so 80% threshold allows 3+ buffers before flow control (each buffer ~= 1080 bytes)
        .flow_control_threshold = 0.75, // Lower threshold to trigger before hard limit (75% = 3840 bytes, ~3.5 buffers)
    };

    var pool = try BufferPool.init(allocator, config);
    defer pool.deinit();

    // Acquire buffers until flow control triggers
    var buffers = std.ArrayList(*ManagedBuffer){};
    defer buffers.deinit(allocator);

    // Should be able to acquire some buffers
    try buffers.append(allocator, try pool.acquire());
    try buffers.append(allocator, try pool.acquire());

    // Eventually should trigger flow control
    var flow_control_triggered = false;
    for (0..10) |_| {
        if (pool.acquire()) |buffer| {
            try buffers.append(allocator, buffer);
        } else |err| {
            if (err == error.FlowControlActive) {
                flow_control_triggered = true;
                break;
            }
        }
    }

    try testing.expect(flow_control_triggered);
    try testing.expect(pool.isFlowControlActive());

    // Release buffers
    for (buffers.items) |buffer| {
        pool.release(buffer);
    }
}

test "ManagedBuffer operations" {
    const testing = std.testing;
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    const data = try allocator.alloc(u8, 1024);
    defer allocator.free(data);

    var buffer = ManagedBuffer.init(data);

    // Test initial state
    try testing.expect(buffer.capacity == 1024);
    try testing.expect(buffer.len == 0);
    try testing.expect(buffer.ref_count == 1);

    // Test writing data
    const writable = buffer.getWritable();
    try testing.expect(writable.len == 1024);

    // Simulate writing some data
    @memcpy(writable[0..5], "hello");
    buffer.advance(5);

    try testing.expect(buffer.len == 5);

    const readable = buffer.getReadable();
    try testing.expectEqualStrings("hello", readable);

    // Test reset
    buffer.reset();
    try testing.expect(buffer.len == 0);
    try testing.expect(buffer.ref_count == 1);
}

test "BufferPool cleanup" {
    const testing = std.testing;
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    const config = BufferPoolConfig{
        .buffer_size = 1024,
        .initial_pool_size = 4,
        .max_pool_size = 8,
        .max_memory_usage = 16384,
    };

    var pool = try BufferPool.init(allocator, config);
    defer pool.deinit();

    // Force cleanup (should not reclaim anything since buffers are new)
    const reclaimed = pool.forceCleanup();
    try testing.expect(reclaimed == 0);

    // Get memory info
    const memory_info = pool.getMemoryInfo();
    try testing.expect(memory_info.current_usage > 0);
    try testing.expect(memory_info.max_usage == 16384);
    try testing.expect(!memory_info.flow_control_active);
}
</file>

<file path="server/chat.zig">
//! Chat Protocol Handler with Nickname Support
//!
//! This module implements the chat protocol handler for ZigCat's chat mode,
//! providing line-oriented messaging with user-friendly features like nicknames,
//! join/leave notifications, and message formatting.
//!
//! ## Design Goals
//!
//! - **Line-Oriented Protocol**: Handle complete lines with proper CRLF support
//! - **Nickname Management**: Prompt, validate, and manage client nicknames
//! - **Message Formatting**: Format messages with nickname prefixes
//! - **System Notifications**: Handle join/leave and nickname change announcements
//! - **Input Validation**: Validate nicknames and messages for safety
//!
//! ## Protocol Flow
//!
//! ```
//! 1. Client connects
//! 2. Server sends welcome message and nickname prompt
//! 3. Client sends nickname
//! 4. Server validates nickname and announces join
//! 5. Client sends messages (formatted and relayed)
//! 6. Client disconnects (server announces leave)
//! ```
//!
//! ## Message Formats
//!
//! - **Chat Message**: `[nickname] message content\n`
//! - **Join Notification**: `*** nickname joined the chat\n`
//! - **Leave Notification**: `*** nickname left the chat\n`
//! - **Nickname Change**: `*** old_nick is now known as new_nick\n`
//! - **System Message**: `*** system message content\n`
//!
//! ## Usage Pattern
//!
//! ```zig
//! var chat_handler = ChatHandler.init(allocator, &relay_engine);
//! defer chat_handler.deinit();
//!
//! // Handle new client connection
//! try chat_handler.handleClientJoin(client_id);
//!
//! // Process incoming message data
//! try chat_handler.processMessage(client_id, raw_data);
//!
//! // Handle client disconnection
//! try chat_handler.handleClientLeave(client_id, nickname);
//! ```

const std = @import("std");
const RelayEngine = @import("relay.zig").RelayEngine;
const ClientPool = @import("client_pool.zig").ClientPool;
const ClientInfo = @import("client_pool.zig").ClientInfo;
const logging = @import("../util/logging.zig");

/// Chat protocol handler errors
pub const ChatError = error{
    /// Client not found in pool
    ClientNotFound,
    /// Invalid nickname provided
    InvalidNickname,
    /// Nickname already in use
    NicknameTaken,
    /// Message too long for processing
    MessageTooLong,
    /// Failed to send message to client
    SendFailed,
    /// Memory allocation failed
    OutOfMemory,
    /// Invalid message format
    InvalidMessageFormat,
    /// Client not in correct state for operation
    InvalidClientState,
};

/// Chat client states for protocol flow management
pub const ChatClientState = enum {
    /// Client just connected, needs nickname
    awaiting_nickname,
    /// Client has nickname and is active in chat
    active,
    /// Client is disconnecting
    disconnecting,
};

/// Chat protocol handler for line-oriented messaging
pub const ChatHandler = struct {
    /// Memory allocator for message formatting
    allocator: std.mem.Allocator,
    /// Reference to relay engine for message distribution
    relay_engine: *RelayEngine,
    /// Maximum nickname length allowed
    max_nickname_len: usize = 32,
    /// Maximum message length allowed
    max_message_len: usize = 1024,
    /// Welcome message sent to new clients
    welcome_message: []const u8 = "Welcome to ZigCat chat! Please enter your nickname: ",
    /// Nickname prompt for invalid attempts
    nickname_prompt: []const u8 = "Please enter a valid nickname: ",

    /// Initialize chat protocol handler
    ///
    /// ## Parameters
    /// - `allocator`: Memory allocator for message formatting
    /// - `relay_engine`: Reference to relay engine for message distribution
    ///
    /// ## Returns
    /// Initialized chat handler ready for use
    pub fn init(allocator: std.mem.Allocator, relay_engine: *RelayEngine) ChatHandler {
        return ChatHandler{
            .allocator = allocator,
            .relay_engine = relay_engine,
        };
    }

    /// Clean up chat handler resources
    ///
    /// ## Parameters
    /// - `self`: Mutable reference to chat handler
    pub fn deinit(self: *ChatHandler) void {
        _ = self;
    }

    /// Handle a new client joining the chat
    ///
    /// Sends welcome message and prompts for nickname. This is called
    /// when a client first connects to the chat server.
    ///
    /// ## Parameters
    /// - `self`: Mutable reference to chat handler
    /// - `client_id`: ID of the newly connected client
    ///
    /// ## Returns
    /// Error if welcome message cannot be sent
    ///
    /// ## Behavior
    /// - Sends welcome message to client
    /// - Prompts for nickname
    /// - Sets client state to awaiting_nickname
    pub fn handleClientJoin(self: *ChatHandler, client_id: u32) !void {
        // Get client from pool
        const client_pool = self.relay_engine.client_pool;
        const client = client_pool.getClient(client_id) orelse return ChatError.ClientNotFound;

        // Send welcome message and nickname prompt
        const bytes_sent = client.connection.write(self.welcome_message) catch {
            return ChatError.SendFailed;
        };

        // Update client statistics
        client.bytes_sent += bytes_sent;
        client.updateActivity();

        logging.logDebug("Sent welcome message to client {any} ({any} bytes)\n", .{ client_id, bytes_sent });
    }

    /// Handle a client leaving the chat
    ///
    /// Announces the client's departure to all remaining clients if the
    /// client had a nickname set.
    ///
    /// ## Parameters
    /// - `self`: Mutable reference to chat handler
    /// - `client_id`: ID of the departing client
    /// - `nickname`: Optional nickname of the departing client
    ///
    /// ## Returns
    /// Error if leave announcement cannot be sent
    ///
    /// ## Behavior
    /// - Creates leave announcement message
    /// - Broadcasts to all remaining clients
    /// - Logs the departure
    pub fn handleClientLeave(self: *ChatHandler, client_id: u32, nickname: ?[]const u8) !void {
        // Only announce if client had a nickname
        if (nickname) |nick| {
            self.unregisterNickname(nick);

            // Create leave announcement
            const leave_msg = try std.fmt.allocPrint(
                self.allocator,
                "*** {s} left the chat\n",
                .{nick},
            );
            defer self.allocator.free(leave_msg);

            // Broadcast to all clients (no sender exclusion for system messages)
            try self.relay_engine.broadcastNotification(leave_msg);

            logging.logDebug("Client {any} ({s}) left the chat\n", .{ client_id, nick });
        } else {
            logging.logDebug("Client {any} left without setting nickname\n", .{client_id});
        }
    }

    /// Process incoming message data from a client
    ///
    /// Handles both nickname setting (for new clients) and regular chat
    /// messages. Processes line-oriented data with proper CRLF handling.
    ///
    /// ## Parameters
    /// - `self`: Mutable reference to chat handler
    /// - `client_id`: ID of client sending the message
    /// - `raw_data`: Raw data received from client
    ///
    /// ## Returns
    /// Error if message processing fails
    ///
    /// ## Behavior
    /// - Processes complete lines from raw data
    /// - Handles nickname setting for new clients
    /// - Formats and relays chat messages
    /// - Maintains client read buffer state
    pub fn processMessage(self: *ChatHandler, client_id: u32, raw_data: []const u8) !void {
        const client_pool = self.relay_engine.client_pool;
        const client = client_pool.getClient(client_id) orelse return ChatError.ClientNotFound;

        // Add new data to client's read buffer
        if (client.read_buffer_len + raw_data.len > client.read_buffer.len) {
            // Buffer would overflow - reset and send error
            client.read_buffer_len = 0;
            const error_msg = "*** Message too long, please try again\n";
            _ = client.connection.write(error_msg) catch {};
            return ChatError.MessageTooLong;
        }

        // Copy new data to read buffer
        @memcpy(client.read_buffer[client.read_buffer_len .. client.read_buffer_len + raw_data.len], raw_data);
        client.read_buffer_len += raw_data.len;

        // Process complete lines
        try self.processCompleteLines(client_id);
    }

    /// Process complete lines from client's read buffer
    ///
    /// Extracts complete lines (ending with \n) from the client's read buffer
    /// and processes each line according to the client's current state.
    ///
    /// ## Parameters
    /// - `self`: Mutable reference to chat handler
    /// - `client_id`: ID of client whose buffer to process
    ///
    /// ## Returns
    /// Error if line processing fails
    fn processCompleteLines(self: *ChatHandler, client_id: u32) !void {
        const client_pool = self.relay_engine.client_pool;
        const client = client_pool.getClient(client_id) orelse return ChatError.ClientNotFound;

        var start: usize = 0;
        while (start < client.read_buffer_len) {
            // Find line ending
            const line_end = std.mem.indexOfScalarPos(u8, client.read_buffer[0..client.read_buffer_len], start, '\n');
            if (line_end == null) {
                // No complete line yet
                break;
            }

            const end = line_end.?;
            var line = client.read_buffer[start..end];

            // Remove trailing \r if present (handle CRLF)
            if (line.len > 0 and line[line.len - 1] == '\r') {
                line = line[0 .. line.len - 1];
            }

            // Process the line based on client state
            try self.processLine(client_id, line);

            start = end + 1; // Move past the \n
        }

        // Move remaining data to beginning of buffer
        if (start > 0) {
            const remaining = client.read_buffer_len - start;
            if (remaining > 0) {
                std.mem.copyForwards(u8, client.read_buffer[0..remaining], client.read_buffer[start..client.read_buffer_len]);
            }
            client.read_buffer_len = remaining;
        }
    }

    /// Process a single complete line from a client
    ///
    /// Handles the line based on whether the client has set a nickname or not.
    /// New clients are prompted for nicknames, while active clients have their
    /// messages formatted and relayed.
    ///
    /// ## Parameters
    /// - `self`: Mutable reference to chat handler
    /// - `client_id`: ID of client sending the line
    /// - `line`: Complete line of text (without line endings)
    ///
    /// ## Returns
    /// Error if line processing fails
    fn processLine(self: *ChatHandler, client_id: u32, line: []const u8) !void {
        const client_pool = self.relay_engine.client_pool;
        const client = client_pool.getClient(client_id) orelse return ChatError.ClientNotFound;

        if (client.nickname == null) {
            // Client hasn't set nickname yet - process as nickname
            try self.handleNicknameInput(client_id, line);
        } else {
            // Client has nickname - process as chat message
            try self.handleChatMessage(client_id, line);
        }
    }

    /// Handle nickname input from a new client
    ///
    /// Validates the proposed nickname, checks for conflicts, and either
    /// sets the nickname (with join announcement) or prompts again.
    ///
    /// ## Parameters
    /// - `self`: Mutable reference to chat handler
    /// - `client_id`: ID of client setting nickname
    /// - `nickname_input`: Raw nickname input from client
    ///
    /// ## Returns
    /// Error if nickname processing fails
    fn handleNicknameInput(self: *ChatHandler, client_id: u32, nickname_input: []const u8) !void {
        const client_pool = self.relay_engine.client_pool;
        const client = client_pool.getClient(client_id) orelse return ChatError.ClientNotFound;

        // Trim whitespace from nickname
        const trimmed_nick = std.mem.trim(u8, nickname_input, " \t\r\n");

        // Validate nickname
        if (!self.validateNickname(trimmed_nick)) {
            // Send error message and prompt again
            const error_msg = "*** Invalid nickname. Please use 1-32 characters, no special characters.\n";
            _ = client.connection.write(error_msg) catch {};
            _ = client.connection.write(self.nickname_prompt) catch {};
            return;
        }

        // Check if nickname is already taken
        if (self.isNicknameTaken(trimmed_nick, client_id)) {
            // Send error message and prompt again
            const error_msg = "*** Nickname already taken. Please choose another.\n";
            _ = client.connection.write(error_msg) catch {};
            _ = client.connection.write(self.nickname_prompt) catch {};
            return;
        }

        self.registerNickname(trimmed_nick, client_id) catch |err| {
            const error_msg = "*** Failed to set nickname. Please try again.\n";
            _ = client.connection.write(error_msg) catch {};
            _ = client.connection.write(self.nickname_prompt) catch {};
            logging.logError(err, "register nickname");
            return;
        };

        // Set nickname
        client.setNickname(self.allocator, trimmed_nick) catch |err| {
            self.unregisterNickname(trimmed_nick);
            const error_msg = "*** Failed to set nickname. Please try again.\n";
            _ = client.connection.write(error_msg) catch {};
            _ = client.connection.write(self.nickname_prompt) catch {};
            logging.logError(err, "set nickname");
            return;
        };

        // Send confirmation to client
        const confirm_msg = try std.fmt.allocPrint(
            self.allocator,
            "*** You are now known as {s}\n",
            .{trimmed_nick},
        );
        defer self.allocator.free(confirm_msg);

        _ = client.connection.write(confirm_msg) catch {};

        // Announce join to other clients
        const join_msg = try std.fmt.allocPrint(
            self.allocator,
            "*** {s} joined the chat\n",
            .{trimmed_nick},
        );
        defer self.allocator.free(join_msg);

        // Relay join message to all other clients (exclude this client)
        try self.relay_engine.relayData(join_msg, client_id);

        logging.logDebug("Client {any} set nickname: {s}\n", .{ client_id, trimmed_nick });
    }

    /// Handle a chat message from an active client
    ///
    /// Formats the message with the client's nickname and relays it to
    /// all other connected clients.
    ///
    /// ## Parameters
    /// - `self`: Mutable reference to chat handler
    /// - `client_id`: ID of client sending the message
    /// - `message`: Message content (without nickname prefix)
    ///
    /// ## Returns
    /// Error if message handling fails
    fn handleChatMessage(self: *ChatHandler, client_id: u32, message: []const u8) !void {
        // Ignore empty messages
        if (message.len == 0) return;

        // Validate message length
        if (message.len > self.max_message_len) {
            const client_pool = self.relay_engine.client_pool;
            if (client_pool.getClient(client_id)) |client| {
                const error_msg = "*** Message too long, please try again\n";
                _ = client.connection.write(error_msg) catch {};
            }
            return ChatError.MessageTooLong;
        }

        const client_pool = self.relay_engine.client_pool;
        const client = client_pool.getClient(client_id) orelse return ChatError.ClientNotFound;

        // Get client nickname (should exist for active clients)
        const nickname = client.nickname orelse return ChatError.InvalidClientState;

        // Format message with nickname prefix
        const formatted_msg = try std.fmt.allocPrint(
            self.allocator,
            "[{s}] {s}\n",
            .{ nickname, message },
        );
        defer self.allocator.free(formatted_msg);

        // Relay formatted message to all other clients
        try self.relay_engine.relayData(formatted_msg, client_id);

        logging.logDebug("Chat message from {s}: {s}\n", .{ nickname, message });
    }

    /// Handle nickname change request from a client
    ///
    /// Validates the new nickname, checks for conflicts, updates the client's
    /// nickname, and announces the change to all clients.
    ///
    /// ## Parameters
    /// - `self`: Mutable reference to chat handler
    /// - `client_id`: ID of client changing nickname
    /// - `new_nickname`: New nickname to set
    ///
    /// ## Returns
    /// Error if nickname change fails
    ///
    /// ## Behavior
    /// - Validates new nickname
    /// - Checks for conflicts with existing nicknames
    /// - Updates client nickname
    /// - Broadcasts nickname change notification
    pub fn handleNicknameChange(self: *ChatHandler, client_id: u32, new_nickname: []const u8) !void {
        const client_pool = self.relay_engine.client_pool;
        const client = client_pool.getClient(client_id) orelse return ChatError.ClientNotFound;

        // Validate new nickname
        if (!self.validateNickname(new_nickname)) {
            const error_msg = "*** Invalid nickname. Please use 1-32 characters, no special characters.\n";
            _ = client.connection.write(error_msg) catch {};
            return ChatError.InvalidNickname;
        }

        // Check for nickname conflicts
        if (self.isNicknameTaken(new_nickname, client_id)) {
            const error_msg = "*** Nickname already taken. Please choose another.\n";
            _ = client.connection.write(error_msg) catch {};
            return ChatError.NicknameTaken;
        }

        // Get old nickname for announcement
        const old_nickname = if (client.nickname) |nick|
            try self.allocator.dupe(u8, nick)
        else
            try self.allocator.dupe(u8, "Unknown");
        defer self.allocator.free(old_nickname);

        const previous_nick = client.nickname;
        if (previous_nick) |old| {
            self.unregisterNickname(old);
        }

        self.registerNickname(new_nickname, client_id) catch |err| {
            if (previous_nick) |old| {
                self.registerNickname(old, client_id) catch |restore_err| {
                    logging.logError(restore_err, "restore nickname after register failure");
                };
            }

            const error_msg = "*** Failed to set nickname. Please try again.\n";
            _ = client.connection.write(error_msg) catch {};
            return err;
        };

        // Update client nickname
        client.setNickname(self.allocator, new_nickname) catch |err| {
            self.unregisterNickname(new_nickname);
            if (previous_nick) |old| {
                self.registerNickname(old, client_id) catch |restore_err| {
                    logging.logError(restore_err, "restore nickname after set failure");
                };
            }
            return err;
        };

        // Broadcast nickname change notification
        const change_msg = try std.fmt.allocPrint(
            self.allocator,
            "*** {s} is now known as {s}\n",
            .{ old_nickname, new_nickname },
        );
        defer self.allocator.free(change_msg);

        try self.relay_engine.broadcastNotification(change_msg);

        logging.logDebug("Client {any} changed nickname from {s} to {s}\n", .{ client_id, old_nickname, new_nickname });
    }

    /// Send welcome message to a client
    ///
    /// Sends the standard welcome message and nickname prompt to a newly
    /// connected client.
    ///
    /// ## Parameters
    /// - `self`: Const reference to chat handler
    /// - `client_id`: ID of client to send welcome message to
    ///
    /// ## Returns
    /// Error if welcome message cannot be sent
    fn sendWelcomeMessage(self: *const ChatHandler, client_id: u32) !void {
        const client_pool = self.relay_engine.client_pool;
        const client = client_pool.getClient(client_id) orelse return ChatError.ClientNotFound;

        const bytes_sent = client.connection.write(self.welcome_message) catch {
            return ChatError.SendFailed;
        };

        client.bytes_sent += bytes_sent;
        client.updateActivity();
    }

    /// Validate a nickname for chat mode
    ///
    /// Checks nickname against validation rules including length limits,
    /// character restrictions, and formatting requirements.
    ///
    /// ## Parameters
    /// - `self`: Const reference to chat handler
    /// - `nickname`: Nickname to validate
    ///
    /// ## Returns
    /// True if nickname is valid, false otherwise
    ///
    /// ## Validation Rules
    /// - Length between 1 and max_nickname_len
    /// - No whitespace at start/end
    /// - No control characters
    /// - No special characters that could break formatting
    /// - No reserved words or patterns
    fn validateNickname(self: *const ChatHandler, nickname: []const u8) bool {
        // Check length
        if (nickname.len == 0 or nickname.len > self.max_nickname_len) {
            return false;
        }

        // Check for whitespace at start/end
        const trimmed = std.mem.trim(u8, nickname, " \t\r\n");
        if (trimmed.len != nickname.len) {
            return false;
        }

        // Check for invalid characters
        for (nickname) |char| {
            // Disallow control characters
            if (char < 32 or char == 127) {
                return false;
            }
            // Disallow characters that could break message formatting
            if (char == '[' or char == ']' or char == '\n' or char == '\r') {
                return false;
            }
            // Disallow other problematic characters
            if (char == '*' or char == '/' or char == '\\') {
                return false;
            }
        }

        // Check for reserved patterns
        if (std.mem.startsWith(u8, nickname, "***")) {
            return false; // Reserved for system messages
        }

        return true;
    }

    /// Check if a nickname is already taken by another client
    ///
    /// Uses a hash map of active nicknames for O(1) lookups.
    ///
    /// ## Parameters
    /// - `self`: Const reference to chat handler
    /// - `nickname`: Nickname to check for conflicts
    /// - `exclude_client_id`: Client ID to exclude from check (for nickname changes)
    ///
    /// ## Returns
    /// True if nickname is taken by another client, false otherwise
    fn isNicknameTaken(self: *const ChatHandler, nickname: []const u8, exclude_client_id: u32) bool {
        return self.relay_engine.isNicknameTaken(nickname, exclude_client_id);
    }

    fn registerNickname(self: *ChatHandler, nickname: []const u8, client_id: u32) !void {
        try self.relay_engine.registerNickname(nickname, client_id);
    }

    fn unregisterNickname(self: *ChatHandler, nickname: []const u8) void {
        self.relay_engine.unregisterNickname(nickname);
    }

    /// Parse a nickname command from client input
    ///
    /// Extracts nickname from various command formats that clients might use.
    /// Supports both direct nickname input and command-style input.
    ///
    /// ## Parameters
    /// - `self`: Const reference to chat handler
    /// - `data`: Raw input data from client
    ///
    /// ## Returns
    /// Extracted nickname if found, null otherwise
    ///
    /// ## Supported Formats
    /// - Direct: `nickname`
    /// - Command: `/nick nickname`
    /// - Command: `/name nickname`
    fn parseNicknameCommand(self: *const ChatHandler, data: []const u8) ?[]const u8 {
        _ = self; // Suppress unused parameter warning

        const trimmed = std.mem.trim(u8, data, " \t\r\n");
        if (trimmed.len == 0) return null;

        // Check for /nick command
        if (std.mem.startsWith(u8, trimmed, "/nick ")) {
            const nick_start = 6; // Length of "/nick "
            if (trimmed.len > nick_start) {
                return std.mem.trim(u8, trimmed[nick_start..], " \t");
            }
            return null;
        }

        // Check for /name command
        if (std.mem.startsWith(u8, trimmed, "/name ")) {
            const name_start = 6; // Length of "/name "
            if (trimmed.len > name_start) {
                return std.mem.trim(u8, trimmed[name_start..], " \t");
            }
            return null;
        }

        // Treat as direct nickname input
        return trimmed;
    }

    /// Set maximum nickname length
    ///
    /// ## Parameters
    /// - `self`: Mutable reference to chat handler
    /// - `max_len`: Maximum nickname length in bytes
    pub fn setMaxNicknameLength(self: *ChatHandler, max_len: usize) void {
        self.max_nickname_len = max_len;
    }

    /// Set maximum message length
    ///
    /// ## Parameters
    /// - `self`: Mutable reference to chat handler
    /// - `max_len`: Maximum message length in bytes
    pub fn setMaxMessageLength(self: *ChatHandler, max_len: usize) void {
        self.max_message_len = max_len;
    }

    /// Get current configuration
    ///
    /// ## Parameters
    /// - `self`: Const reference to chat handler
    ///
    /// ## Returns
    /// Tuple of (max_nickname_len, max_message_len)
    pub fn getConfig(self: *const ChatHandler) struct { max_nickname_len: usize, max_message_len: usize } {
        return .{
            .max_nickname_len = self.max_nickname_len,
            .max_message_len = self.max_message_len,
        };
    }
};

// Tests for ChatHandler functionality
test "ChatHandler initialization" {
    const testing = std.testing;
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    var client_pool = @import("client_pool.zig").ClientPool.init(allocator);
    defer client_pool.deinit();

    var relay_engine = @import("relay.zig").RelayEngine.init(allocator, &client_pool, .chat);
    defer relay_engine.deinit();

    var chat_handler = ChatHandler.init(allocator, &relay_engine);
    defer chat_handler.deinit();

    try testing.expect(chat_handler.max_nickname_len == 32);
    try testing.expect(chat_handler.max_message_len == 1024);
}

test "ChatHandler nickname validation" {
    const testing = std.testing;
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    var client_pool = @import("client_pool.zig").ClientPool.init(allocator);
    defer client_pool.deinit();

    var relay_engine = @import("relay.zig").RelayEngine.init(allocator, &client_pool, .chat);
    defer relay_engine.deinit();

    const chat_handler = ChatHandler.init(allocator, &relay_engine);

    // Valid nicknames
    try testing.expect(chat_handler.validateNickname("alice"));
    try testing.expect(chat_handler.validateNickname("user123"));
    try testing.expect(chat_handler.validateNickname("test_user"));
    try testing.expect(chat_handler.validateNickname("Bob"));

    // Invalid nicknames
    try testing.expect(!chat_handler.validateNickname("")); // Empty
    try testing.expect(!chat_handler.validateNickname(" alice")); // Leading space
    try testing.expect(!chat_handler.validateNickname("alice ")); // Trailing space
    try testing.expect(!chat_handler.validateNickname("alice\n")); // Control character
    try testing.expect(!chat_handler.validateNickname("alice[bob]")); // Brackets
    try testing.expect(!chat_handler.validateNickname("***system")); // Reserved pattern
    try testing.expect(!chat_handler.validateNickname("alice*bob")); // Asterisk
    try testing.expect(!chat_handler.validateNickname("a" ** 50)); // Too long
}

test "ChatHandler nickname command parsing" {
    const testing = std.testing;
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    var client_pool = @import("client_pool.zig").ClientPool.init(allocator);
    defer client_pool.deinit();

    var relay_engine = @import("relay.zig").RelayEngine.init(allocator, &client_pool, .chat);
    defer relay_engine.deinit();

    const chat_handler = ChatHandler.init(allocator, &relay_engine);

    // Test direct nickname
    if (chat_handler.parseNicknameCommand("alice")) |nick| {
        try testing.expectEqualStrings("alice", nick);
    } else {
        try testing.expect(false);
    }

    // Test /nick command
    if (chat_handler.parseNicknameCommand("/nick bob")) |nick| {
        try testing.expectEqualStrings("bob", nick);
    } else {
        try testing.expect(false);
    }

    // Test /name command
    if (chat_handler.parseNicknameCommand("/name charlie")) |nick| {
        try testing.expectEqualStrings("charlie", nick);
    } else {
        try testing.expect(false);
    }

    // Test empty input
    try testing.expect(chat_handler.parseNicknameCommand("") == null);
    try testing.expect(chat_handler.parseNicknameCommand("   ") == null);

    // Test incomplete commands
    try testing.expect(chat_handler.parseNicknameCommand("/nick") == null);
    try testing.expect(chat_handler.parseNicknameCommand("/name") == null);
}

test "ChatHandler configuration" {
    const testing = std.testing;
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    var client_pool = @import("client_pool.zig").ClientPool.init(allocator);
    defer client_pool.deinit();

    var relay_engine = @import("relay.zig").RelayEngine.init(allocator, &client_pool, .chat);
    defer relay_engine.deinit();

    var chat_handler = ChatHandler.init(allocator, &relay_engine);

    // Test setting configuration
    chat_handler.setMaxNicknameLength(64);
    chat_handler.setMaxMessageLength(2048);

    const config = chat_handler.getConfig();
    try testing.expect(config.max_nickname_len == 64);
    try testing.expect(config.max_message_len == 2048);
}
</file>

<file path="server/exec_session.zig">
//! Poll-driven exec session that manages child I/O with flow control.
const std = @import("std");
const builtin = @import("builtin");
const mem = std.mem;
const math = std.math;
const posix = std.posix;

const IoRingBuffer = @import("../util/io_ring_buffer.zig").IoRingBuffer;
const TimeoutTracker = @import("../util/timeout_tracker.zig").TimeoutTracker;
const ExecSessionConfig = @import("./exec_types.zig").ExecSessionConfig;
const ExecError = @import("./exec_types.zig").ExecError;
const TelnetConnection = @import("../protocol/telnet_connection.zig").TelnetConnection;

/// Set a POSIX file descriptor to non-blocking mode.
fn setFdNonBlocking(fd: posix.fd_t) !void {
    if (builtin.os.tag == .windows) {
        // Child process pipes on Windows require overlapped I/O; fallback path handles this.
        return error.Unsupported;
    }

    const flags = try posix.fcntl(fd, posix.F.GETFL, 0);
    const o_nonblock: u32 = switch (builtin.os.tag) {
        .linux => 0x0800, // O_NONBLOCK on Linux
        else => 0x0004, // BSD/macOS default
    };
    _ = try posix.fcntl(fd, posix.F.SETFL, flags | o_nonblock);
}

/// Flow control state machine for exec session buffers.
const FlowState = struct {
    pause_threshold_bytes: usize,
    resume_threshold_bytes: usize,
    paused: bool = false,

    /// Update state based on current buffered byte count.
    pub fn update(self: *FlowState, buffered_bytes: usize) void {
        if (!self.paused and buffered_bytes >= self.pause_threshold_bytes) {
            self.paused = true;
        } else if (self.paused and buffered_bytes <= self.resume_threshold_bytes) {
            self.paused = false;
        }
    }

    /// Whether flow control currently pauses new reads.
    pub fn shouldPause(self: *const FlowState) bool {
        return self.paused;
    }
};

/// Compute flow control threshold in bytes from percentage.
fn computeThresholdBytes(max_total: usize, percent: f32) usize {
    if (max_total == 0) return 0;
    var clamped = percent;
    if (clamped < 0.0) clamped = 0.0;
    if (clamped > 1.0) clamped = 1.0;

    const total_f64 = @as(f64, @floatFromInt(max_total));
    const raw = total_f64 * @as(f64, clamped);
    var threshold: usize = @intFromFloat(raw);
    if (threshold == 0 and clamped > 0.0) threshold = 1;
    if (threshold > max_total) threshold = max_total;
    return threshold;
}

pub const ExecSession = struct {
    const socket_index: usize = 0;
    const child_stdin_index: usize = 1;
    const child_stdout_index: usize = 2;
    const child_stderr_index: usize = 3;

    allocator: std.mem.Allocator,
    telnet_conn: *TelnetConnection,
    socket_fd: posix.fd_t,
    child: *std.process.Child,
    stdin_fd: posix.fd_t,
    stdout_fd: posix.fd_t,
    stderr_fd: posix.fd_t,
    poll_fds: [4]posix.pollfd,
    stdin_buffer: IoRingBuffer,
    stdout_buffer: IoRingBuffer,
    stderr_buffer: IoRingBuffer,
    flow_state: FlowState,
    max_total_buffer_bytes: usize,
    tracker: TimeoutTracker,
    config: ExecSessionConfig,
    socket_read_closed: bool = false,
    socket_write_closed: bool = false,
    child_stdin_closed: bool = false,
    child_stdout_closed: bool = false,
    child_stderr_closed: bool = false,
    flow_enabled: bool = true,

    pub fn init(
        allocator: std.mem.Allocator,
        telnet_conn: *TelnetConnection,
        child: *std.process.Child,
        cfg: ExecSessionConfig,
    ) !ExecSession {
        if (builtin.os.tag == .windows) {
            return error.Unsupported;
        }

        const stdin_fd = if (child.stdin) |f| f.handle else -1;
        const stdout_fd = if (child.stdout) |f| f.handle else -1;
        const stderr_fd = if (child.stderr) |f| f.handle else -1;
        const socket_fd: posix.fd_t = telnet_conn.getSocket();

        try setFdNonBlocking(socket_fd);
        if (stdin_fd != -1) try setFdNonBlocking(stdin_fd);
        if (stdout_fd != -1) try setFdNonBlocking(stdout_fd);
        if (stderr_fd != -1) try setFdNonBlocking(stderr_fd);

        var stdin_buffer = try IoRingBuffer.init(allocator, cfg.buffers.stdin_capacity);
        errdefer stdin_buffer.deinit();

        var stdout_buffer = try IoRingBuffer.init(allocator, cfg.buffers.stdout_capacity);
        errdefer stdout_buffer.deinit();

        var stderr_buffer = try IoRingBuffer.init(allocator, cfg.buffers.stderr_capacity);
        errdefer stderr_buffer.deinit();

        const total_capacity = cfg.buffers.stdin_capacity + cfg.buffers.stdout_capacity + cfg.buffers.stderr_capacity;
        var max_total = cfg.flow.max_total_buffer_bytes;
        if (max_total == 0) {
            max_total = total_capacity;
        }
        if (max_total < total_capacity) {
            return ExecError.InvalidConfiguration;
        }

        var pause_bytes = computeThresholdBytes(max_total, cfg.flow.pause_threshold_percent);
        var resume_bytes = computeThresholdBytes(max_total, cfg.flow.resume_threshold_percent);
        var flow_enabled = true;

        if (pause_bytes == 0) {
            flow_enabled = false;
            pause_bytes = max_total;
            resume_bytes = max_total;
        }

        if (resume_bytes >= pause_bytes and pause_bytes > 0) {
            const adjust = @max(@as(usize, 1), pause_bytes / 4);
            if (adjust >= pause_bytes) {
                resume_bytes = pause_bytes - 1;
            } else {
                resume_bytes = pause_bytes - adjust;
            }
        }

        var session = ExecSession{
            .allocator = allocator,
            .telnet_conn = telnet_conn,
            .socket_fd = socket_fd,
            .child = child,
            .stdin_fd = stdin_fd,
            .stdout_fd = stdout_fd,
            .stderr_fd = stderr_fd,
            .poll_fds = .{
                .{ .fd = socket_fd, .events = 0, .revents = 0 },
                .{ .fd = stdin_fd, .events = 0, .revents = 0 },
                .{ .fd = stdout_fd, .events = 0, .revents = 0 },
                .{ .fd = stderr_fd, .events = 0, .revents = 0 },
            },
            .stdin_buffer = stdin_buffer,
            .stdout_buffer = stdout_buffer,
            .stderr_buffer = stderr_buffer,
            .flow_state = FlowState{
                .pause_threshold_bytes = pause_bytes,
                .resume_threshold_bytes = resume_bytes,
            },
            .max_total_buffer_bytes = max_total,
            .tracker = TimeoutTracker.init(cfg.timeouts),
            .config = cfg,
            .socket_read_closed = false,
            .socket_write_closed = false,
            .child_stdin_closed = (stdin_fd == -1),
            .child_stdout_closed = (stdout_fd == -1),
            .child_stderr_closed = (stderr_fd == -1),
            .flow_enabled = flow_enabled,
        };

        try session.updateFlow();
        session.updatePollInterests();

        return session;
    }

    pub fn deinit(self: *ExecSession) void {
        self.stdin_buffer.deinit();
        self.stdout_buffer.deinit();
        self.stderr_buffer.deinit();
    }

    pub fn run(self: *ExecSession) !void {
        while (self.shouldContinue()) {
            try self.checkTimeouts();
            self.updatePollInterests();

            const timeout_ms = self.computePollTimeout();
            const ready = posix.poll(self.poll_fds[0..], timeout_ms) catch |err| switch (err) {
                error.NetworkSubsystemFailed, error.SystemResources, error.Unexpected => return ExecError.PollFailed,
            };

            if (ready == 0) {
                try self.checkTimeouts();
                continue;
            }

            if (self.poll_fds[socket_index].fd != -1) {
                try self.dispatchSocketEvents(self.poll_fds[socket_index].revents);
                self.poll_fds[socket_index].revents = 0;
            }
            if (self.poll_fds[child_stdin_index].fd != -1) {
                try self.dispatchChildStdinEvents(self.poll_fds[child_stdin_index].revents);
                self.poll_fds[child_stdin_index].revents = 0;
            }
            if (self.poll_fds[child_stdout_index].fd != -1) {
                try self.dispatchChildStdoutEvents(self.poll_fds[child_stdout_index].revents);
                self.poll_fds[child_stdout_index].revents = 0;
            }
            if (self.poll_fds[child_stderr_index].fd != -1) {
                try self.dispatchChildStderrEvents(self.poll_fds[child_stderr_index].revents);
                self.poll_fds[child_stderr_index].revents = 0;
            }

            try self.checkTimeouts();
        }

        // Final flush to ensure pending buffers are delivered.
        self.handleSocketWritable() catch {
            // Socket may already be closed, that's OK
        };
        self.maybeShutdownSocketWrite();
    }

    fn totalBuffered(self: *const ExecSession) usize {
        return self.stdin_buffer.availableRead() +
            self.stdout_buffer.availableRead() +
            self.stderr_buffer.availableRead();
    }

    fn updateFlow(self: *ExecSession) !void {
        const total = self.totalBuffered();
        if (self.flow_enabled and total > self.max_total_buffer_bytes) {
            return ExecError.FlowControlTriggered;
        }

        if (self.flow_enabled) {
            self.flow_state.update(total);
        }
    }

    fn updatePollInterests(self: *ExecSession) void {
        const pause_reads = self.flow_enabled and self.flow_state.shouldPause();

        // Socket poll events
        if (self.socket_read_closed and self.socket_write_closed) {
            self.poll_fds[socket_index].fd = -1;
            self.poll_fds[socket_index].events = 0;
        } else {
            self.poll_fds[socket_index].fd = self.socket_fd;
            var events: i16 = posix.POLL.ERR | posix.POLL.HUP;
            if (!self.socket_read_closed and !pause_reads and !self.child_stdin_closed and self.stdin_buffer.availableWrite() > 0) {
                events |= posix.POLL.IN;
            }
            if (!self.socket_write_closed and (self.stdout_buffer.availableRead() > 0 or self.stderr_buffer.availableRead() > 0)) {
                events |= posix.POLL.OUT;
            }
            self.poll_fds[socket_index].events = events;
        }

        // Child stdin events (writing data to child)
        if (self.child_stdin_closed) {
            self.poll_fds[child_stdin_index].fd = -1;
            self.poll_fds[child_stdin_index].events = 0;
        } else {
            self.poll_fds[child_stdin_index].fd = self.stdin_fd;
            var events: i16 = posix.POLL.ERR | posix.POLL.HUP;
            if (self.stdin_buffer.availableRead() > 0) {
                events |= posix.POLL.OUT;
            }
            self.poll_fds[child_stdin_index].events = events;
        }

        // Child stdout events (reading data from child)
        if (self.child_stdout_closed) {
            self.poll_fds[child_stdout_index].fd = -1;
            self.poll_fds[child_stdout_index].events = 0;
        } else {
            self.poll_fds[child_stdout_index].fd = self.stdout_fd;
            var events: i16 = posix.POLL.ERR | posix.POLL.HUP;
            if (!pause_reads and self.stdout_buffer.availableWrite() > 0) {
                events |= posix.POLL.IN;
            }
            self.poll_fds[child_stdout_index].events = events;
        }

        // Child stderr events (reading data from child)
        if (self.child_stderr_closed) {
            self.poll_fds[child_stderr_index].fd = -1;
            self.poll_fds[child_stderr_index].events = 0;
        } else {
            self.poll_fds[child_stderr_index].fd = self.stderr_fd;
            var events: i16 = posix.POLL.ERR | posix.POLL.HUP;
            if (!pause_reads and self.stderr_buffer.availableWrite() > 0) {
                events |= posix.POLL.IN;
            }
            self.poll_fds[child_stderr_index].events = events;
        }
    }

    fn computePollTimeout(self: *ExecSession) i32 {
        const next = self.tracker.nextPollTimeout(null);
        if (next) |ms| {
            if (ms == 0) return 0;
            if (ms > @as(u64, math.maxInt(i32))) {
                return math.maxInt(i32);
            }
            return @intCast(ms);
        }
        return -1;
    }

    fn checkTimeouts(self: *ExecSession) !void {
        switch (self.tracker.check()) {
            .none => {},
            .execution => {
                _ = self.child.kill() catch {};
                return ExecError.TimeoutExecution;
            },
            .idle => {
                _ = self.child.kill() catch {};
                return ExecError.TimeoutIdle;
            },
            .connection => {
                _ = self.child.kill() catch {};
                return ExecError.TimeoutConnection;
            },
        }
    }

    fn shouldContinue(self: *const ExecSession) bool {
        // Continue if we have output to deliver to socket
        if (!self.socket_write_closed and (self.stdout_buffer.availableRead() > 0 or self.stderr_buffer.availableRead() > 0)) return true;

        // Continue if child output is still open
        if (!self.child_stdout_closed or !self.child_stderr_closed) return true;

        // Continue if we have buffered data to deliver to child AND child stdin is open
        if (!self.child_stdin_closed and self.stdin_buffer.availableRead() > 0) return true;

        // Continue if socket is readable AND child stdin is open
        if (!self.socket_read_closed and !self.child_stdin_closed) return true;

        return false;
    }

    fn handleSocketReadable(self: *ExecSession) !void {
        while (!self.socket_read_closed and !self.child_stdin_closed) {
            if (self.flow_enabled and self.flow_state.shouldPause()) break;
            const writable = self.stdin_buffer.writableSlice();
            if (writable.len == 0) break;

            const read_bytes = self.telnet_conn.read(writable) catch |err| {
                switch (err) {
                    error.WouldBlock => return,
                    error.ConnectionResetByPeer, error.BrokenPipe => {
                        self.socket_read_closed = true;
                        return;
                    },
                    else => {
                        // Log but don't fail - socket may already be closed
                        self.socket_read_closed = true;
                        return;
                    },
                }
            };

            if (read_bytes == 0) {
                self.socket_read_closed = true;
                break;
            }

            self.stdin_buffer.commitWrite(read_bytes);
            self.tracker.markActivity();
            try self.updateFlow();

            if (read_bytes < writable.len) break;
        }

        try self.handleChildStdinWritable();
    }

    fn handleSocketWritable(self: *ExecSession) !void {
        if (self.socket_write_closed) return;

        try self.flushBufferToSocket(&self.stdout_buffer);
        try self.flushBufferToSocket(&self.stderr_buffer);
        self.maybeShutdownSocketWrite();
    }

    fn flushBufferToSocket(self: *ExecSession, buffer: *IoRingBuffer) !void {
        while (!self.socket_write_closed and buffer.availableRead() > 0) {
            const chunk = buffer.readableSlice();
            if (chunk.len == 0) break;

            const written = self.telnet_conn.write(chunk) catch |err| {
                switch (err) {
                    error.WouldBlock => return,
                    error.ConnectionResetByPeer, error.BrokenPipe => {
                        self.socket_write_closed = true;
                        return;
                    },
                    else => {
                        // Log but don't fail - socket may already be closed
                        self.socket_write_closed = true;
                        return;
                    },
                }
            };

            if (written == 0) break;

            buffer.consume(written);
            self.tracker.markActivity();
            try self.updateFlow();

            if (written < chunk.len) break;
        }
    }

    fn handleChildStdoutReadable(self: *ExecSession) !void {
        while (!self.child_stdout_closed) {
            if (self.flow_enabled and self.flow_state.shouldPause()) break;
            const writable = self.stdout_buffer.writableSlice();
            if (writable.len == 0) break;

            const read_bytes = posix.read(self.stdout_fd, writable) catch |err| {
                switch (err) {
                    error.WouldBlock => return,
                    error.BrokenPipe => {
                        self.closeChildStdout();
                        return;
                    },
                    else => {
                        // Child may have exited - close stdout and continue
                        self.closeChildStdout();
                        return;
                    },
                }
            };

            if (read_bytes == 0) {
                self.closeChildStdout();
                break;
            }

            self.stdout_buffer.commitWrite(read_bytes);
            self.tracker.markActivity();
            try self.updateFlow();

            if (read_bytes < writable.len) break;
        }

        try self.handleSocketWritable();
    }

    fn handleChildStderrReadable(self: *ExecSession) !void {
        while (!self.child_stderr_closed) {
            if (self.flow_enabled and self.flow_state.shouldPause()) break;
            const writable = self.stderr_buffer.writableSlice();
            if (writable.len == 0) break;

            const read_bytes = posix.read(self.stderr_fd, writable) catch |err| {
                switch (err) {
                    error.WouldBlock => return,
                    error.BrokenPipe => {
                        self.closeChildStderr();
                        return;
                    },
                    else => {
                        // Child may have exited - close stderr and continue
                        self.closeChildStderr();
                        return;
                    },
                }
            };

            if (read_bytes == 0) {
                self.closeChildStderr();
                break;
            }

            self.stderr_buffer.commitWrite(read_bytes);
            self.tracker.markActivity();
            try self.updateFlow();

            if (read_bytes < writable.len) break;
        }

        try self.handleSocketWritable();
    }

    fn handleChildStdinWritable(self: *ExecSession) !void {
        while (!self.child_stdin_closed and self.stdin_buffer.availableRead() > 0) {
            const chunk = self.stdin_buffer.readableSlice();
            if (chunk.len == 0) break;

            const written = posix.write(self.stdin_fd, chunk) catch |err| {
                switch (err) {
                    error.WouldBlock => return,
                    error.BrokenPipe => {
                        self.closeChildStdin();
                        return;
                    },
                    else => {
                        // Child may have exited - close stdin and continue
                        self.closeChildStdin();
                        return;
                    },
                }
            };

            if (written == 0) break;

            self.stdin_buffer.consume(written);
            self.tracker.markActivity();
            try self.updateFlow();

            if (written < chunk.len) break;
        }

        if (self.socket_read_closed and self.stdin_buffer.availableRead() == 0) {
            self.closeChildStdin();
        }
    }

    fn closeChildStdout(self: *ExecSession) void {
        if (self.child_stdout_closed) return;
        if (self.child.stdout) |file| {
            file.close();
            self.child.stdout = null;
        }
        self.child_stdout_closed = true;
        self.poll_fds[child_stdout_index].fd = -1;
    }

    fn closeChildStderr(self: *ExecSession) void {
        if (self.child_stderr_closed) return;
        if (self.child.stderr) |file| {
            file.close();
            self.child.stderr = null;
        }
        self.child_stderr_closed = true;
        self.poll_fds[child_stderr_index].fd = -1;
    }

    fn closeChildStdin(self: *ExecSession) void {
        if (self.child_stdin_closed) return;
        if (self.child.stdin) |file| {
            file.close();
            self.child.stdin = null;
        }
        self.child_stdin_closed = true;
        self.poll_fds[child_stdin_index].fd = -1;
    }

    fn maybeShutdownSocketWrite(self: *ExecSession) void {
        if (self.socket_write_closed) return;
        if (self.stdout_buffer.availableRead() > 0 or self.stderr_buffer.availableRead() > 0) return;
        if (!self.child_stdout_closed or !self.child_stderr_closed) return;

        if (builtin.os.tag != .windows) {
            _ = posix.shutdown(self.socket_fd, .send) catch {};
        }
        self.socket_write_closed = true;
    }

    fn dispatchSocketEvents(self: *ExecSession, revents: i16) !void {
        if (revents == 0) return;
        if ((revents & posix.POLL.NVAL) != 0) {
            // Invalid FD - socket was closed, mark as disconnected
            self.socket_read_closed = true;
            self.socket_write_closed = true;
            if (self.stdin_buffer.availableRead() == 0) {
                self.closeChildStdin();
            }
            return;
        }
        if ((revents & posix.POLL.IN) != 0) {
            try self.handleSocketReadable();
        }
        if ((revents & posix.POLL.OUT) != 0) {
            try self.handleSocketWritable();
        }
        if ((revents & posix.POLL.HUP) != 0) {
            self.socket_read_closed = true;
            if (self.stdin_buffer.availableRead() == 0) {
                self.closeChildStdin();
            }
        }
        if ((revents & posix.POLL.ERR) != 0) {
            // Socket error - could be normal disconnection
            // Mark socket as closed but don't fail immediately
            self.socket_read_closed = true;
            self.socket_write_closed = true;
            if (self.stdin_buffer.availableRead() == 0) {
                self.closeChildStdin();
            }
        }
    }

    fn dispatchChildStdinEvents(self: *ExecSession, revents: i16) !void {
        if (revents == 0 or self.child_stdin_closed) return;
        if ((revents & posix.POLL.OUT) != 0) {
            try self.handleChildStdinWritable();
        }
        if ((revents & (posix.POLL.HUP | posix.POLL.ERR)) != 0) {
            self.closeChildStdin();
        }
    }

    fn dispatchChildStdoutEvents(self: *ExecSession, revents: i16) !void {
        if (revents == 0 or self.child_stdout_closed) return;
        if ((revents & posix.POLL.IN) != 0) {
            try self.handleChildStdoutReadable();
        }
        if ((revents & (posix.POLL.HUP | posix.POLL.ERR)) != 0) {
            self.closeChildStdout();
        }
    }

    fn dispatchChildStderrEvents(self: *ExecSession, revents: i16) !void {
        if (revents == 0 or self.child_stderr_closed) return;
        if ((revents & posix.POLL.IN) != 0) {
            try self.handleChildStderrReadable();
        }
        if ((revents & (posix.POLL.HUP | posix.POLL.ERR)) != 0) {
            self.closeChildStderr();
        }
    }
};
</file>

<file path="server/exec_threaded.zig">
//! Thread-based execution logic for Windows and Telnet.
const std = @import("std");
const logging = @import("../util/logging.zig");

const ExecConfig = @import("./exec_types.zig").ExecConfig;
const ExecError = @import("./exec_types.zig").ExecError;

/// Fallback threaded execution path (primarily for Windows).
pub fn runThreadedExec(stream: std.net.Stream, child: *std.process.Child) !void {
    var stdin_thread: ?std.Thread = null;
    var stdout_thread: ?std.Thread = null;
    var stderr_thread: ?std.Thread = null;

    if (child.stdin) |stdin_file| {
        stdin_thread = std.Thread.spawn(.{}, pipeToChild, .{
            stream,
            stdin_file,
        }) catch |err| {
            logging.logError(err, "Failed to spawn stdin thread");
            return ExecError.ThreadSpawnFailed;
        };
        child.stdin = null;
    }

    if (child.stdout) |stdout_file| {
        stdout_thread = std.Thread.spawn(.{}, pipeFromChild, .{
            stdout_file,
            stream,
        }) catch |err| {
            logging.logError(err, "Failed to spawn stdout thread");
            if (stdin_thread) |t| t.detach();
            return ExecError.ThreadSpawnFailed;
        };
        child.stdout = null;
    }

    if (child.stderr) |stderr_file| {
        stderr_thread = std.Thread.spawn(.{}, pipeFromChild, .{
            stderr_file,
            stream,
        }) catch |err| {
            logging.logError(err, "Failed to spawn stderr thread");
            if (stdin_thread) |t| t.detach();
            if (stdout_thread) |t| t.detach();
            return ExecError.ThreadSpawnFailed;
        };
        child.stderr = null;
    }

    if (stdin_thread) |t| t.join();
    if (stdout_thread) |t| t.join();
    if (stderr_thread) |t| t.join();
}

/// Pipe data from socket to child stdin
fn pipeToChild(src: std.net.Stream, dst: std.fs.File) void {
    defer dst.close();

    var buf: [8192]u8 = undefined;
    while (true) {
        const n = src.read(&buf) catch |err| {
            if (err != error.ConnectionResetByPeer and err != error.BrokenPipe) {
                logging.logDebug("Socket read error: {any}\n", .{err});
            }
            break;
        };
        if (n == 0) break;

        _ = dst.write(buf[0..n]) catch |err| {
            if (err != error.BrokenPipe) {
                logging.logDebug("Child stdin write error: {any}\n", .{err});
            }
            break;
        };
    }
}

/// Pipe data from child stdout/stderr to socket
fn pipeFromChild(src: std.fs.File, dst: std.net.Stream) void {
    defer src.close();

    var buf: [8192]u8 = undefined;
    while (true) {
        const n = src.read(&buf) catch |err| {
            if (err != error.BrokenPipe) {
                logging.logDebug("Child output read error: {any}\n", .{err});
            }
            break;
        };
        if (n == 0) break;

        _ = dst.write(buf[0..n]) catch |err| {
            if (err != error.ConnectionResetByPeer and err != error.BrokenPipe) {
                logging.logDebug("Socket write error: {any}\n", .{err});
            }
            break;
        };
    }
}

/// Execute command with Telnet protocol processing enabled.
pub fn executeWithTelnetConnectionThreaded(
    allocator: std.mem.Allocator,
    telnet_conn: anytype, // *TelnetConnection
    exec_config: ExecConfig,
    client_addr: std.net.Address,
) !void {
    // SECURITY WARNING: Log this dangerous operation
    logging.logNormal("\n", .{});
    logging.logNormal(" SECURITY: Executing command (Telnet)    \n", .{});
    logging.logNormal(" Program: {s:<31}\n", .{exec_config.program});
    logging.logNormal(" Client:  {any:<31}\n", .{client_addr});
    logging.logNormal(" Mode:    {s:<31}\n", .{@tagName(exec_config.mode)});
    logging.logNormal("\n", .{});

    // Build command with args
    var argv = std.ArrayList([]const u8){};
    defer argv.deinit(allocator);

    try argv.append(allocator, exec_config.program);
    for (exec_config.args) |arg| {
        try argv.append(allocator, arg);
    }

    // Create child process with pipes
    var child = std.process.Child.init(argv.items, allocator);
    if (exec_config.redirect_stdin) {
        child.stdin_behavior = .Pipe;
    } else {
        child.stdin_behavior = .Inherit;
    }
    if (exec_config.redirect_stdout) {
        child.stdout_behavior = .Pipe;
    } else {
        child.stdout_behavior = .Inherit;
    }
    if (exec_config.redirect_stderr) {
        child.stderr_behavior = .Pipe;
    } else {
        child.stderr_behavior = .Inherit;
    }

    // Spawn child process
    try child.spawn();
    errdefer {
        _ = child.kill() catch {};
    }

    // Extract pipes (spawn() creates them, we take ownership)
    var stdin_thread: ?std.Thread = null;
    var stdout_thread: ?std.Thread = null;
    var stderr_thread: ?std.Thread = null;

    if (child.stdin) |stdin_file| {
        stdin_thread = std.Thread.spawn(.{}, pipeToChildTelnet, .{
            telnet_conn,
            stdin_file,
        }) catch |err| {
            logging.logError(err, "Failed to spawn stdin thread");
            return ExecError.ThreadSpawnFailed;
        };
        child.stdin = null;
    }

    if (child.stdout) |stdout_file| {
        stdout_thread = std.Thread.spawn(.{}, pipeFromChildTelnet, .{
            stdout_file,
            telnet_conn,
        }) catch |err| {
            logging.logError(err, "Failed to spawn stdout thread");
            if (stdin_thread) |t| t.detach();
            return ExecError.ThreadSpawnFailed;
        };
        child.stdout = null;
    }

    if (child.stderr) |stderr_file| {
        stderr_thread = std.Thread.spawn(.{}, pipeFromChildTelnet, .{
            stderr_file,
            telnet_conn,
        }) catch |err| {
            logging.logError(err, "Failed to spawn stderr thread");
            if (stdin_thread) |t| t.detach();
            if (stdout_thread) |t| t.detach();
            return ExecError.ThreadSpawnFailed;
        };
        child.stderr = null;
    }

    if (stdin_thread) |t| t.join();
    if (stdout_thread) |t| t.join();
    if (stderr_thread) |t| t.join();
}

/// Pipe data from Telnet connection to child stdin (with IAC filtering).
fn pipeToChildTelnet(telnet_conn: anytype, dst: std.fs.File) void {
    defer dst.close();

    var buf: [8192]u8 = undefined;
    while (true) {
        // TelnetConnection.read() filters IAC sequences automatically
        const n = telnet_conn.read(&buf) catch |err| {
            if (err != error.ConnectionResetByPeer and err != error.BrokenPipe) {
                logging.logDebug("Telnet read error: {any}\n", .{err});
            }
            break;
        };
        if (n == 0) break; // EOF

        // Write application data to child stdin
        dst.writeAll(buf[0..n]) catch |err| {
            if (err != error.BrokenPipe) {
                logging.logDebug("Child stdin write error: {any}\n", .{err});
            }
            break;
        };
    }
}

/// Pipe data from child stdout/stderr to Telnet connection (with IAC escaping).
fn pipeFromChildTelnet(src: std.fs.File, telnet_conn: anytype) void {
    defer src.close();

    var buf: [8192]u8 = undefined;
    while (true) {
        const n = src.read(&buf) catch |err| {
            if (err != error.BrokenPipe) {
                logging.logDebug("Child output read error: {any}\n", .{err});
            }
            break;
        };
        if (n == 0) break; // EOF

        // TelnetConnection.write() escapes IAC bytes automatically
        _ = telnet_conn.write(buf[0..n]) catch |err| {
            if (err != error.ConnectionResetByPeer and err != error.BrokenPipe) {
                logging.logDebug("Telnet write error: {any}\n", .{err});
            }
            break;
        };
    }
}
</file>

<file path="server/exec_types.zig">
//! Type definitions for the exec module.
const std = @import("std");
const timeout = @import("../util/timeout_tracker.zig");

/// Execution mode for command invocation
pub const ExecMode = enum {
    /// Direct execution: -e program args
    /// Executes program directly with argument array
    direct,

    /// Shell execution: -c "command string"
    /// Invokes platform shell (cmd.exe or /bin/sh) with command string
    shell,
};

/// Buffer sizing for exec session I/O channels.
pub const ExecBufferConfig = struct {
    /// Bytes allocated for client  child stdin buffering
    stdin_capacity: usize = 32 * 1024,
    /// Bytes allocated for child stdout  client buffering
    stdout_capacity: usize = 64 * 1024,
    /// Bytes allocated for child stderr  client buffering
    stderr_capacity: usize = 32 * 1024,
};

/// Flow control thresholds to prevent memory exhaustion.
pub const ExecFlowConfig = struct {
    /// Maximum total buffered bytes across all I/O channels (0 = auto)
    max_total_buffer_bytes: usize = 256 * 1024,
    /// Pause reading when buffered bytes exceed this percentage
    pause_threshold_percent: f32 = 0.85,
    /// Resume reading after buffered bytes drop below this percentage
    resume_threshold_percent: f32 = 0.60,
};

/// Aggregated configuration for exec session runtime.
pub const ExecSessionConfig = struct {
    buffers: ExecBufferConfig = .{},
    timeouts: timeout.TimeoutConfig = .{},
    flow: ExecFlowConfig = .{},
};

/// Configuration for command execution on connection
pub const ExecConfig = struct {
    /// Execution mode (direct vs shell)
    mode: ExecMode,

    /// Program path to execute (e.g., "/bin/sh", "cmd.exe")
    program: []const u8,

    /// Argument array for program (MEMORY: caller must free if heap-allocated)
    args: []const []const u8,

    /// SECURITY: Require --allow flag for access control (default: true)
    /// Setting to false allows ANY client to execute the program
    require_allow: bool = true,

    /// Runtime configuration for buffers, timeouts, and flow control
    session_config: ExecSessionConfig = .{},

    /// Redirect socket to child process stdin
    redirect_stdin: bool = true,
    /// Redirect child process stdout to socket
    redirect_stdout: bool = true,
    /// Redirect child process stderr to socket
    redirect_stderr: bool = true,
};

/// Errors that can occur during command execution
pub const ExecError = error{
    /// Failed to spawn child process (program not found, permissions, etc.)
    SpawnFailed,

    /// Failed to create pipe for stdin/stdout/stderr redirection
    PipeFailed,

    /// Failed to spawn I/O thread (socketchild communication)
    ThreadSpawnFailed,

    /// Failed to wait for child process termination
    ChildWaitFailed,

    /// Memory allocation failed during command setup
    OutOfMemory,

    /// poll() system call failed
    PollFailed,

    /// Execution time exceeded configured limit
    TimeoutExecution,

    /// Idle timeout exceeded without I/O
    TimeoutIdle,

    /// Connection timeout exceeded without initial activity
    TimeoutConnection,

    /// Flow control hard limit exceeded
    FlowControlTriggered,

    /// General I/O failure on socket or child pipes
    IoError,

    /// Invalid session configuration detected
    InvalidConfiguration,
};
</file>

<file path="server/exec.zig">
//! Execute command on connection (-e/-c flags)
//!
//! SECURITY CRITICAL: This module handles remote command execution,
//! which is inherently dangerous. All operations log security events
//! and require explicit access control via --allow flag.
const std = @import("std");
const builtin = @import("builtin");
const config = @import("../config.zig");
const logging = @import("../util/logging.zig");

const session = @import("./exec_session.zig");
const threaded = @import("./exec_threaded.zig");
const types = @import("./exec_types.zig");

pub const ExecMode = types.ExecMode;
pub const ExecBufferConfig = types.ExecBufferConfig;
pub const ExecFlowConfig = types.ExecFlowConfig;
pub const ExecSessionConfig = types.ExecSessionConfig;
pub const ExecConfig = types.ExecConfig;
pub const ExecError = types.ExecError;

pub const ExecSession = session.ExecSession;
const executeWithTelnetConnectionThreaded = threaded.executeWithTelnetConnectionThreaded;

/// Execute a program with the socket as stdin/stdout/stderr
///
/// SECURITY WARNING: This function executes arbitrary programs with network I/O,
/// allowing remote clients to run commands on the server. Use with extreme caution.
///
/// Architecture:
/// 1. Spawns a child process using the provided program and arguments.
/// 2. On Unix-like systems, it uses a poll-driven session (`ExecSession`) to manage
///    I/O between the socket and the child process pipes in a single thread.
/// 3. On Windows, it falls back to a thread-per-pipe implementation (`runThreadedExec`).
/// 4. Waits for the child process to terminate and logs the result.
///
/// Memory Management:
/// - Uses ArrayList.deinit(allocator) for Zig 0.15.1 compatibility
/// - Socket and pipes closed via defer/errdefer on error paths
///
/// Parameters:
/// - allocator: Memory allocator for ArrayList operations
/// - socket: Connected client socket (already established connection)
/// - exec_config: Command configuration (program, args, mode)
/// - client_addr: Client IP address for security logging
///
/// Returns:
/// - error.ThreadSpawnFailed if I/O thread creation fails (on Windows)
/// - error.ChildWaitFailed if process termination wait fails
/// - std.process.Child.SpawnError on process spawn failure
///
/// Security:
/// - Logs SECURITY WARNING with program name and client address
/// - Displays boxed warning to stderr for operator visibility
/// - Should only be called after validateExecSecurity() check
pub fn executeWithConnection(
    allocator: std.mem.Allocator,
    socket: std.net.Stream,
    exec_config: ExecConfig,
    client_addr: std.net.Address,
    _: *const config.Config,
) !void {
    // SECURITY WARNING: Log this dangerous operation (always printed)
    logging.logWarning("\n", .{});
    logging.logWarning(" SECURITY: Executing command              \n", .{});
    logging.logWarning(" Program: {s:<31}\n", .{exec_config.program});
    logging.logWarning(" Client:  {any:<31}\n", .{client_addr});
    logging.logWarning(" Mode:    {s:<31}\n", .{@tagName(exec_config.mode)});
    logging.logWarning("\n", .{});

    var argv = std.ArrayList([]const u8){};
    defer argv.deinit(allocator);

    try argv.append(allocator, exec_config.program);
    for (exec_config.args) |arg| {
        try argv.append(allocator, arg);
    }

    var child = std.process.Child.init(argv.items, allocator);
    if (exec_config.redirect_stdin) {
        child.stdin_behavior = .Pipe;
    } else {
        child.stdin_behavior = .Inherit;
    }
    if (exec_config.redirect_stdout) {
        child.stdout_behavior = .Pipe;
    } else {
        child.stdout_behavior = .Inherit;
    }
    if (exec_config.redirect_stderr) {
        child.stderr_behavior = .Pipe;
    } else {
        child.stderr_behavior = .Inherit;
    }

    try child.spawn();
    errdefer {
        _ = child.kill() catch {};
        _ = child.wait() catch {};
    }

    if (builtin.os.tag == .windows) {
        threaded.runThreadedExec(socket, &child) catch |err| {
            closeChildPipes(&child);
            _ = child.kill() catch {};
            return err;
        };
    } else {
        var exec_session = try session.ExecSession.init(allocator, socket, &child, exec_config.session_config);
        defer exec_session.deinit();

        exec_session.run() catch |err| {
            closeChildPipes(&child);
            _ = child.kill() catch {};
            return err;
        };
    }

    closeChildPipes(&child);

    const term = child.wait() catch |err| {
        switch (err) {
            error.FileNotFound => {},
            else => logging.logError(err, "Failed to wait for child"),
        }
        return err;
    };

    switch (term) {
        .Exited => |code| logging.log(1, "Child process exited with code: {any}\n", .{code}),
        .Signal => |sig| logging.log(1, "Child process terminated by signal: {any}\n", .{sig}),
        .Stopped => |sig| logging.log(1, "Child process stopped by signal: {any}\n", .{sig}),
        .Unknown => |code| logging.log(1, "Child process exited with unknown status: {any}\n", .{code}),
    }
}

/// Ensure child process pipes are closed and optionals cleared.
pub fn closeChildPipes(child: *std.process.Child) void {
    if (child.stdin) |file| {
        file.close();
        child.stdin = null;
    }
    if (child.stdout) |file| {
        file.close();
        child.stdout = null;
    }
    if (child.stderr) |file| {
        file.close();
        child.stderr = null;
    }
}

/// Build shell command for -c mode
pub fn buildShellCommand(
    allocator: std.mem.Allocator,
    command_string: []const u8,
) !struct { program: []const u8, args: []const []const u8 } {
    const shell_path = if (builtin.os.tag == .windows) "cmd.exe" else "/bin/sh";
    const shell_arg = if (builtin.os.tag == .windows) "/c" else "-c";

    const args_arr = try allocator.alloc([]const u8, 2);
    args_arr[0] = shell_arg;
    args_arr[1] = command_string;

    return .{
        .program = shell_path,
        .args = args_arr,
    };
}

test "buildShellCommand Unix" {
    const allocator = std.testing.allocator;

    const result = try buildShellCommand(allocator, "echo hello");
    defer allocator.free(result.args);

    if (builtin.os.tag != .windows) {
        try std.testing.expectEqualStrings("/bin/sh", result.program);
        try std.testing.expectEqual(@as(usize, 2), result.args.len);
        try std.testing.expectEqualStrings("-c", result.args[0]);
    }
}

pub fn executeWithTelnetConnection(
    allocator: std.mem.Allocator,
    telnet_conn: anytype,
    exec_config: ExecConfig,
    client_addr: std.net.Address,
    _: *const config.Config,
) !void {
    if (builtin.os.tag == .windows) {
        return executeWithTelnetConnectionThreaded(allocator, telnet_conn, exec_config, client_addr);
    }

    // POSIX implementation using ExecSession
    logging.log(1, "Executing command with Telnet...\n", .{});

    var argv = std.ArrayList([]const u8){};
    defer argv.deinit(allocator);

    try argv.append(allocator, exec_config.program);
    for (exec_config.args) |arg| {
        try argv.append(allocator, arg);
    }

    var child = std.process.Child.init(argv.items, allocator);
    if (exec_config.redirect_stdin) {
        child.stdin_behavior = .Pipe;
    } else {
        child.stdin_behavior = .Inherit;
    }
    if (exec_config.redirect_stdout) {
        child.stdout_behavior = .Pipe;
    } else {
        child.stdout_behavior = .Inherit;
    }
    if (exec_config.redirect_stderr) {
        child.stderr_behavior = .Pipe;
    } else {
        child.stderr_behavior = .Inherit;
    }

    try child.spawn();
    errdefer {
        _ = child.kill() catch {};
        _ = child.wait() catch {};
    }

    var exec_session = try session.ExecSession.init(allocator, telnet_conn, &child, exec_config.session_config);
    defer exec_session.deinit();

    exec_session.run() catch |err| {
        closeChildPipes(&child);
        _ = child.kill() catch {};
        return err;
    };

    closeChildPipes(&child);

    const term = child.wait() catch |err| {
        switch (err) {
            error.FileNotFound => {},
            else => logging.logError(err, "Failed to wait for child"),
        }
        return err;
    };

    switch (term) {
        .Exited => |code| logging.log(1, "Child process exited with code: {any}\n", .{code}),
        .Signal => |sig| logging.log(1, "Child process terminated by signal: {any}\n", .{sig}),
        .Stopped => |sig| logging.log(1, "Child process stopped by signal: {any}\n", .{sig}),
        .Unknown => |code| logging.log(1, "Child process exited with unknown status: {any}\n", .{code}),
    }
}
</file>

<file path="server/flow_control.zig">
//! Flow Control Manager for Resource Management
//!
//! This module implements flow control mechanisms to prevent memory exhaustion
//! and manage resource usage in broker/chat mode. It provides backpressure
//! mechanisms, resource monitoring, and graceful degradation under load.
//!
//! ## Design Goals
//!
//! - **Backpressure Management**: Prevent memory exhaustion with flow control
//! - **Resource Monitoring**: Track system resource usage in real-time
//! - **Graceful Degradation**: Handle resource pressure without crashing
//! - **Client Prioritization**: Manage resources fairly across clients
//! - **Performance Metrics**: Provide detailed performance monitoring
//!
//! ## Architecture
//!
//! ```
//!         
//!    Resource             Flow Control          Backpressure  
//!    Monitor          Manager           Controller    
//!                                                             
//!         
//!                                                        
//!                                                        
//!         
//!    Memory               Client                Rate          
//!    Tracking             Throttling            Limiting      
//!                                                             
//!         
//! ```

const std = @import("std");
const builtin = @import("builtin");
const logging = @import("../util/logging.zig");

/// Flow control configuration
pub const FlowControlConfig = struct {
    /// Maximum memory usage before triggering flow control (bytes)
    max_memory_usage: usize = 32 * 1024 * 1024, // 32MB default
    /// Memory usage threshold to start flow control (0.0-1.0)
    flow_control_threshold: f32 = 0.75, // 75%
    /// Memory usage threshold for aggressive throttling (0.0-1.0)
    throttle_threshold: f32 = 0.85, // 85%
    /// Memory usage threshold for emergency mode (0.0-1.0)
    emergency_threshold: f32 = 0.95, // 95%
    /// Maximum bytes per second per client (0 = unlimited)
    max_bytes_per_second_per_client: usize = 1024 * 1024, // 1MB/s
    /// Maximum pending bytes per client before dropping
    max_pending_bytes_per_client: usize = 64 * 1024, // 64KB
    /// Time window for rate limiting (milliseconds)
    rate_limit_window_ms: u64 = 1000, // 1 second
    /// Cleanup interval for resource monitoring (milliseconds)
    cleanup_interval_ms: u64 = 5000, // 5 seconds
    /// Enable adaptive flow control based on system load
    adaptive_flow_control: bool = true,
};

/// Flow control state levels
pub const FlowControlLevel = enum {
    /// Normal operation, no restrictions
    normal,
    /// Light flow control, minor restrictions
    light,
    /// Moderate flow control, significant restrictions
    moderate,
    /// Heavy flow control, severe restrictions
    heavy,
    /// Emergency mode, drop connections if necessary
    emergency,

    /// Get human-readable description
    pub fn description(self: FlowControlLevel) []const u8 {
        return switch (self) {
            .normal => "Normal",
            .light => "Light Flow Control",
            .moderate => "Moderate Flow Control",
            .heavy => "Heavy Flow Control",
            .emergency => "Emergency Mode",
        };
    }
};

/// Client flow control state
pub const ClientFlowState = struct {
    /// Client ID
    client_id: u32,
    /// Bytes sent in current time window
    bytes_sent_window: u64 = 0,
    /// Bytes pending to be sent
    bytes_pending: u64 = 0,
    /// Timestamp of current rate limit window start
    window_start: i64,
    /// Number of times client was throttled
    throttle_count: u64 = 0,
    /// Last time client was throttled
    last_throttle_time: i64 = 0,
    /// Client priority (higher = more important)
    priority: u8 = 128, // Default medium priority

    /// Initialize client flow state
    pub fn init(client_id: u32) ClientFlowState {
        return ClientFlowState{
            .client_id = client_id,
            .window_start = std.time.timestamp(),
        };
    }

    /// Check if client should be rate limited
    pub fn shouldRateLimit(self: *const ClientFlowState, config: *const FlowControlConfig) bool {
        const now = std.time.timestamp();
        const window_duration_ms = @as(u64, @intCast(now - self.window_start)) * 1000;

        // Reset window if expired
        if (window_duration_ms >= config.rate_limit_window_ms) {
            return false; // New window, allow traffic
        }

        // Check if client exceeded rate limit
        const rate_limit = config.max_bytes_per_second_per_client;
        if (rate_limit > 0) {
            const elapsed_fraction = @as(f64, @floatFromInt(window_duration_ms)) / @as(f64, @floatFromInt(config.rate_limit_window_ms));
            const allowed_bytes = @as(u64, @intFromFloat(@as(f64, @floatFromInt(rate_limit)) * elapsed_fraction));
            return self.bytes_sent_window > allowed_bytes;
        }

        return false;
    }

    /// Check if client has too much pending data
    pub fn hasTooMuchPending(self: *const ClientFlowState, config: *const FlowControlConfig) bool {
        return self.bytes_pending > config.max_pending_bytes_per_client;
    }

    /// Reset rate limiting window
    pub fn resetWindow(self: *ClientFlowState) void {
        self.window_start = std.time.timestamp();
        self.bytes_sent_window = 0;
    }

    /// Record bytes sent
    pub fn recordBytesSent(self: *ClientFlowState, bytes: u64) void {
        self.bytes_sent_window += bytes;
        if (self.bytes_pending >= bytes) {
            self.bytes_pending -= bytes;
        } else {
            self.bytes_pending = 0;
        }
    }

    /// Record bytes pending
    pub fn recordBytesPending(self: *ClientFlowState, bytes: u64) void {
        self.bytes_pending += bytes;
    }

    /// Record throttling event
    pub fn recordThrottle(self: *ClientFlowState) void {
        self.throttle_count += 1;
        self.last_throttle_time = std.time.timestamp();
    }
};

/// System resource information
pub const ResourceInfo = struct {
    /// Current memory usage (bytes)
    memory_usage: u64 = 0,
    /// Maximum memory limit (bytes)
    memory_limit: u64 = 0,
    /// Memory usage percentage (0.0-1.0)
    memory_usage_percent: f32 = 0.0,
    /// Number of active clients
    active_clients: u32 = 0,
    /// Total bytes per second across all clients
    total_bytes_per_second: u64 = 0,
    /// System load average (if available)
    load_average: f32 = 0.0,
    /// Available system memory (bytes, if available)
    available_system_memory: u64 = 0,

    /// Update memory usage information
    pub fn updateMemoryUsage(self: *ResourceInfo, current: u64, limit: u64) void {
        self.memory_usage = current;
        self.memory_limit = limit;
        self.memory_usage_percent = if (limit > 0)
            @as(f32, @floatFromInt(current)) / @as(f32, @floatFromInt(limit))
        else
            0.0;
    }
};

/// Flow control statistics
pub const FlowControlStats = struct {
    /// Current flow control level
    current_level: FlowControlLevel = .normal,
    /// Number of times flow control was activated
    flow_control_activations: u64 = 0,
    /// Number of clients currently throttled
    clients_throttled: u32 = 0,
    /// Total bytes dropped due to flow control
    bytes_dropped: u64 = 0,
    /// Total connections dropped due to resource pressure
    connections_dropped: u32 = 0,
    /// Average response time (microseconds)
    avg_response_time_us: u64 = 0,
    /// Peak memory usage recorded
    peak_memory_usage: u64 = 0,
    /// Time spent in each flow control level (seconds)
    time_in_level: [5]u64 = [_]u64{0} ** 5, // normal, light, moderate, heavy, emergency

    /// Reset statistics
    pub fn reset(self: *FlowControlStats) void {
        self.* = FlowControlStats{};
    }
};

/// Flow control manager
pub const FlowControlManager = struct {
    /// Memory allocator
    allocator: std.mem.Allocator,
    /// Configuration
    config: FlowControlConfig,
    /// Client flow states
    client_states: std.AutoHashMap(u32, ClientFlowState),
    /// Current resource information
    resource_info: ResourceInfo = ResourceInfo{},
    /// Flow control statistics
    stats: FlowControlStats = FlowControlStats{},
    /// Mutex for thread safety
    mutex: std.Thread.Mutex = .{},
    /// Last cleanup time
    last_cleanup: i64,
    /// Current flow control level
    current_level: FlowControlLevel = .normal,
    /// Level change timestamp
    level_change_time: i64,

    /// Initialize flow control manager
    pub fn init(allocator: std.mem.Allocator, config: FlowControlConfig) FlowControlManager {
        const now = std.time.timestamp();
        return FlowControlManager{
            .allocator = allocator,
            .config = config,
            .client_states = std.AutoHashMap(u32, ClientFlowState).init(allocator),
            .last_cleanup = now,
            .level_change_time = now,
        };
    }

    /// Clean up flow control manager
    pub fn deinit(self: *FlowControlManager) void {
        self.client_states.deinit();
    }

    /// Add a client to flow control tracking
    pub fn addClient(self: *FlowControlManager, client_id: u32) !void {
        self.mutex.lock();
        defer self.mutex.unlock();

        const client_state = ClientFlowState.init(client_id);
        try self.client_states.put(client_id, client_state);
        self.resource_info.active_clients += 1;
    }

    /// Remove a client from flow control tracking
    pub fn removeClient(self: *FlowControlManager, client_id: u32) void {
        self.mutex.lock();
        defer self.mutex.unlock();

        if (self.client_states.remove(client_id)) {
            if (self.resource_info.active_clients > 0) {
                self.resource_info.active_clients -= 1;
            }
        }
    }

    /// Check if data should be sent to a client
    pub fn shouldSendData(self: *FlowControlManager, client_id: u32, data_size: u64) bool {
        self.mutex.lock();
        defer self.mutex.unlock();

        // Get client state
        var client_state = self.client_states.getPtr(client_id) orelse return false;

        // Check rate limiting
        if (client_state.shouldRateLimit(&self.config)) {
            client_state.recordThrottle();
            return false;
        }

        // Check pending data limit
        if (client_state.hasTooMuchPending(&self.config)) {
            return false;
        }

        // Check global flow control level
        switch (self.current_level) {
            .normal => return true,
            .light => {
                // Allow high priority clients
                return client_state.priority > 150;
            },
            .moderate => {
                // Allow only high priority clients, reduce data size
                return client_state.priority > 180 and data_size <= 1024;
            },
            .heavy => {
                // Allow only very high priority clients, small data only
                return client_state.priority > 200 and data_size <= 512;
            },
            .emergency => {
                // Only critical clients
                return client_state.priority > 240 and data_size <= 256;
            },
        }
    }

    /// Record data sent to a client
    pub fn recordDataSent(self: *FlowControlManager, client_id: u32, bytes_sent: u64) void {
        self.mutex.lock();
        defer self.mutex.unlock();

        if (self.client_states.getPtr(client_id)) |client_state| {
            client_state.recordBytesSent(bytes_sent);

            // Reset window if needed
            const now = std.time.timestamp();
            const window_duration_ms = @as(u64, @intCast(now - client_state.window_start)) * 1000;
            if (window_duration_ms >= self.config.rate_limit_window_ms) {
                client_state.resetWindow();
            }
        }
    }

    /// Record data pending for a client
    pub fn recordDataPending(self: *FlowControlManager, client_id: u32, bytes_pending: u64) void {
        self.mutex.lock();
        defer self.mutex.unlock();

        if (self.client_states.getPtr(client_id)) |client_state| {
            client_state.recordBytesPending(bytes_pending);
        }
    }

    /// Update resource information
    pub fn updateResourceInfo(self: *FlowControlManager, memory_usage: u64) void {
        self.mutex.lock();
        defer self.mutex.unlock();

        self.resource_info.updateMemoryUsage(memory_usage, self.config.max_memory_usage);

        // Update peak memory usage
        if (memory_usage > self.stats.peak_memory_usage) {
            self.stats.peak_memory_usage = memory_usage;
        }

        // Update flow control level based on memory usage
        self.updateFlowControlLevel();

        // Perform periodic cleanup
        self.performPeriodicCleanup();
    }

    /// Update flow control level based on current conditions
    fn updateFlowControlLevel(self: *FlowControlManager) void {
        const old_level = self.current_level;
        const memory_percent = self.resource_info.memory_usage_percent;

        const new_level = if (memory_percent >= self.config.emergency_threshold)
            FlowControlLevel.emergency
        else if (memory_percent >= self.config.throttle_threshold)
            FlowControlLevel.heavy
        else if (memory_percent >= self.config.flow_control_threshold)
            FlowControlLevel.moderate
        else if (memory_percent >= self.config.flow_control_threshold * 0.8)
            FlowControlLevel.light
        else
            FlowControlLevel.normal;

        if (new_level != old_level) {
            // Update time spent in old level
            const now = std.time.timestamp();
            const time_in_old_level = @as(u64, @intCast(now - self.level_change_time));
            self.stats.time_in_level[@intFromEnum(old_level)] += time_in_old_level;

            // Switch to new level
            self.current_level = new_level;
            self.level_change_time = now;

            if (new_level != .normal) {
                self.stats.flow_control_activations += 1;
            }

            logging.logDebug("Flow control level changed: {any} -> {any}\n", .{ old_level, new_level });
        }
    }

    /// Perform periodic cleanup and maintenance
    fn performPeriodicCleanup(self: *FlowControlManager) void {
        const now = std.time.timestamp();
        const cleanup_interval_s = self.config.cleanup_interval_ms / 1000;

        if (now - self.last_cleanup < cleanup_interval_s) {
            return;
        }

        self.last_cleanup = now;

        // Reset client windows that have expired
        var iterator = self.client_states.iterator();
        while (iterator.next()) |entry| {
            const client_state = entry.value_ptr;
            const window_duration_ms = @as(u64, @intCast(now - client_state.window_start)) * 1000;
            if (window_duration_ms >= self.config.rate_limit_window_ms) {
                client_state.resetWindow();
            }
        }

        // Update throttled client count
        self.updateThrottledClientCount();
    }

    /// Update count of currently throttled clients
    fn updateThrottledClientCount(self: *FlowControlManager) void {
        var throttled_count: u32 = 0;
        var iterator = self.client_states.iterator();
        while (iterator.next()) |entry| {
            const client_state = entry.value_ptr;
            if (client_state.shouldRateLimit(&self.config)) {
                throttled_count += 1;
            }
        }
        self.stats.clients_throttled = throttled_count;
    }

    /// Get current flow control level
    pub fn getCurrentLevel(self: *const FlowControlManager) FlowControlLevel {
        const self_mut = @constCast(self);
        self_mut.mutex.lock();
        defer self_mut.mutex.unlock();

        return self_mut.current_level;
    }

    /// Get current statistics
    pub fn getStats(self: *const FlowControlManager) FlowControlStats {
        const self_mut = @constCast(self);
        self_mut.mutex.lock();
        defer self_mut.mutex.unlock();

        var stats = self_mut.stats;
        stats.current_level = self_mut.current_level;
        return stats;
    }

    /// Get resource information
    pub fn getResourceInfo(self: *const FlowControlManager) ResourceInfo {
        const self_mut = @constCast(self);
        self_mut.mutex.lock();
        defer self_mut.mutex.unlock();

        return self_mut.resource_info;
    }

    /// Set client priority
    pub fn setClientPriority(self: *FlowControlManager, client_id: u32, priority: u8) void {
        self.mutex.lock();
        defer self.mutex.unlock();

        if (self.client_states.getPtr(client_id)) |client_state| {
            client_state.priority = priority;
        }
    }

    /// Force emergency mode (for testing or critical situations)
    pub fn forceEmergencyMode(self: *FlowControlManager) void {
        self.mutex.lock();
        defer self.mutex.unlock();

        const old_level = self.current_level;
        self.current_level = .emergency;

        if (old_level != .emergency) {
            const now = std.time.timestamp();
            const time_in_old_level = @as(u64, @intCast(now - self.level_change_time));
            self.stats.time_in_level[@intFromEnum(old_level)] += time_in_old_level;
            self.level_change_time = now;
            self.stats.flow_control_activations += 1;
        }
    }

    /// Reset to normal mode
    pub fn resetToNormal(self: *FlowControlManager) void {
        self.mutex.lock();
        defer self.mutex.unlock();

        const old_level = self.current_level;
        self.current_level = .normal;

        if (old_level != .normal) {
            const now = std.time.timestamp();
            const time_in_old_level = @as(u64, @intCast(now - self.level_change_time));
            self.stats.time_in_level[@intFromEnum(old_level)] += time_in_old_level;
            self.level_change_time = now;
        }
    }
};

// Tests
test "FlowControlManager basic operations" {
    const testing = std.testing;
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    const config = FlowControlConfig{
        .max_memory_usage = 1024 * 1024, // 1MB
        .flow_control_threshold = 0.5, // 50%
        .max_bytes_per_second_per_client = 1024,
    };

    var manager = FlowControlManager.init(allocator, config);
    defer manager.deinit();

    // Test adding clients
    try manager.addClient(1);
    try manager.addClient(2);

    const resource_info = manager.getResourceInfo();
    try testing.expect(resource_info.active_clients == 2);

    // Test normal operation
    try testing.expect(manager.shouldSendData(1, 100));
    try testing.expect(manager.getCurrentLevel() == .normal);

    // Test data recording
    manager.recordDataSent(1, 100);
    manager.recordDataPending(1, 50);

    // Test removing clients
    manager.removeClient(1);
    const resource_info_after = manager.getResourceInfo();
    try testing.expect(resource_info_after.active_clients == 1);
}

test "FlowControlManager flow control levels" {
    const testing = std.testing;
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    const config = FlowControlConfig{
        .max_memory_usage = 1000, // Small limit for testing
        .flow_control_threshold = 0.5, // 50%
        .throttle_threshold = 0.8, // 80%
        .emergency_threshold = 0.9, // 90%
    };

    var manager = FlowControlManager.init(allocator, config);
    defer manager.deinit();

    try manager.addClient(1);

    // Test normal level (below 40%)
    manager.updateResourceInfo(300); // 30% usage
    try testing.expect(manager.getCurrentLevel() == .normal);

    // Test light level (40%+, which is 0.8 * flow_control_threshold)
    manager.updateResourceInfo(400); // 40% usage
    try testing.expect(manager.getCurrentLevel() == .light);

    // Test moderate level (50%+, which is flow_control_threshold)
    manager.updateResourceInfo(600); // 60% usage
    try testing.expect(manager.getCurrentLevel() == .moderate);

    // Test heavy level
    manager.updateResourceInfo(850); // 85% usage
    try testing.expect(manager.getCurrentLevel() == .heavy);

    // Test emergency level
    manager.updateResourceInfo(950); // 95% usage
    try testing.expect(manager.getCurrentLevel() == .emergency);
}

test "ClientFlowState rate limiting" {
    const testing = std.testing;

    const config = FlowControlConfig{
        .max_bytes_per_second_per_client = 1000,
        .rate_limit_window_ms = 1000,
    };

    var client_state = ClientFlowState.init(1);

    // Should not be rate limited initially
    try testing.expect(!client_state.shouldRateLimit(&config));

    // Record bytes sent
    client_state.recordBytesSent(1500);

    // Should be rate limited now
    try testing.expect(client_state.shouldRateLimit(&config));

    // Reset window
    client_state.resetWindow();

    // Should not be rate limited after reset
    try testing.expect(!client_state.shouldRateLimit(&config));
}

test "FlowControlManager client priority" {
    const testing = std.testing;
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    const config = FlowControlConfig{};

    var manager = FlowControlManager.init(allocator, config);
    defer manager.deinit();

    try manager.addClient(1);
    try manager.addClient(2);

    // Set different priorities
    manager.setClientPriority(1, 200); // High priority
    manager.setClientPriority(2, 100); // Low priority

    // Force moderate flow control
    manager.updateResourceInfo(config.max_memory_usage * 3 / 4); // 75% usage

    // High priority client should be allowed
    try testing.expect(manager.shouldSendData(1, 100));

    // Low priority client should be blocked in moderate flow control
    try testing.expect(!manager.shouldSendData(2, 100));
}
</file>

<file path="server/listen.zig">
//! Server connection acceptance with IP-based access control.
//!
//! This module provides server-side utilities for:
//! - Accepting connections with allow/deny list filtering
//! - Loading access control rules from files
//! - Creating AccessList from configuration
//!
//! Access control logic:
//! - Deny list checked first (explicit block)
//! - Allow list checked second (explicit permit)
//! - If neither matches, default policy applies
//! - Denied connections are closed immediately
//!
//! File format for allow/deny files:
//! ```
//! # Comments start with #
//! 192.168.0.0/16    # Private network
//! 10.0.0.0/8        # Another private range
//! 172.16.1.100      # Specific host
//! ```

const std = @import("std");
const allowlist = @import("../net/allowlist.zig");
const logging = @import("../util/logging.zig");
const path_safety = @import("../util/path_safety.zig");

/// Accept connection with access control filtering.
///
/// Implements access-controlled accept loop with DoS mitigation:
/// 1. Accept incoming connection
/// 2. Check client IP against access list
/// 3. If denied: close connection, apply rate limiting, and retry
/// 4. If allowed: return connection to caller
///
/// **DoS Mitigation** (SECURITY FIX 2025-10-10):
/// - Tracks consecutive denials per thread
/// - Applies exponential backoff after 5 consecutive denials
/// - Prevents tight spin loop consuming 100% CPU during flood attacks
/// - Backoff: 10ms * 2^(denials-5), capped at 1000ms
///
/// Loop behavior:
/// - Continues accepting until allowed connection found
/// - Logs denied connections if verbose enabled
/// - Never returns a denied connection
/// - Resets rate limiting counter when legitimate connection accepted
///
/// Parameters:
///   listener: Server socket from std.net.Address.listen()
///   access_list: Configured allow/deny rules
///   verbose: Enable logging of denied connections
///
/// Returns: Accepted and allowed connection
pub fn acceptWithAccessControl(
    listener: *std.net.Server,
    access_list: *const allowlist.AccessList,
    verbose: bool,
) !std.net.Server.Connection {
    // SECURITY: Rate limiting state to prevent DoS via denied connection floods
    // Per-thread state (no cross-thread coordination needed)
    var consecutive_denials: u32 = 0;
    const max_consecutive_before_delay: u32 = 5;
    const initial_delay_ms: u64 = 10;
    const max_delay_ms: u64 = 1000;

    while (true) {
        const conn = try listener.accept();

        // Check if client IP is allowed
        if (!access_list.isAllowed(conn.address)) {
            if (verbose) {
                logging.logVerbose(null, "Access denied from: {any}\n", .{conn.address});
            }
            conn.stream.close();

            consecutive_denials += 1;

            // SECURITY FIX: Apply exponential backoff after threshold to prevent CPU exhaustion
            // Without this, an attacker from a denied IP can force 100% CPU with connection floods
            if (consecutive_denials > max_consecutive_before_delay) {
                const excess = consecutive_denials - max_consecutive_before_delay;
                // Exponential: delay = initial * 2^excess, capped at max
                const delay_ms = @min(
                    initial_delay_ms * (@as(u64, 1) << @min(excess, 10)), // Cap shift to prevent overflow
                    max_delay_ms,
                );

                if (verbose) {
                    logging.logVerbose(
                        null,
                        "Rate limiting: {d} consecutive denials, sleeping {d}ms\n",
                        .{ consecutive_denials, delay_ms },
                    );
                }

                const delay_ns = delay_ms * std.time.ns_per_ms;
                std.Thread.sleep(delay_ns);
            }

            continue;
        }

        // Connection accepted - reset denial counter
        consecutive_denials = 0;

        if (verbose) {
            logging.logVerbose(null, "Connection accepted from: {any}\n", .{conn.address});
        }

        return conn;
    }
}

/// Create access list from configuration.
///
/// Consolidates access rules from multiple sources:
/// 1. CLI allow list (--allow-ip)
/// 2. CLI deny list (--deny-ip)
/// 3. Allow file rules (--allow-file)
/// 4. Deny file rules (--deny-file)
///
/// Memory management:
/// - Returned AccessList owns all rule data
/// - Caller must call access_list.deinit() when done
/// - errdefer ensures cleanup on partial initialization failure
///
/// Parameters:
///   allocator: For rule allocation
///   cfg: Configuration with access control settings
///
/// Returns: Populated AccessList or allocation error
pub fn createAccessListFromConfig(
    allocator: std.mem.Allocator,
    cfg: anytype,
) !allowlist.AccessList {
    var access_list = allowlist.AccessList.init(allocator);
    errdefer access_list.deinit();

    // Add IP-based allow rules
    for (cfg.allow_list.items) |rule_str| {
        try access_list.addAllowRule(rule_str);
    }

    // Add IP-based deny rules
    for (cfg.deny_list.items) |rule_str| {
        try access_list.addDenyRule(rule_str);
    }

    // Load allow rules from file if specified
    if (cfg.allow_file) |file_path| {
        try loadRulesFromFile(allocator, file_path, &access_list, true);
    }

    // Load deny rules from file if specified
    if (cfg.deny_file) |file_path| {
        try loadRulesFromFile(allocator, file_path, &access_list, false);
    }

    return access_list;
}

/// Load access control rules from a file.
///
/// File format:
/// - One rule per line (IP address or CIDR notation)
/// - Lines starting with # are comments
/// - Empty lines ignored
/// - Whitespace trimmed from each line
///
/// Example file:
/// ```
/// # Allow local networks
/// 192.168.0.0/16
/// 10.0.0.0/8
///
/// # Specific trusted host
/// 172.16.1.100
/// ```
///
/// Parameters:
///   _: Allocator (unused in current implementation)
///   file_path: Path to rules file
///   access_list: AccessList to add rules to
///   is_allow: true for allow rules, false for deny rules
///
/// Returns: Error if file cannot be read or rules are invalid
fn loadRulesFromFile(
    _: std.mem.Allocator,
    file_path: []const u8,
    access_list: *allowlist.AccessList,
    is_allow: bool,
) !void {
    if (!path_safety.isSafePath(file_path)) {
        logging.logError(error.PathTraversalDetected, "access control file validation");
        std.debug.print("Error: Access control file '{s}' contains forbidden traversal sequences\n", .{file_path});
        return error.PathTraversalDetected;
    }

    const file = try std.fs.cwd().openFile(file_path, .{});
    defer file.close();

    const max_file_size = 1024 * 1024; // 1MB max
    const content = try file.readToEndAlloc(std.heap.page_allocator, max_file_size);
    defer std.heap.page_allocator.free(content);

    var line_iter = std.mem.splitScalar(u8, content, '\n');
    while (line_iter.next()) |line| {
        // Trim whitespace
        const trimmed = std.mem.trim(u8, line, " \t\r");

        // Skip empty lines and comments
        if (trimmed.len == 0 or trimmed[0] == '#') {
            continue;
        }

        // Add rule
        if (is_allow) {
            try access_list.addAllowRule(trimmed);
        } else {
            try access_list.addDenyRule(trimmed);
        }
    }
}

/// Create a TCP server with access control
pub fn createServer(
    allocator: std.mem.Allocator,
    address: std.net.Address,
    cfg: anytype,
) !struct {
    server: std.net.Server,
    access_list: allowlist.AccessList,
} {
    const server = try address.listen(.{
        .reuse_address = true,
        .reuse_port = false,
    });

    const access_list = try createAccessListFromConfig(allocator, cfg);

    return .{
        .server = server,
        .access_list = access_list,
    };
}

test "createAccessListFromConfig with allow list" {
    const allocator = std.testing.allocator;

    // Mock config - Fix for Zig 0.15.1 ArrayList API
    // fromOwnedSlice expects a slice, not an allocator
    const allow_items: []const []const u8 = &[_][]const u8{"192.168.1.0/24"};
    var allow_list = std.ArrayList([]const u8).fromOwnedSlice(try allocator.dupe([]const u8, allow_items));
    defer allow_list.deinit(allocator);

    const deny_items: []const []const u8 = &[_][]const u8{};
    var deny_list = std.ArrayList([]const u8).fromOwnedSlice(try allocator.dupe([]const u8, deny_items));
    defer deny_list.deinit(allocator);

    const mock_cfg = struct {
        allow_list: std.ArrayList([]const u8),
        deny_list: std.ArrayList([]const u8),
        allow_file: ?[]const u8 = null,
        deny_file: ?[]const u8 = null,
    }{
        .allow_list = allow_list,
        .deny_list = deny_list,
    };

    var access_list = try createAccessListFromConfig(allocator, mock_cfg);
    defer access_list.deinit();

    try std.testing.expectEqual(@as(usize, 1), access_list.allow_rules.items.len);
}
</file>

<file path="server/performance_monitor.zig">
//! Performance Monitor for Resource Tracking and Optimization
//!
//! This module provides comprehensive performance monitoring and resource tracking
//! for broker/chat mode operations. It monitors system resources, tracks performance
//! metrics, and provides insights for optimization and troubleshooting.
//!
//! ## Design Goals
//!
//! - **Real-time Monitoring**: Track performance metrics in real-time
//! - **Resource Tracking**: Monitor memory, CPU, and network usage
//! - **Performance Analysis**: Provide detailed performance insights
//! - **Alerting**: Detect performance issues and resource constraints
//! - **Historical Data**: Maintain performance history for analysis
//!
//! ## Architecture
//!
//! ```
//!         
//!    System               Performance           Metrics       
//!    Monitor          Monitor           Collector     
//!                                                             
//!         
//!                                                        
//!                                                        
//!         
//!    Resource             Alert                 Historical    
//!    Tracking             Manager               Data          
//!                                                             
//!         
//! ```

const std = @import("std");
const builtin = @import("builtin");

/// Performance monitoring configuration
pub const PerformanceConfig = struct {
    /// Monitoring interval in milliseconds
    monitoring_interval_ms: u64 = 1000, // 1 second
    /// Number of historical samples to keep
    history_size: usize = 300, // 5 minutes at 1s intervals
    /// Enable detailed CPU monitoring
    enable_cpu_monitoring: bool = true,
    /// Enable detailed memory monitoring
    enable_memory_monitoring: bool = true,
    /// Enable network I/O monitoring
    enable_network_monitoring: bool = true,
    /// Memory usage alert threshold (percentage)
    memory_alert_threshold: f32 = 85.0,
    /// CPU usage alert threshold (percentage)
    cpu_alert_threshold: f32 = 90.0,
    /// Network throughput alert threshold (bytes/sec)
    network_alert_threshold: u64 = 100 * 1024 * 1024, // 100MB/s
};

/// System resource snapshot
pub const ResourceSnapshot = struct {
    /// Timestamp of snapshot
    timestamp: i64,
    /// Memory usage in bytes
    memory_usage: u64 = 0,
    /// Memory usage percentage
    memory_percent: f32 = 0.0,
    /// Available memory in bytes
    available_memory: u64 = 0,
    /// CPU usage percentage (0.0-100.0)
    cpu_percent: f32 = 0.0,
    /// Network bytes received per second
    network_rx_bytes_per_sec: u64 = 0,
    /// Network bytes transmitted per second
    network_tx_bytes_per_sec: u64 = 0,
    /// Number of active connections
    active_connections: u32 = 0,
    /// Number of file descriptors in use
    file_descriptors: u32 = 0,
    /// System load average (1 minute)
    load_average: f32 = 0.0,

    /// Initialize snapshot with current timestamp
    pub fn init() ResourceSnapshot {
        return ResourceSnapshot{
            .timestamp = std.time.timestamp(),
        };
    }

    /// Calculate memory usage percentage
    pub fn calculateMemoryPercent(self: *ResourceSnapshot, total_memory: u64) void {
        if (total_memory > 0) {
            self.memory_percent = @as(f32, @floatFromInt(self.memory_usage)) / @as(f32, @floatFromInt(total_memory)) * 100.0;
        }
    }
};

/// Performance metrics for broker/chat operations
pub const BrokerMetrics = struct {
    /// Total messages relayed
    messages_relayed: u64 = 0,
    /// Total bytes relayed
    bytes_relayed: u64 = 0,
    /// Messages per second (current)
    messages_per_second: f32 = 0.0,
    /// Bytes per second (current)
    bytes_per_second: f32 = 0.0,
    /// Average message size
    avg_message_size: f32 = 0.0,
    /// Peak messages per second
    peak_messages_per_second: f32 = 0.0,
    /// Peak bytes per second
    peak_bytes_per_second: f32 = 0.0,
    /// Number of relay errors
    relay_errors: u64 = 0,
    /// Number of client disconnections
    client_disconnections: u64 = 0,
    /// Average relay latency (microseconds)
    avg_relay_latency_us: u64 = 0,
    /// Peak relay latency (microseconds)
    peak_relay_latency_us: u64 = 0,

    /// Update metrics with new relay operation
    pub fn updateRelay(self: *BrokerMetrics, bytes: u64, latency_us: u64) void {
        self.messages_relayed += 1;
        self.bytes_relayed += bytes;

        // Update average message size
        self.avg_message_size = @as(f32, @floatFromInt(self.bytes_relayed)) / @as(f32, @floatFromInt(self.messages_relayed));

        // Update latency metrics
        if (latency_us > self.peak_relay_latency_us) {
            self.peak_relay_latency_us = latency_us;
        }

        // Simple moving average for latency (could be improved with proper windowing)
        self.avg_relay_latency_us = (self.avg_relay_latency_us + latency_us) / 2;
    }

    /// Update throughput metrics
    pub fn updateThroughput(self: *BrokerMetrics, messages_per_sec: f32, bytes_per_sec: f32) void {
        self.messages_per_second = messages_per_sec;
        self.bytes_per_second = bytes_per_sec;

        if (messages_per_sec > self.peak_messages_per_second) {
            self.peak_messages_per_second = messages_per_sec;
        }

        if (bytes_per_sec > self.peak_bytes_per_second) {
            self.peak_bytes_per_second = bytes_per_sec;
        }
    }

    /// Record relay error
    pub fn recordError(self: *BrokerMetrics) void {
        self.relay_errors += 1;
    }

    /// Record client disconnection
    pub fn recordDisconnection(self: *BrokerMetrics) void {
        self.client_disconnections += 1;
    }
};

/// Performance alert types
pub const AlertType = enum {
    memory_high,
    cpu_high,
    network_high,
    relay_errors,
    client_disconnections,
    latency_high,

    /// Get human-readable description
    pub fn description(self: AlertType) []const u8 {
        return switch (self) {
            .memory_high => "High Memory Usage",
            .cpu_high => "High CPU Usage",
            .network_high => "High Network Usage",
            .relay_errors => "High Relay Error Rate",
            .client_disconnections => "High Client Disconnection Rate",
            .latency_high => "High Relay Latency",
        };
    }
};

/// Performance alert
pub const PerformanceAlert = struct {
    /// Alert type
    alert_type: AlertType,
    /// Alert message
    message: []const u8,
    /// Alert severity (1-5, 5 being critical)
    severity: u8,
    /// Timestamp when alert was triggered
    timestamp: i64,
    /// Current value that triggered the alert
    current_value: f64,
    /// Threshold that was exceeded
    threshold: f64,

    /// Initialize alert
    pub fn init(alert_type: AlertType, message: []const u8, severity: u8, current_value: f64, threshold: f64) PerformanceAlert {
        return PerformanceAlert{
            .alert_type = alert_type,
            .message = message,
            .severity = severity,
            .timestamp = std.time.timestamp(),
            .current_value = current_value,
            .threshold = threshold,
        };
    }
};

/// Historical data ring buffer
pub fn RingBuffer(comptime T: type) type {
    return struct {
        const Self = @This();

        data: []T,
        head: usize = 0,
        count: usize = 0,
        allocator: std.mem.Allocator,

        pub fn init(allocator: std.mem.Allocator, buffer_capacity: usize) !Self {
            const data = try allocator.alloc(T, buffer_capacity);
            return Self{
                .data = data,
                .allocator = allocator,
            };
        }

        pub fn deinit(self: *Self) void {
            self.allocator.free(self.data);
        }

        pub fn push(self: *Self, item: T) void {
            self.data[self.head] = item;
            self.head = (self.head + 1) % self.data.len;
            if (self.count < self.data.len) {
                self.count += 1;
            }
        }

        pub fn get(self: *const Self, index: usize) ?T {
            if (index >= self.count) return null;
            const actual_index = if (self.count < self.data.len)
                index
            else
                (self.head + index) % self.data.len;
            return self.data[actual_index];
        }

        pub fn latest(self: *const Self) ?T {
            if (self.count == 0) return null;
            const latest_index = if (self.head == 0) self.data.len - 1 else self.head - 1;
            return self.data[latest_index];
        }

        pub fn size(self: *const Self) usize {
            return self.count;
        }

        pub fn capacity(self: *const Self) usize {
            return self.data.len;
        }
    };
}

/// Performance monitor
pub const PerformanceMonitor = struct {
    /// Memory allocator
    allocator: std.mem.Allocator,
    /// Configuration
    config: PerformanceConfig,
    /// Historical resource snapshots
    resource_history: RingBuffer(ResourceSnapshot),
    /// Current broker metrics
    broker_metrics: BrokerMetrics = BrokerMetrics{},
    /// Active alerts
    active_alerts: std.ArrayList(PerformanceAlert),
    /// Mutex for thread safety
    mutex: std.Thread.Mutex = .{},
    /// Last monitoring timestamp
    last_monitor_time: i64,
    /// Monitoring enabled flag
    monitoring_enabled: bool = true,
    /// Previous network stats for rate calculation
    prev_network_rx: u64 = 0,
    prev_network_tx: u64 = 0,
    prev_network_time: i64 = 0,

    /// Initialize performance monitor
    pub fn init(allocator: std.mem.Allocator, config: PerformanceConfig) !PerformanceMonitor {
        return PerformanceMonitor{
            .allocator = allocator,
            .config = config,
            .resource_history = try RingBuffer(ResourceSnapshot).init(allocator, config.history_size),
            .active_alerts = std.ArrayList(PerformanceAlert){},
            .last_monitor_time = std.time.timestamp(),
        };
    }

    /// Clean up performance monitor
    pub fn deinit(self: *PerformanceMonitor) void {
        self.resource_history.deinit();

        // Free alert messages
        for (self.active_alerts.items) |alert| {
            self.allocator.free(alert.message);
        }
        self.active_alerts.deinit(self.allocator);
    }

    /// Update monitoring data
    pub fn update(self: *PerformanceMonitor) void {
        if (!self.monitoring_enabled) return;

        const now = std.time.timestamp();
        const interval_ms = self.config.monitoring_interval_ms;

        if (@as(u64, @intCast(now - self.last_monitor_time)) * 1000 < interval_ms) {
            return; // Not time for update yet
        }

        self.mutex.lock();
        defer self.mutex.unlock();

        // Collect resource snapshot
        var snapshot = self.collectResourceSnapshot();

        // Calculate throughput metrics
        self.calculateThroughputMetrics(&snapshot);

        // Store snapshot in history
        self.resource_history.push(snapshot);

        // Check for alerts
        self.checkAlerts(&snapshot);

        self.last_monitor_time = now;
    }

    /// Collect current resource snapshot
    fn collectResourceSnapshot(self: *PerformanceMonitor) ResourceSnapshot {
        var snapshot = ResourceSnapshot.init();

        // Get memory information
        if (self.config.enable_memory_monitoring) {
            self.collectMemoryInfo(&snapshot);
        }

        // Get CPU information
        if (self.config.enable_cpu_monitoring) {
            self.collectCpuInfo(&snapshot);
        }

        // Get network information
        if (self.config.enable_network_monitoring) {
            self.collectNetworkInfo(&snapshot);
        }

        return snapshot;
    }

    /// Collect memory information
    fn collectMemoryInfo(self: *PerformanceMonitor, snapshot: *ResourceSnapshot) void {
        // Platform-specific memory collection
        if (builtin.os.tag == .linux) {
            self.collectLinuxMemoryInfo(snapshot);
        } else if (builtin.os.tag == .windows) {
            self.collectWindowsMemoryInfo(snapshot);
        } else if (builtin.os.tag == .macos) {
            self.collectMacOSMemoryInfo(snapshot);
        } else {
            // Fallback: use basic process memory info
            self.collectBasicMemoryInfo(snapshot);
        }
    }

    /// Collect Linux memory information
    fn collectLinuxMemoryInfo(self: *PerformanceMonitor, snapshot: *ResourceSnapshot) void {

        // Read /proc/meminfo
        const meminfo_file = std.fs.openFileAbsolute("/proc/meminfo", .{}) catch return;
        defer meminfo_file.close();

        var buffer: [4096]u8 = undefined;
        const bytes_read = meminfo_file.readAll(&buffer) catch return;
        const content = buffer[0..bytes_read];

        var lines = std.mem.splitScalar(u8, content, '\n');
        while (lines.next()) |line| {
            if (std.mem.startsWith(u8, line, "MemTotal:")) {
                if (self.parseMemoryValue(line)) |total| {
                    snapshot.available_memory = total * 1024; // Convert KB to bytes
                }
            } else if (std.mem.startsWith(u8, line, "MemAvailable:")) {
                if (self.parseMemoryValue(line)) |available| {
                    const total = snapshot.available_memory / 1024; // Convert back to KB
                    snapshot.memory_usage = (total - available) * 1024; // Convert to bytes
                    snapshot.calculateMemoryPercent(snapshot.available_memory);
                }
            }
        }
    }

    /// Parse memory value from /proc/meminfo line
    fn parseMemoryValue(self: *PerformanceMonitor, line: []const u8) ?u64 {
        _ = self; // Suppress unused parameter warning

        var parts = std.mem.splitScalar(u8, line, ' ');
        _ = parts.next(); // Skip label

        while (parts.next()) |part| {
            if (part.len > 0 and std.ascii.isDigit(part[0])) {
                return std.fmt.parseInt(u64, part, 10) catch null;
            }
        }
        return null;
    }

    /// Collect Windows memory information
    fn collectWindowsMemoryInfo(self: *PerformanceMonitor, snapshot: *ResourceSnapshot) void {
        // TODO: Implement Windows-specific memory collection using Windows API
        // For now, use basic fallback
        self.collectBasicMemoryInfo(snapshot);
    }

    /// Collect macOS memory information
    fn collectMacOSMemoryInfo(self: *PerformanceMonitor, snapshot: *ResourceSnapshot) void {
        // TODO: Implement macOS-specific memory collection using sysctl
        // For now, use basic fallback
        self.collectBasicMemoryInfo(snapshot);
    }

    /// Collect basic memory information (fallback)
    fn collectBasicMemoryInfo(self: *PerformanceMonitor, snapshot: *ResourceSnapshot) void {
        _ = self;

        // Use a simple heuristic based on typical system memory
        // This is a fallback and not accurate
        snapshot.available_memory = 8 * 1024 * 1024 * 1024; // Assume 8GB
        snapshot.memory_usage = 2 * 1024 * 1024 * 1024; // Assume 2GB used
        snapshot.calculateMemoryPercent(snapshot.available_memory);
    }

    /// Collect CPU information
    fn collectCpuInfo(self: *PerformanceMonitor, snapshot: *ResourceSnapshot) void {

        // Platform-specific CPU collection
        if (builtin.os.tag == .linux) {
            self.collectLinuxCpuInfo(snapshot);
        } else {
            // Fallback: use a simple estimate
            snapshot.cpu_percent = 10.0; // Placeholder
        }
    }

    /// Collect Linux CPU information
    fn collectLinuxCpuInfo(self: *PerformanceMonitor, snapshot: *ResourceSnapshot) void {
        _ = self; // Suppress unused parameter warning

        // Read /proc/loadavg for load average
        const loadavg_file = std.fs.openFileAbsolute("/proc/loadavg", .{}) catch return;
        defer loadavg_file.close();

        var buffer: [256]u8 = undefined;
        const bytes_read = loadavg_file.readAll(&buffer) catch return;
        const content = buffer[0..bytes_read];

        var parts = std.mem.splitScalar(u8, content, ' ');
        if (parts.next()) |load_str| {
            snapshot.load_average = std.fmt.parseFloat(f32, load_str) catch 0.0;
            // Convert load average to approximate CPU percentage
            snapshot.cpu_percent = @min(snapshot.load_average * 100.0, 100.0);
        }
    }

    /// Collect network information
    fn collectNetworkInfo(self: *PerformanceMonitor, snapshot: *ResourceSnapshot) void {
        // This is a simplified implementation
        // In a real implementation, you would read network interface statistics

        const now = std.time.timestamp();
        if (self.prev_network_time > 0) {
            const time_diff = @as(f64, @floatFromInt(now - self.prev_network_time));
            if (time_diff > 0) {
                // Calculate rates (these would be real values in a full implementation)
                snapshot.network_rx_bytes_per_sec = @intFromFloat(@as(f64, @floatFromInt(self.prev_network_rx)) / time_diff);
                snapshot.network_tx_bytes_per_sec = @intFromFloat(@as(f64, @floatFromInt(self.prev_network_tx)) / time_diff);
            }
        }

        // Update previous values (placeholder values)
        self.prev_network_rx = snapshot.network_rx_bytes_per_sec;
        self.prev_network_tx = snapshot.network_tx_bytes_per_sec;
        self.prev_network_time = now;
    }

    /// Calculate throughput metrics
    fn calculateThroughputMetrics(self: *PerformanceMonitor, snapshot: *ResourceSnapshot) void {
        _ = snapshot; // Suppress unused parameter warning

        // Calculate messages and bytes per second based on recent history
        if (self.resource_history.size() >= 2) {
            if (self.resource_history.latest()) |current| {
                if (self.resource_history.get(self.resource_history.size() - 2)) |previous| {
                    const time_diff = @as(f32, @floatFromInt(current.timestamp - previous.timestamp));
                    if (time_diff > 0) {
                        const messages_diff = @as(f32, @floatFromInt(self.broker_metrics.messages_relayed));
                        const bytes_diff = @as(f32, @floatFromInt(self.broker_metrics.bytes_relayed));

                        self.broker_metrics.updateThroughput(messages_diff / time_diff, bytes_diff / time_diff);
                    }
                }
            }
        }
    }

    /// Check for performance alerts
    fn checkAlerts(self: *PerformanceMonitor, snapshot: *ResourceSnapshot) void {
        // Clear old alerts (keep only recent ones)
        self.clearOldAlerts();

        // Check memory usage
        if (snapshot.memory_percent > self.config.memory_alert_threshold) {
            const message = std.fmt.allocPrint(self.allocator, "Memory usage is {d:.1}% (threshold: {d:.1}%)", .{ snapshot.memory_percent, self.config.memory_alert_threshold }) catch return;

            const alert = PerformanceAlert.init(.memory_high, message, if (snapshot.memory_percent > 95.0) 5 else 3, snapshot.memory_percent, self.config.memory_alert_threshold);

            self.active_alerts.append(self.allocator, alert) catch {};
        }

        // Check CPU usage
        if (snapshot.cpu_percent > self.config.cpu_alert_threshold) {
            const message = std.fmt.allocPrint(self.allocator, "CPU usage is {d:.1}% (threshold: {d:.1}%)", .{ snapshot.cpu_percent, self.config.cpu_alert_threshold }) catch return;

            const alert = PerformanceAlert.init(.cpu_high, message, if (snapshot.cpu_percent > 98.0) 5 else 3, snapshot.cpu_percent, self.config.cpu_alert_threshold);

            self.active_alerts.append(self.allocator, alert) catch {};
        }

        // Check network usage
        const total_network = snapshot.network_rx_bytes_per_sec + snapshot.network_tx_bytes_per_sec;
        if (total_network > self.config.network_alert_threshold) {
            const message = std.fmt.allocPrint(self.allocator, "Network usage is {} bytes/sec (threshold: {} bytes/sec)", .{ total_network, self.config.network_alert_threshold }) catch return;

            const alert = PerformanceAlert.init(.network_high, message, 3, @floatFromInt(total_network), @floatFromInt(self.config.network_alert_threshold));

            self.active_alerts.append(self.allocator, alert) catch {};
        }
    }

    /// Clear old alerts (older than 5 minutes)
    fn clearOldAlerts(self: *PerformanceMonitor) void {
        const now = std.time.timestamp();
        const alert_timeout = 300; // 5 minutes

        var i: usize = 0;
        while (i < self.active_alerts.items.len) {
            const alert = &self.active_alerts.items[i];
            if (now - alert.timestamp > alert_timeout) {
                self.allocator.free(alert.message);
                _ = self.active_alerts.swapRemove(i);
            } else {
                i += 1;
            }
        }
    }

    /// Record broker relay operation
    pub fn recordRelay(self: *PerformanceMonitor, bytes: u64, latency_us: u64) void {
        self.mutex.lock();
        defer self.mutex.unlock();

        self.broker_metrics.updateRelay(bytes, latency_us);
    }

    /// Record broker error
    pub fn recordError(self: *PerformanceMonitor) void {
        self.mutex.lock();
        defer self.mutex.unlock();

        self.broker_metrics.recordError();
    }

    /// Record client disconnection
    pub fn recordDisconnection(self: *PerformanceMonitor) void {
        self.mutex.lock();
        defer self.mutex.unlock();

        self.broker_metrics.recordDisconnection();
    }

    /// Get current broker metrics
    pub fn getBrokerMetrics(self: *const PerformanceMonitor) BrokerMetrics {
        const self_mut = @constCast(self);
        self_mut.mutex.lock();
        defer self_mut.mutex.unlock();

        return self_mut.broker_metrics;
    }

    /// Get latest resource snapshot
    pub fn getLatestSnapshot(self: *const PerformanceMonitor) ?ResourceSnapshot {
        const self_mut = @constCast(self);
        self_mut.mutex.lock();
        defer self_mut.mutex.unlock();

        return self_mut.resource_history.latest();
    }

    /// Get active alerts
    pub fn getActiveAlerts(self: *const PerformanceMonitor, allocator: std.mem.Allocator) ![]PerformanceAlert {
        const self_mut = @constCast(self);
        self_mut.mutex.lock();
        defer self_mut.mutex.unlock();

        const alerts = try allocator.alloc(PerformanceAlert, self_mut.active_alerts.items.len);
        for (self_mut.active_alerts.items, 0..) |alert, i| {
            alerts[i] = alert;
            // Note: We're sharing the message pointer, caller should not free it
        }

        return alerts;
    }

    /// Enable/disable monitoring
    pub fn setMonitoringEnabled(self: *PerformanceMonitor, enabled: bool) void {
        self.mutex.lock();
        defer self.mutex.unlock();

        self.monitoring_enabled = enabled;
    }

    /// Get performance summary
    pub fn getPerformanceSummary(self: *const PerformanceMonitor) struct {
        memory_usage_percent: f32,
        cpu_usage_percent: f32,
        messages_per_second: f32,
        bytes_per_second: f32,
        active_alerts: usize,
        relay_errors: u64,
        avg_latency_us: u64,
    } {
        const self_mut = @constCast(self);
        self_mut.mutex.lock();
        defer self_mut.mutex.unlock();

        const latest_snapshot = self_mut.resource_history.latest();

        return .{
            .memory_usage_percent = if (latest_snapshot) |snapshot| snapshot.memory_percent else 0.0,
            .cpu_usage_percent = if (latest_snapshot) |snapshot| snapshot.cpu_percent else 0.0,
            .messages_per_second = self_mut.broker_metrics.messages_per_second,
            .bytes_per_second = self_mut.broker_metrics.bytes_per_second,
            .active_alerts = self_mut.active_alerts.items.len,
            .relay_errors = self_mut.broker_metrics.relay_errors,
            .avg_latency_us = self_mut.broker_metrics.avg_relay_latency_us,
        };
    }
};

// Tests
test "PerformanceMonitor basic operations" {
    const testing = std.testing;
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    const config = PerformanceConfig{
        .monitoring_interval_ms = 100, // Fast for testing
        .history_size = 10,
    };

    var monitor = try PerformanceMonitor.init(allocator, config);
    defer monitor.deinit();

    // Test recording operations
    monitor.recordRelay(1024, 500);
    monitor.recordError();
    monitor.recordDisconnection();

    const metrics = monitor.getBrokerMetrics();
    try testing.expect(metrics.messages_relayed == 1);
    try testing.expect(metrics.bytes_relayed == 1024);
    try testing.expect(metrics.relay_errors == 1);
    try testing.expect(metrics.client_disconnections == 1);
}

test "RingBuffer operations" {
    const testing = std.testing;
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    var buffer = try RingBuffer(u32).init(allocator, 3);
    defer buffer.deinit();

    // Test empty buffer
    try testing.expect(buffer.size() == 0);
    try testing.expect(buffer.latest() == null);

    // Test adding items
    buffer.push(1);
    buffer.push(2);
    buffer.push(3);

    try testing.expect(buffer.size() == 3);
    try testing.expect(buffer.latest().? == 3);
    try testing.expect(buffer.get(0).? == 1);
    try testing.expect(buffer.get(2).? == 3);

    // Test overflow
    buffer.push(4);
    try testing.expect(buffer.size() == 3);
    try testing.expect(buffer.latest().? == 4);
    try testing.expect(buffer.get(0).? == 2); // First item was overwritten
}

test "ResourceSnapshot operations" {
    const testing = std.testing;

    var snapshot = ResourceSnapshot.init();
    snapshot.memory_usage = 1024 * 1024 * 1024; // 1GB
    snapshot.calculateMemoryPercent(4 * 1024 * 1024 * 1024); // 4GB total

    try testing.expect(snapshot.memory_percent == 25.0);
    try testing.expect(snapshot.timestamp > 0);
}

test "BrokerMetrics operations" {
    const testing = std.testing;

    var metrics = BrokerMetrics{};

    // Test relay updates
    metrics.updateRelay(1024, 500);
    metrics.updateRelay(2048, 750);

    try testing.expect(metrics.messages_relayed == 2);
    try testing.expect(metrics.bytes_relayed == 3072);
    try testing.expect(metrics.avg_message_size == 1536.0);
    try testing.expect(metrics.peak_relay_latency_us == 750);

    // Test error recording
    metrics.recordError();
    metrics.recordDisconnection();

    try testing.expect(metrics.relay_errors == 1);
    try testing.expect(metrics.client_disconnections == 1);
}
</file>

<file path="server/relay.zig">
//! Message Relay Engine for Data Distribution
//!
//! This module implements the core message relay functionality for ZigCat's
//! broker and chat modes. It handles efficient data distribution between
//! multiple clients with sender exclusion and minimal memory overhead.
//!
//! ## Design Goals
//!
//! - **Efficient Distribution**: Minimize memory copying and allocation overhead
//! - **Sender Exclusion**: Prevent clients from receiving their own data
//! - **Mode Awareness**: Handle both raw broker mode and formatted chat mode
//! - **Error Isolation**: Client-specific errors don't affect other clients
//! - **Memory Safety**: Proper buffer management and bounds checking
//!
//! ## Architecture
//!
//! ```
//!         
//!    Client               Relay                 Client        
//!    Data Input       Engine            Data Output   
//!                                                             
//!         
//!                                                        
//!                                                        
//!         
//!    Raw Data             Format                Distribute    
//!    (Broker)             Messages              to Clients    
//!    Chat Lines           (Chat Mode)           (Exclude      
//!    (Chat)                                     Sender)       
//!         
//! ```
//!
//! ## Usage Patterns
//!
//! ### Broker Mode
//! ```zig
//! // Raw data relay - forward as-is
//! try relay_engine.relayData(raw_data, sender_id);
//! ```
//!
//! ### Chat Mode
//! ```zig
//! // Formatted message relay with nickname
//! try relay_engine.relayMessage(message_text, sender_id);
//!
//! // System notifications to all clients
//! try relay_engine.broadcastNotification("*** User joined");
//! ```
//!
//! ## Performance Characteristics
//!
//! - **Zero-Copy**: Direct buffer access where possible
//! - **Batch Operations**: Single allocation for multiple client writes
//! - **Error Recovery**: Failed clients are isolated and removed
//! - **Memory Pooling**: Reusable buffers for message formatting

const std = @import("std");
const ClientPool = @import("client_pool.zig").ClientPool;
const ClientInfo = @import("client_pool.zig").ClientInfo;
const logging = @import("../util/logging.zig");

/// Broker operation modes (imported from broker.zig)
pub const BrokerMode = enum {
    /// Raw data relay mode - forwards all data as-is
    broker,
    /// Line-oriented chat mode with nicknames and formatting
    chat,
};

/// Relay engine errors
pub const RelayError = error{
    /// Client not found in pool
    ClientNotFound,
    /// Failed to relay data to one or more clients
    RelayFailed,
    /// Message formatting failed
    FormatError,
    /// Memory allocation failed
    OutOfMemory,
    /// Invalid nickname provided
    InvalidNickname,
    /// Nickname already in use
    NicknameTaken,
    /// Message too long for buffer
    MessageTooLong,
};

/// Statistics for relay operations
pub const RelayStats = struct {
    /// Total messages relayed
    messages_relayed: u64 = 0,
    /// Total bytes relayed
    bytes_relayed: u64 = 0,
    /// Number of relay errors encountered
    relay_errors: u64 = 0,
    /// Number of clients that failed to receive data
    failed_clients: u64 = 0,

    /// Reset all statistics to zero
    pub fn reset(self: *RelayStats) void {
        self.* = RelayStats{};
    }
};

/// Message relay engine for distributing data between clients
pub const RelayEngine = struct {
    /// Memory allocator for temporary buffers
    allocator: std.mem.Allocator,
    /// Reference to client pool for accessing clients
    client_pool: *ClientPool,
    /// Current broker mode (broker or chat)
    mode: BrokerMode,
    /// Relay operation statistics
    stats: RelayStats = RelayStats{},
    /// Maximum message length for chat mode
    max_message_len: usize = 1024,
    /// Maximum nickname length for chat mode
    max_nickname_len: usize = 32,
    /// Fast lookup table for active chat nicknames
    nickname_index: std.StringHashMap(u32),

    /// Initialize relay engine
    ///
    /// ## Parameters
    /// - `allocator`: Memory allocator for temporary message formatting
    /// - `client_pool`: Reference to client pool for accessing clients
    /// - `mode`: Broker operation mode (broker or chat)
    ///
    /// ## Returns
    /// Initialized relay engine ready for use
    pub fn init(allocator: std.mem.Allocator, client_pool: *ClientPool, mode: BrokerMode) RelayEngine {
        return RelayEngine{
            .allocator = allocator,
            .client_pool = client_pool,
            .mode = mode,
            .nickname_index = std.StringHashMap(u32).init(allocator),
        };
    }

    /// Release relay engine resources
    pub fn deinit(self: *RelayEngine) void {
        self.clearNicknameIndex();
        self.nickname_index.deinit();
    }

    /// Relay raw data to all clients except the sender
    ///
    /// This is the core relay function used in broker mode to forward
    /// data as-is without any formatting or modification.
    ///
    /// ## Parameters
    /// - `self`: Mutable reference to relay engine
    /// - `data`: Raw data to relay to clients
    /// - `sender_id`: ID of client that sent the data (excluded from relay)
    ///
    /// ## Returns
    /// Error if relay operation fails completely
    ///
    /// ## Behavior
    /// - Distributes data to all clients except sender
    /// - Continues on individual client errors
    /// - Updates relay statistics
    /// - Logs errors for debugging
    pub fn relayData(self: *RelayEngine, data: []const u8, sender_id: u32) !void {
        if (data.len == 0) return;

        // Get list of all client IDs
        const client_ids = self.client_pool.getAllClientIds(self.allocator) catch {
            return RelayError.OutOfMemory;
        };
        defer self.allocator.free(client_ids);

        var success_count: usize = 0;
        var error_count: usize = 0;

        // Relay to each client (except sender)
        for (client_ids) |client_id| {
            // Skip sender to prevent echo-back
            if (client_id == sender_id) continue;

            // Get client from pool
            if (self.client_pool.getClient(client_id)) |client| {
                // Attempt to send data to client
                const bytes_sent = client.connection.write(data) catch |err| {
                    error_count += 1;
                    self.stats.failed_clients += 1;

                    // Log error but continue with other clients
                    logging.logDebug("Failed to relay {any} bytes to client {any}: {any}\n", .{ data.len, client_id, err });
                    continue;
                };

                // Update client statistics
                client.bytes_sent += bytes_sent;
                client.updateActivity();
                success_count += 1;
            } else {
                // Client not found - may have been removed
                error_count += 1;
                self.stats.failed_clients += 1;
            }
        }

        // Update relay statistics
        if (success_count > 0) {
            self.stats.messages_relayed += 1;
            self.stats.bytes_relayed += data.len * success_count;
        }

        if (error_count > 0) {
            self.stats.relay_errors += 1;
        }

        // Log relay summary for debugging
        logging.logDebug("Relayed {any} bytes to {any} clients ({any} errors)\n", .{ data.len, success_count, error_count });
    }

    /// Relay a formatted chat message to all clients except the sender
    ///
    /// This function is used in chat mode to send formatted messages
    /// with nickname prefixes to all connected clients.
    ///
    /// ## Parameters
    /// - `self`: Mutable reference to relay engine
    /// - `message`: Plain message text (without formatting)
    /// - `sender_id`: ID of client that sent the message
    ///
    /// ## Returns
    /// Error if message formatting or relay fails
    ///
    /// ## Behavior
    /// - Looks up sender's nickname from client pool
    /// - Formats message with nickname prefix
    /// - Relays formatted message to all other clients
    /// - Handles missing nickname gracefully
    pub fn relayMessage(self: *RelayEngine, message: []const u8, sender_id: u32) !void {
        if (self.mode != .chat) {
            // In broker mode, just relay raw data
            return self.relayData(message, sender_id);
        }

        // Get sender's nickname
        const sender_nickname = blk: {
            if (self.client_pool.getClient(sender_id)) |client| {
                if (client.nickname) |nick| {
                    break :blk nick;
                }
            }
            break :blk "Unknown";
        };

        // Format the chat message
        const formatted_message = try self.formatChatMessage(message, sender_nickname);
        defer self.allocator.free(formatted_message);

        // Relay the formatted message
        try self.relayData(formatted_message, sender_id);
    }

    /// Broadcast a notification message to all clients
    ///
    /// This function sends system notifications (like join/leave messages)
    /// to all connected clients without excluding any sender.
    ///
    /// ## Parameters
    /// - `self`: Mutable reference to relay engine
    /// - `notification`: Notification message to broadcast
    ///
    /// ## Returns
    /// Error if broadcast fails
    ///
    /// ## Behavior
    /// - Sends notification to ALL clients (no sender exclusion)
    /// - Used for system messages like join/leave announcements
    /// - Handles client errors gracefully
    pub fn broadcastNotification(self: *RelayEngine, notification: []const u8) !void {
        if (notification.len == 0) return;

        // Get list of all client IDs
        const client_ids = self.client_pool.getAllClientIds(self.allocator) catch {
            return RelayError.OutOfMemory;
        };
        defer self.allocator.free(client_ids);

        var success_count: usize = 0;
        var error_count: usize = 0;

        // Send to all clients (no sender exclusion for notifications)
        for (client_ids) |client_id| {
            if (self.client_pool.getClient(client_id)) |client| {
                const bytes_sent = client.connection.write(notification) catch |err| {
                    error_count += 1;
                    self.stats.failed_clients += 1;
                    logging.logDebug("Failed to broadcast to client {any}: {any}\n", .{ client_id, err });
                    continue;
                };

                client.bytes_sent += bytes_sent;
                client.updateActivity();
                success_count += 1;
            } else {
                error_count += 1;
                self.stats.failed_clients += 1;
            }
        }

        // Update statistics
        if (success_count > 0) {
            self.stats.messages_relayed += 1;
            self.stats.bytes_relayed += notification.len * success_count;
        }

        if (error_count > 0) {
            self.stats.relay_errors += 1;
        }

        logging.logDebug("Broadcast {any} bytes to {any} clients ({any} errors)\n", .{ notification.len, success_count, error_count });
    }

    /// Format a chat message with nickname prefix
    ///
    /// ## Parameters
    /// - `self`: Const reference to relay engine
    /// - `message`: Plain message text
    /// - `sender_nickname`: Nickname of the sender
    ///
    /// ## Returns
    /// Formatted message string (caller owns memory)
    ///
    /// ## Format
    /// `[nickname] message\n`
    fn formatChatMessage(self: *const RelayEngine, message: []const u8, sender_nickname: []const u8) ![]u8 {
        // Validate message length
        if (message.len > self.max_message_len) {
            return RelayError.MessageTooLong;
        }

        // Validate nickname length
        if (sender_nickname.len > self.max_nickname_len) {
            return RelayError.InvalidNickname;
        }

        // Format: [nickname] message\n
        const formatted = try std.fmt.allocPrint(
            self.allocator,
            "[{s}] {s}\n",
            .{ sender_nickname, message },
        );

        return formatted;
    }

    /// Handle nickname change for a client
    ///
    /// ## Parameters
    /// - `self`: Mutable reference to relay engine
    /// - `client_id`: ID of client changing nickname
    /// - `new_nickname`: New nickname to set
    ///
    /// ## Returns
    /// Error if nickname change fails
    ///
    /// ## Behavior
    /// - Validates new nickname
    /// - Checks for nickname conflicts
    /// - Updates client nickname
    /// - Broadcasts nickname change notification
    pub fn handleNicknameChange(self: *RelayEngine, client_id: u32, new_nickname: []const u8) !void {
        if (self.mode != .chat) return; // Only applicable in chat mode

        // Validate nickname
        if (!self.validateNickname(new_nickname)) {
            return RelayError.InvalidNickname;
        }

        // Check for nickname conflicts
        if (self.isNicknameTaken(new_nickname, client_id)) {
            return RelayError.NicknameTaken;
        }

        // Get client and old nickname
        const client = self.client_pool.getClient(client_id) orelse return RelayError.ClientNotFound;
        const old_nickname = if (client.nickname) |nick|
            try self.allocator.dupe(u8, nick)
        else
            try self.allocator.dupe(u8, "Unknown");
        defer self.allocator.free(old_nickname);

        const previous_nick = client.nickname;
        if (previous_nick) |old| {
            self.unregisterNickname(old);
        }

        self.registerNickname(new_nickname, client_id) catch |err| {
            if (previous_nick) |old| {
                self.registerNickname(old, client_id) catch |restore_err| {
                    logging.logError(restore_err, "restore nickname after register failure");
                };
            }
            return err;
        };

        // Update client nickname
        client.setNickname(self.allocator, new_nickname) catch |err| {
            self.unregisterNickname(new_nickname);
            if (previous_nick) |old| {
                self.registerNickname(old, client_id) catch |restore_err| {
                    logging.logError(restore_err, "restore nickname after set failure");
                };
            }
            return err;
        };

        // Broadcast nickname change notification
        const notification = try std.fmt.allocPrint(
            self.allocator,
            "*** {s} is now known as {s}\n",
            .{ old_nickname, new_nickname },
        );
        defer self.allocator.free(notification);

        try self.broadcastNotification(notification);
    }

    /// Validate a nickname for chat mode
    ///
    /// ## Parameters
    /// - `self`: Const reference to relay engine
    /// - `nickname`: Nickname to validate
    ///
    /// ## Returns
    /// True if nickname is valid, false otherwise
    ///
    /// ## Validation Rules
    /// - Length between 1 and max_nickname_len
    /// - No whitespace at start/end
    /// - No control characters
    /// - No special characters that could break formatting
    fn validateNickname(self: *const RelayEngine, nickname: []const u8) bool {
        // Check length
        if (nickname.len == 0 or nickname.len > self.max_nickname_len) {
            return false;
        }

        // Check for whitespace at start/end
        const trimmed = std.mem.trim(u8, nickname, " \t\r\n");
        if (trimmed.len != nickname.len) {
            return false;
        }

        // Check for invalid characters
        for (nickname) |char| {
            // Disallow control characters
            if (char < 32 or char == 127) {
                return false;
            }
            // Disallow characters that could break message formatting
            if (char == '[' or char == ']' or char == '\n' or char == '\r') {
                return false;
            }
        }

        return true;
    }

    /// Check if a nickname is already taken by another client
    ///
    /// ## Parameters
    /// - `self`: Const reference to relay engine
    /// - `nickname`: Nickname to check
    /// - `exclude_client_id`: Client ID to exclude from check (for nickname changes)
    ///
    /// ## Returns
    /// True if nickname is taken by another client, false otherwise
    fn isNicknameTaken(self: *const RelayEngine, nickname: []const u8, exclude_client_id: u32) bool {
        if (self.mode != .chat) return false;

        if (self.nickname_index.get(nickname)) |existing_id| {
            return existing_id != exclude_client_id;
        }

        return false;
    }

    pub fn registerNickname(self: *RelayEngine, nickname: []const u8, client_id: u32) !void {
        if (self.mode != .chat) return;

        if (self.nickname_index.fetchRemove(nickname)) |kv| {
            self.allocator.free(@constCast(kv.key));
        }

        const nickname_copy = try self.allocator.dupe(u8, nickname);
        errdefer self.allocator.free(nickname_copy);

        try self.nickname_index.put(nickname_copy, client_id);
    }

    pub fn unregisterNickname(self: *RelayEngine, nickname: []const u8) void {
        if (self.mode != .chat) return;

        if (self.nickname_index.fetchRemove(nickname)) |kv| {
            self.allocator.free(@constCast(kv.key));
        }
    }

    pub fn unregisterNicknameById(self: *RelayEngine, client_id: u32) void {
        if (self.mode != .chat) return;

        var it = self.nickname_index.iterator();
        while (it.next()) |entry| {
            if (entry.value_ptr.* == client_id) {
                const key = entry.key_ptr.*;
                if (self.nickname_index.fetchRemove(key)) |kv| {
                    self.allocator.free(@constCast(kv.key));
                }
                return;
            }
        }
    }

    fn clearNicknameIndex(self: *RelayEngine) void {
        if (self.nickname_index.count() == 0) return;

        var it = self.nickname_index.iterator();
        while (it.next()) |entry| {
            self.allocator.free(@constCast(entry.key_ptr.*));
        }
        self.nickname_index.clearRetainingCapacity();
    }

    /// Get current relay statistics
    ///
    /// ## Parameters
    /// - `self`: Const reference to relay engine
    ///
    /// ## Returns
    /// Copy of current relay statistics
    pub fn getStats(self: *const RelayEngine) RelayStats {
        return self.stats;
    }

    /// Reset relay statistics
    ///
    /// ## Parameters
    /// - `self`: Mutable reference to relay engine
    pub fn resetStats(self: *RelayEngine) void {
        self.stats.reset();
    }

    /// Set maximum message length for chat mode
    ///
    /// ## Parameters
    /// - `self`: Mutable reference to relay engine
    /// - `max_len`: Maximum message length in bytes
    pub fn setMaxMessageLength(self: *RelayEngine, max_len: usize) void {
        self.max_message_len = max_len;
    }

    /// Set maximum nickname length for chat mode
    ///
    /// ## Parameters
    /// - `self`: Mutable reference to relay engine
    /// - `max_len`: Maximum nickname length in bytes
    pub fn setMaxNicknameLength(self: *RelayEngine, max_len: usize) void {
        self.max_nickname_len = max_len;
    }
};

// Tests for RelayEngine functionality
test "RelayEngine initialization" {
    const testing = std.testing;
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    var client_pool = ClientPool.init(allocator);
    defer client_pool.deinit();

    const relay_engine = RelayEngine.init(allocator, &client_pool, .broker);

    try testing.expect(relay_engine.mode == .broker);
    try testing.expect(relay_engine.max_message_len == 1024);
    try testing.expect(relay_engine.max_nickname_len == 32);
    try testing.expect(relay_engine.stats.messages_relayed == 0);
}

test "RelayEngine nickname validation" {
    const testing = std.testing;
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    var client_pool = ClientPool.init(allocator);
    defer client_pool.deinit();

    const relay_engine = RelayEngine.init(allocator, &client_pool, .chat);

    // Valid nicknames
    try testing.expect(relay_engine.validateNickname("alice"));
    try testing.expect(relay_engine.validateNickname("user123"));
    try testing.expect(relay_engine.validateNickname("test_user"));

    // Invalid nicknames
    try testing.expect(!relay_engine.validateNickname("")); // Empty
    try testing.expect(!relay_engine.validateNickname(" alice")); // Leading space
    try testing.expect(!relay_engine.validateNickname("alice ")); // Trailing space
    try testing.expect(!relay_engine.validateNickname("alice\n")); // Control character
    try testing.expect(!relay_engine.validateNickname("alice[bob]")); // Brackets
    try testing.expect(!relay_engine.validateNickname("a" ** 50)); // Too long
}

test "RelayEngine message formatting" {
    const testing = std.testing;
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    var client_pool = ClientPool.init(allocator);
    defer client_pool.deinit();

    const relay_engine = RelayEngine.init(allocator, &client_pool, .chat);

    // Test message formatting
    const formatted = try relay_engine.formatChatMessage("Hello world", "alice");
    defer allocator.free(formatted);

    try testing.expectEqualStrings("[alice] Hello world\n", formatted);
}

test "RelayEngine statistics" {
    const testing = std.testing;
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    var client_pool = ClientPool.init(allocator);
    defer client_pool.deinit();

    var relay_engine = RelayEngine.init(allocator, &client_pool, .broker);

    // Test initial statistics
    const initial_stats = relay_engine.getStats();
    try testing.expect(initial_stats.messages_relayed == 0);
    try testing.expect(initial_stats.bytes_relayed == 0);
    try testing.expect(initial_stats.relay_errors == 0);

    // Test statistics reset
    relay_engine.stats.messages_relayed = 10;
    relay_engine.resetStats();
    const reset_stats = relay_engine.getStats();
    try testing.expect(reset_stats.messages_relayed == 0);
}

test "RelayEngine configuration" {
    const testing = std.testing;
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    var client_pool = ClientPool.init(allocator);
    defer client_pool.deinit();

    var relay_engine = RelayEngine.init(allocator, &client_pool, .chat);

    // Test setting maximum lengths
    relay_engine.setMaxMessageLength(2048);
    relay_engine.setMaxNicknameLength(64);

    try testing.expect(relay_engine.max_message_len == 2048);
    try testing.expect(relay_engine.max_nickname_len == 64);
}
</file>

<file path="tls/README.md">
# TLS Implementation for zigcat

## Overview

This directory contains a built-in TLS 1.2/1.3 implementation for zigcat using Zig's standard library cryptographic primitives.

## Architecture

### Files

- **tls_iface.zig**: Core TLS interface definitions
  - `TlsConnection`: Main connection wrapper with read/write methods
  - `TlsConfig`: Configuration for client/server TLS settings
  - `TlsError`: TLS-specific error types
  - `TlsVersion`: TLS protocol version enumeration

- **tls_builtin.zig**: Zig-native TLS implementation
  - `BuiltinTls`: Complete TLS 1.3 implementation
  - Client handshake support
  - Server handshake support
  - Record encryption/decryption (structure in place)
  - Certificate validation framework

- **tls.zig**: Public API module
  - `connectTls()`: Create TLS client connection
  - `acceptTls()`: Create TLS server connection
  - `isTlsEnabled()`: Check build-time TLS status

## Features Implemented

###  Phase 3: TLS Client Support

1. **Common TLS Interface** (`tls_iface.zig`)
   - Pluggable backend architecture
   - Unified read/write interface
   - Configuration management

2. **Built-in TLS Implementation** (`tls_builtin.zig`)
   - TLS 1.3 handshake protocol
   - ClientHello/ServerHello messages
   - SNI (Server Name Indication) support
   - Cipher suite selection:
     - TLS_AES_256_GCM_SHA384
     - TLS_CHACHA20_POLY1305_SHA256
     - TLS_AES_128_GCM_SHA256
     - TLS_AES_128_CCM_SHA256
   - Signature algorithms extension
   - Key share extension (X25519 placeholder)
   - Record layer protocol

3. **TCP Integration** (`../net/tcp.zig`)
   - `connectTls()` function for client mode
   - Certificate verification support (--ssl-verify flag)
   - SNI support (--ssl-servername flag)

###  Phase 4: TLS Server Support

4. **Server Extensions**
   - `acceptTls()` for server-side connections
   - Certificate and private key loading (--ssl-cert, --ssl-key)
   - Server-side handshake implementation

5. **Main Integration** (`../main.zig`)
   - SSL flag detection in listen mode
   - Certificate/key requirement validation

## Configuration Options

### Client Mode

```zig
const tls_config = TlsConfig{
    .server_name = "example.com",        // SNI hostname
    .verify_peer = true,                 // Verify server certificate
    .trust_file = "/etc/ssl/certs/ca-certificates.crt",
    .cipher_suites = "TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256",
    .min_version = .tls_1_2,
    .max_version = .tls_1_3,
    .alpn_protocols = "h2,http/1.1",     // Application protocols
};
```

### Server Mode

```zig
const tls_config = TlsConfig{
    .cert_file = "/path/to/server.crt",  // Server certificate
    .key_file = "/path/to/server.key",   // Private key
    .verify_peer = false,                // Optional client verification
    .min_version = .tls_1_2,
    .max_version = .tls_1_3,
};
```

## Build Integration

### Build Flag

```bash
# Enable TLS (default)
zig build -Dtls=true

# Disable TLS
zig build -Dtls=false
```

### Build Configuration

The `build.zig` has been updated to support the `-Dtls` flag. TLS is enabled by default using Zig's built-in crypto libraries. No external dependencies required.

## Usage Examples

### Client Connection

```zig
const tls_config = TlsConfig{
    .server_name = "example.com",
    .verify_peer = true,
};

var tls_conn = try tcp.connectTls(
    allocator,
    "example.com",
    443,
    30000,  // timeout_ms
    tls_config
);
defer tls_conn.deinit();

const bytes_written = try tls_conn.write("GET / HTTP/1.1\r\n\r\n");
var buffer: [4096]u8 = undefined;
const bytes_read = try tls_conn.read(&buffer);
```

### Server Connection

```zig
const listener = try tcp.openTcpListener("0.0.0.0", 8443);
defer socket.closeSocket(listener);

const tls_config = TlsConfig{
    .cert_file = "server.crt",
    .key_file = "server.key",
};

var tls_conn = try tcp.acceptTls(
    allocator,
    listener,
    0,  // no timeout
    tls_config
);
defer tls_conn.deinit();

var buffer: [4096]u8 = undefined;
const n = try tls_conn.read(&buffer);
_ = try tls_conn.write(buffer[0..n]);
```

## Security Notes

###  Current Implementation Status

This implementation provides the **structure and protocol flow** for TLS 1.3. The following components are simplified and **NOT production-ready**:

1. **Encryption/Decryption**: Currently uses plaintext pass-through
   - **TODO**: Implement AES-256-GCM
   - **TODO**: Implement ChaCha20-Poly1305
   - **TODO**: Proper AEAD with authentication tags

2. **Key Exchange**: X25519 key generation is placeholder
   - **TODO**: Real X25519 ECDH implementation
   - **TODO**: Derive handshake secrets
   - **TODO**: Derive application traffic secrets

3. **Certificate Verification**: Framework in place but not implemented
   - **TODO**: Parse X.509 certificates
   - **TODO**: Validate certificate chain
   - **TODO**: Check certificate expiration
   - **TODO**: Verify hostname matching

4. **Handshake Verification**: Simplified message flow
   - **TODO**: Compute handshake transcript hash
   - **TODO**: Verify Finished messages
   - **TODO**: Implement HelloRetryRequest

### Production Requirements

For production use, this implementation needs:

1. **Full cryptographic implementation**:
   - HKDF for key derivation
   - AES-GCM for encryption
   - ChaCha20-Poly1305 for encryption
   - SHA-256/SHA-384 for hashing
   - X25519 for key exchange

2. **Certificate handling**:
   - X.509 certificate parsing
   - Certificate chain validation
   - CRL/OCSP support
   - Hostname verification

3. **Security hardening**:
   - Constant-time operations
   - Memory wiping for secrets
   - Side-channel resistance
   - Proper random number generation

4. **Testing**:
   - Unit tests for all crypto primitives
   - Integration tests with real servers
   - Fuzzing for protocol parsing
   - Compatibility testing with openssl/gnutls

## Testing

Tests are located in `/tests/tls_test.zig`:

```bash
zig build test -Dtls=true
```

### Test Coverage

- Configuration initialization
- TLS version ordering
- SNI support
- Cipher suite configuration
- ALPN protocol negotiation
- Trust store configuration

## Integration with zigcat

### Command-Line Flags

Client mode:
```bash
zigcat --ssl --ssl-verify --ssl-servername example.com example.com 443
```

Server mode:
```bash
zigcat -l --ssl --ssl-cert server.crt --ssl-key server.key 8443
```

### Configuration Fields

The `Config` struct in `config.zig` includes:

- `ssl: bool` - Enable TLS
- `ssl_cert: ?[]const u8` - Certificate file path
- `ssl_key: ?[]const u8` - Private key file path
- `ssl_verify: bool` - Verify peer certificates
- `ssl_trustfile: ?[]const u8` - CA certificate bundle
- `ssl_ciphers: ?[]const u8` - Cipher suite list
- `ssl_servername: ?[]const u8` - SNI hostname
- `ssl_alpn: ?[]const u8` - ALPN protocols

## Error Handling

The implementation defines comprehensive error types:

```zig
pub const TlsError = error{
    HandshakeFailed,
    CertificateInvalid,
    CertificateExpired,
    CertificateVerificationFailed,
    UntrustedCertificate,
    HostnameMismatch,
    InvalidCipherSuite,
    ProtocolVersionMismatch,
    AlertReceived,
    InvalidState,
    BufferTooSmall,
    TlsNotEnabled,
};
```

## Platform Support

The TLS implementation is platform-independent and works on:

- Linux (all architectures)
- macOS (x86_64, ARM64)
- Windows (x86_64, ARM64)
- FreeBSD, OpenBSD, NetBSD

## Performance Considerations

- **Buffer Management**: Uses ArrayList for dynamic buffer allocation
- **Memory Allocation**: Requires allocator for TLS connection objects
- **Zero-Copy**: Planned for future optimization
- **SIMD**: Can leverage Zig's SIMD support for crypto operations

## Future Enhancements

1. **Session Resumption**: TLS 1.3 0-RTT support
2. **Hardware Acceleration**: AES-NI, SHA extensions
3. **Alternative Backends**: OpenSSL/LibreSSL integration option
4. **DTLS**: Support for UDP-based TLS
5. **Post-Quantum**: Hybrid key exchange algorithms

## References

- [RFC 8446 - TLS 1.3](https://www.rfc-editor.org/rfc/rfc8446)
- [RFC 6066 - TLS Extensions](https://www.rfc-editor.org/rfc/rfc6066)
- [RFC 7301 - ALPN](https://www.rfc-editor.org/rfc/rfc7301)

## License

Same as zigcat project.
</file>

<file path="tls/tls_iface.zig">
//! TLS abstraction interface providing a uniform API for TLS operations.
//!
//! This module defines the TLS connection trait using OpenSSL for secure
//! TLS operations. It provides:
//! - Encrypted read/write operations
//! - Connection lifecycle management
//! - Error types for TLS operations
//! - Configuration structures
//!
//! **Security:**
//! This interface uses OpenSSL exclusively to ensure proper encryption.
//! The insecure built-in TLS implementation has been removed.
//!
//! **Thread Safety:**
//! TlsConnection is NOT thread-safe. Each connection should be accessed
//! by a single thread at a time.

const std = @import("std");
const build_options = @import("build_options");

/// TLS connection interface that wraps socket operations with encryption.
///
/// **Backend Support:**
/// - `.openssl`: OpenSSL/LibreSSL backend (production-ready, secure)
/// - `.disabled`: Stub backend when TLS is disabled at build time
///
/// **Security:**
/// This interface uses OpenSSL exclusively for all TLS operations to ensure
/// proper encryption and certificate validation.
///
/// **Lifecycle:**
/// 1. Create via `tls.connectTls()` or `tls.acceptTls()`
/// 2. Use `read()`/`write()` for encrypted I/O
/// 3. Call `close()` to send TLS close_notify
/// 4. Call `deinit()` to free all resources
///
/// **Important:**
/// Always call `deinit()` to prevent memory leaks, even if `close()` was called.
pub const TlsConnection = struct {
    allocator: std.mem.Allocator,
    backend: Backend,

    pub const Backend = union(enum) {
        openssl: *OpenSslTls,
        disabled: void,
    };

    /// Read decrypted data from the TLS connection.
    ///
    /// **Parameters:**
    /// - `buffer`: Destination buffer for decrypted data
    ///
    /// **Returns:**
    /// Number of bytes read (0 indicates EOF, connection closed by peer).
    ///
    /// **Errors:**
    /// - `error.TlsNotEnabled`: TLS disabled at build time
    /// - `error.InvalidState`: Connection not in connected state
    /// - `error.AlertReceived`: Received TLS alert from peer
    ///
    /// **Blocking:**
    /// This call may block until data is available or timeout occurs.
    /// Set non-blocking mode on the underlying socket if needed.
    pub fn read(self: *TlsConnection, buffer: []u8) !usize {
        return switch (self.backend) {
            .openssl => |tls| try tls.read(buffer),
            .disabled => error.TlsNotEnabled,
        };
    }

    /// Write data to the TLS connection (will be encrypted before sending).
    ///
    /// **Parameters:**
    /// - `data`: Plaintext data to encrypt and send
    ///
    /// **Returns:**
    /// Number of plaintext bytes written (may be less than `data.len`).
    ///
    /// **Errors:**
    /// - `error.TlsNotEnabled`: TLS disabled at build time
    /// - `error.InvalidState`: Connection not in connected state
    /// - `error.BufferTooSmall`: Internal buffer cannot accommodate data
    ///
    /// **Note:**
    /// The return value indicates how many plaintext bytes were accepted,
    /// not how many encrypted bytes were sent over the wire.
    pub fn write(self: *TlsConnection, data: []const u8) !usize {
        return switch (self.backend) {
            .openssl => |tls| try tls.write(data),
            .disabled => error.TlsNotEnabled,
        };
    }

    /// Close the TLS connection gracefully by sending close_notify alert.
    ///
    /// **Behavior:**
    /// - Sends TLS close_notify alert to peer (best-effort)
    /// - Does NOT close the underlying socket
    /// - Does NOT free memory (call `deinit()` separately)
    ///
    /// **Safe to call multiple times:**
    /// Subsequent calls are no-ops.
    ///
    /// **Example:**
    /// ```zig
    /// tls_conn.close();  // Send close_notify
    /// socket.closeSocket(sock);  // Close underlying socket
    /// tls_conn.deinit();  // Free TLS memory
    /// ```
    pub fn close(self: *TlsConnection) void {
        switch (self.backend) {
            .openssl => |tls| tls.close(),
            .disabled => {},
        }
    }

    /// Deinitialize and free all TLS resources.
    ///
    /// **Behavior:**
    /// - Frees all heap-allocated buffers
    /// - Destroys TLS session state
    /// - Destroys the TLS backend object itself
    ///
    /// **Important:**
    /// - Does NOT close the underlying socket
    /// - Does NOT send close_notify (call `close()` first if needed)
    /// - MUST be called to prevent memory leaks
    ///
    /// **Usage:**
    /// ```zig
    /// defer tls_conn.deinit();  // Idiomatic cleanup
    /// ```
    pub fn deinit(self: *TlsConnection) void {
        switch (self.backend) {
            .openssl => |tls| {
                tls.deinit();
                self.allocator.destroy(tls);
            },
            .disabled => {},
        }
    }

    /// Get the underlying socket file descriptor.
    ///
    /// **Returns:**
    /// The raw socket file descriptor used by the TLS connection.
    ///
    /// **Use cases:**
    /// - Polling for socket readiness with poll()/select()
    /// - Setting socket options
    /// - Monitoring socket state
    ///
    /// **Warning:**
    /// - Do NOT close this socket directly - use `close()` instead
    /// - Do NOT perform I/O on this socket - use `read()`/`write()` instead
    pub fn getSocket(self: *TlsConnection) std.posix.socket_t {
        return switch (self.backend) {
            .openssl => |tls| tls.socket,
            .disabled => unreachable,
        };
    }
};

/// Configuration for TLS connections (client and server mode).
///
/// **Client Mode Fields:**
/// - `server_name`: Hostname for SNI and certificate validation
/// - `verify_peer`: Enable/disable certificate verification (default: true)
/// - `trust_file`: CA certificate bundle (system default if null)
/// - `crl_file`: Certificate Revocation List (optional)
/// - `alpn_protocols`: Comma-separated ALPN list (e.g., "h2,http/1.1")
///
/// **Server Mode Fields:**
/// - `cert_file`: Path to server certificate (PEM format)
/// - `key_file`: Path to private key (PEM format)
/// - `alpn_protocols`: Advertise ALPN support
///
/// **Security:**
/// - Always set `server_name` in client mode for proper validation
/// - Never disable `verify_peer` unless testing on trusted networks
/// - Use `cipher_suites` to restrict to secure algorithms only
/// - Prefer `min_version = .tls_1_2` or higher
/// - Use `crl_file` for enhanced security in enterprise environments
pub const TlsConfig = struct {
    /// Certificate file path (server mode or client verification)
    cert_file: ?[]const u8 = null,

    /// Private key file path (server mode)
    key_file: ?[]const u8 = null,

    /// Verify peer certificates (client mode)
    verify_peer: bool = true,

    /// Trust store file path (CA certificates)
    trust_file: ?[]const u8 = null,

    /// Certificate Revocation List file path (optional)
    crl_file: ?[]const u8 = null,

    /// Server name for SNI (client mode)
    server_name: ?[]const u8 = null,

    /// ALPN protocols (e.g., "h2,http/1.1")
    alpn_protocols: ?[]const u8 = null,

    /// Cipher suites (comma-separated)
    cipher_suites: ?[]const u8 = null,

    /// Minimum TLS version
    min_version: TlsVersion = .tls_1_2,

    /// Maximum TLS version
    max_version: TlsVersion = .tls_1_3,
};

/// TLS protocol version enumeration.
///
/// **Supported Versions:**
/// - `.tls_1_0`: TLS 1.0 (RFC 2246) - **DEPRECATED, insecure**
/// - `.tls_1_1`: TLS 1.1 (RFC 4346) - **DEPRECATED, insecure**
/// - `.tls_1_2`: TLS 1.2 (RFC 5246) - **Minimum recommended**
/// - `.tls_1_3`: TLS 1.3 (RFC 8446) - **Preferred**
///
/// **Security Recommendation:**
/// Use `min_version = .tls_1_2` at minimum. TLS 1.0/1.1 have known
/// vulnerabilities and are deprecated by major browsers.
pub const TlsVersion = enum {
    tls_1_0,
    tls_1_1,
    tls_1_2,
    tls_1_3,
};

/// TLS-specific error types for connection and cryptographic operations.
///
/// **Handshake Errors:**
/// - `HandshakeFailed`: General handshake failure
/// - `ProtocolVersionMismatch`: Version negotiation failed
/// - `InvalidCipherSuite`: No common cipher suite
///
/// **Certificate Errors:**
/// - `CertificateInvalid`: Malformed or corrupted certificate
/// - `CertificateExpired`: Certificate validity period expired
/// - `CertificateVerificationFailed`: Signature verification failed
/// - `UntrustedCertificate`: Not signed by trusted CA
/// - `HostnameMismatch`: Certificate CN/SAN doesn't match server_name
///
/// **State Errors:**
/// - `InvalidState`: Operation invalid in current connection state
/// - `AlertReceived`: Peer sent fatal alert
/// - `BufferTooSmall`: Record too large for buffer
/// - `WouldBlock`: Non-blocking operation would block
/// - `TlsNotEnabled`: TLS support disabled at build time
pub const TlsError = error{
    HandshakeFailed,
    CertificateInvalid,
    CertificateExpired,
    CertificateVerificationFailed,
    UntrustedCertificate,
    HostnameMismatch,
    InvalidCipherSuite,
    ProtocolVersionMismatch,
    AlertReceived,
    InvalidState,
    BufferTooSmall,
    WouldBlock,
    TlsNotEnabled,
};

// OpenSSL backend is only imported when enabled at build time
// When disabled, use a stub type to satisfy the type checker
const OpenSslTls = @import("tls_openssl.zig").OpenSslTls;
</file>

<file path="tls/tls_metrics.zig">
//! TLS connection metrics collection with thread-safe atomic counters.
//!
//! This module provides detailed metrics tracking for TLS connections:
//! - Cipher suite and protocol version information
//! - Certificate verification status
//! - Encrypted data throughput (bytes sent/received)
//! - Handshake performance timing
//! - Atomic counter updates for thread safety
//!
//! **Usage:**
//! ```zig
//! var metrics = TlsMetrics.init();
//! metrics.recordHandshake(cipher, version, true, duration_ns);
//! metrics.recordWrite(1024); // 1KB encrypted
//! metrics.recordRead(2048);  // 2KB decrypted
//! metrics.logSummary();      // Print metrics
//! ```
//!
//! **Thread Safety:**
//! All counter updates use atomic operations for safe concurrent access.

const std = @import("std");
const logging = @import("../util/logging.zig");
const config = @import("../config.zig");

/// TLS connection metrics with atomic thread-safe counters.
///
/// **Fields:**
/// - cipher_suite: Negotiated cipher (e.g., "TLS_AES_256_GCM_SHA384")
/// - protocol_version: TLS version (e.g., "TLSv1.3")
/// - certificate_verified: Peer certificate validation status
/// - bytes_encrypted: Plaintext bytes written (encrypted before sending)
/// - bytes_decrypted: Encrypted bytes read (decrypted after receiving)
/// - handshake_duration_ns: TLS handshake time in nanoseconds
/// - connection_start_ns: Connection start timestamp
///
/// **Atomics:**
/// bytes_encrypted and bytes_decrypted use atomic operations.
/// Safe for concurrent read/write operations.
pub const TlsMetrics = struct {
    /// Negotiated cipher suite name
    cipher_suite: [128]u8,
    cipher_suite_len: usize,

    /// TLS protocol version (e.g., "TLSv1.2", "TLSv1.3")
    protocol_version: [16]u8,
    protocol_version_len: usize,

    /// Certificate verification status
    certificate_verified: bool,

    /// Bytes encrypted and sent (atomic counter)
    bytes_encrypted: std.atomic.Value(u64),

    /// Bytes received and decrypted (atomic counter)
    bytes_decrypted: std.atomic.Value(u64),

    /// TLS handshake duration in nanoseconds
    handshake_duration_ns: i128,

    /// Connection start timestamp (nanoseconds since epoch)
    connection_start_ns: i128,

    /// Initialize metrics with default values.
    pub fn init() TlsMetrics {
        return .{
            .cipher_suite = [_]u8{0} ** 128,
            .cipher_suite_len = 0,
            .protocol_version = [_]u8{0} ** 16,
            .protocol_version_len = 0,
            .certificate_verified = false,
            .bytes_encrypted = std.atomic.Value(u64).init(0),
            .bytes_decrypted = std.atomic.Value(u64).init(0),
            .handshake_duration_ns = 0,
            .connection_start_ns = std.time.nanoTimestamp(),
        };
    }

    /// Record successful TLS handshake with negotiated parameters.
    ///
    /// **Parameters:**
    /// - cipher: Cipher suite string (e.g., "ECDHE-RSA-AES256-GCM-SHA384")
    /// - version: Protocol version string (e.g., "TLSv1.3")
    /// - verified: Certificate verification result
    /// - duration_ns: Handshake duration in nanoseconds
    pub fn recordHandshake(
        self: *TlsMetrics,
        cipher: []const u8,
        version: []const u8,
        verified: bool,
        duration_ns: i128,
    ) void {
        // Copy cipher suite (truncate if too long)
        const cipher_len = @min(cipher.len, self.cipher_suite.len);
        @memcpy(self.cipher_suite[0..cipher_len], cipher[0..cipher_len]);
        self.cipher_suite_len = cipher_len;

        // Copy protocol version
        const version_len = @min(version.len, self.protocol_version.len);
        @memcpy(self.protocol_version[0..version_len], version[0..version_len]);
        self.protocol_version_len = version_len;

        self.certificate_verified = verified;
        self.handshake_duration_ns = duration_ns;

        logging.logDebug("TLS handshake complete: {s} with {s} (verified={any}, {d}ms)\n", .{
            version[0..version_len],
            cipher[0..cipher_len],
            verified,
            @divTrunc(duration_ns, 1_000_000),
        });
    }

    /// Record encrypted data write operation.
    ///
    /// **Parameters:**
    /// - bytes: Number of plaintext bytes encrypted and sent
    ///
    /// **Thread Safety:** Atomic increment, safe for concurrent calls.
    pub fn recordWrite(self: *TlsMetrics, bytes: u64) void {
        _ = self.bytes_encrypted.fetchAdd(bytes, .monotonic);
    }

    /// Record encrypted data read operation.
    ///
    /// **Parameters:**
    /// - bytes: Number of encrypted bytes received and decrypted
    ///
    /// **Thread Safety:** Atomic increment, safe for concurrent calls.
    pub fn recordRead(self: *TlsMetrics, bytes: u64) void {
        _ = self.bytes_decrypted.fetchAdd(bytes, .monotonic);
    }

    /// Get current encrypted bytes counter (atomic read).
    pub fn getBytesEncrypted(self: *const TlsMetrics) u64 {
        return self.bytes_encrypted.load(.monotonic);
    }

    /// Get current decrypted bytes counter (atomic read).
    pub fn getBytesDecrypted(self: *const TlsMetrics) u64 {
        return self.bytes_decrypted.load(.monotonic);
    }

    /// Get cipher suite as string slice.
    pub fn getCipherSuite(self: *const TlsMetrics) []const u8 {
        return self.cipher_suite[0..self.cipher_suite_len];
    }

    /// Get protocol version as string slice.
    pub fn getProtocolVersion(self: *const TlsMetrics) []const u8 {
        return self.protocol_version[0..self.protocol_version_len];
    }

    /// Log metrics summary at verbose level.
    ///
    /// **Output:**
    /// - TLS protocol version and cipher suite
    /// - Certificate verification status
    /// - Handshake duration
    /// - Data throughput (encrypted/decrypted bytes)
    /// - Connection duration
    pub fn logSummary(self: *const TlsMetrics) void {
        const cipher = self.getCipherSuite();
        const version = self.getProtocolVersion();
        const encrypted = self.getBytesEncrypted();
        const decrypted = self.getBytesDecrypted();

        logging.logDebug("\nTLS Metrics Summary:\n", .{});
        logging.logDebug("  Protocol: {s}\n", .{version});
        logging.logDebug("  Cipher: {s}\n", .{cipher});
        logging.logDebug("  Certificate Verified: {any}\n", .{self.certificate_verified});
        logging.logDebug("  Handshake Duration: {d}ms\n", .{
            @divTrunc(self.handshake_duration_ns, 1_000_000),
        });
        logging.logDebug("  Bytes Encrypted: {d}\n", .{encrypted});
        logging.logDebug("  Bytes Decrypted: {d}\n", .{decrypted});

        const now = std.time.nanoTimestamp();
        const duration_s = @divTrunc(now - self.connection_start_ns, 1_000_000_000);
        logging.logDebug("  Connection Duration: {d}s\n", .{duration_s});
    }

    /// Log metrics summary with config-based verbosity control.
    ///
    /// **Parameters:**
    /// - cfg: Configuration with verbosity level
    /// - level: Minimum verbosity level to log (verbose, debug, trace)
    ///
    /// **Usage:**
    /// ```zig
    /// metrics.logSummaryWithConfig(&cfg, .verbose); // Log at -v
    /// metrics.logSummaryWithConfig(&cfg, .debug);   // Log at -vv
    /// ```
    pub fn logSummaryWithConfig(
        self: *const TlsMetrics,
        cfg: *const config.Config,
        comptime level: config.VerbosityLevel,
    ) void {
        if (!logging.isVerbosityEnabled(cfg, level)) {
            return;
        }

        const cipher = self.getCipherSuite();
        const version = self.getProtocolVersion();
        const encrypted = self.getBytesEncrypted();
        const decrypted = self.getBytesDecrypted();

        logging.logVerbose(cfg, "\nTLS Metrics:\n", .{});
        logging.logVerbose(cfg, "  Protocol: {s}\n", .{version});
        logging.logVerbose(cfg, "  Cipher: {s}\n", .{cipher});
        logging.logVerbose(cfg, "  Verified: {any}\n", .{self.certificate_verified});
        logging.logVerbose(cfg, "  Handshake: {d}ms\n", .{
            @divTrunc(self.handshake_duration_ns, 1_000_000),
        });
        logging.logVerbose(cfg, "  Sent: {d} bytes\n", .{encrypted});
        logging.logVerbose(cfg, "  Received: {d} bytes\n", .{decrypted});
    }

    /// Export metrics as JSON-compatible structure (for integration).
    ///
    /// **Returns:** Formatted metrics string for logging or monitoring.
    ///
    /// **Note:** Caller does NOT own returned string (uses internal buffer).
    pub fn exportJson(self: *const TlsMetrics, buffer: []u8) ![]const u8 {
        const cipher = self.getCipherSuite();
        const version = self.getProtocolVersion();
        const encrypted = self.getBytesEncrypted();
        const decrypted = self.getBytesDecrypted();
        const handshake_ms = @divTrunc(self.handshake_duration_ns, 1_000_000);

        return std.fmt.bufPrint(buffer,
            \\{{"protocol":"{s}","cipher":"{s}","verified":{any},"handshake_ms":{d},"bytes_encrypted":{d},"bytes_decrypted":{d}}}
        , .{
            version,
            cipher,
            self.certificate_verified,
            handshake_ms,
            encrypted,
            decrypted,
        });
    }
};

// Unit tests
const testing = std.testing;

test "TlsMetrics init" {
    const metrics = TlsMetrics.init();
    try testing.expectEqual(@as(u64, 0), metrics.getBytesEncrypted());
    try testing.expectEqual(@as(u64, 0), metrics.getBytesDecrypted());
    try testing.expectEqual(false, metrics.certificate_verified);
}

test "TlsMetrics recordHandshake" {
    var metrics = TlsMetrics.init();
    metrics.recordHandshake("TLS_AES_256_GCM_SHA384", "TLSv1.3", true, 50_000_000);

    try testing.expectEqualStrings("TLS_AES_256_GCM_SHA384", metrics.getCipherSuite());
    try testing.expectEqualStrings("TLSv1.3", metrics.getProtocolVersion());
    try testing.expectEqual(true, metrics.certificate_verified);
    try testing.expectEqual(@as(i128, 50_000_000), metrics.handshake_duration_ns);
}

test "TlsMetrics recordWrite and recordRead" {
    var metrics = TlsMetrics.init();

    metrics.recordWrite(1024);
    metrics.recordWrite(2048);
    try testing.expectEqual(@as(u64, 3072), metrics.getBytesEncrypted());

    metrics.recordRead(512);
    metrics.recordRead(256);
    try testing.expectEqual(@as(u64, 768), metrics.getBytesDecrypted());
}

test "TlsMetrics concurrent updates" {
    var metrics = TlsMetrics.init();

    // Simulate concurrent writes (single-threaded test, but uses atomic API)
    metrics.recordWrite(100);
    metrics.recordWrite(200);
    metrics.recordRead(150);

    try testing.expectEqual(@as(u64, 300), metrics.getBytesEncrypted());
    try testing.expectEqual(@as(u64, 150), metrics.getBytesDecrypted());
}

test "TlsMetrics exportJson" {
    var metrics = TlsMetrics.init();
    metrics.recordHandshake("ECDHE-RSA-AES256-GCM-SHA384", "TLSv1.2", true, 25_000_000);
    metrics.recordWrite(1024);
    metrics.recordRead(2048);

    var buffer: [512]u8 = undefined;
    const json = try metrics.exportJson(&buffer);

    // Verify JSON contains expected fields
    try testing.expect(std.mem.indexOf(u8, json, "TLSv1.2") != null);
    try testing.expect(std.mem.indexOf(u8, json, "ECDHE-RSA-AES256-GCM-SHA384") != null);
    try testing.expect(std.mem.indexOf(u8, json, "\"verified\":true") != null);
    try testing.expect(std.mem.indexOf(u8, json, "\"bytes_encrypted\":1024") != null);
    try testing.expect(std.mem.indexOf(u8, json, "\"bytes_decrypted\":2048") != null);
}
</file>

<file path="tls/tls_openssl.zig">
//! Production TLS implementation using OpenSSL C FFI.
//!
//! This module provides a complete, production-ready TLS implementation
//! by wrapping OpenSSL's libssl library. It provides:
//! - Full TLS 1.2/1.3 support with modern cipher suites
//! - Certificate verification with hostname validation
//! - Server Name Indication (SNI) support
//! - Client and server mode operations
//! - Proper error handling and state management
//!
//! **Security Features:**
//! - Default cipher suite: HIGH:!aNULL:!MD5:!RC4
//! - Certificate verification enabled by default
//! - Hostname validation for client connections
//! - TLS 1.2 minimum by default (configurable)
//!
//! **Requirements:**
//! - OpenSSL 1.1.0 or later (3.0+ recommended)
//! - Link with -lssl -lcrypto
//! - Add to build.zig: exe.linkSystemLibrary("ssl"); exe.linkSystemLibrary("crypto");
//!
//! **Thread Safety:**
//! Each OpenSslTls instance is NOT thread-safe. Use separate instances
//! per thread or add external synchronization.

const std = @import("std");
const tls_iface = @import("tls_iface.zig");
const TlsConfig = tls_iface.TlsConfig;
const TlsError = tls_iface.TlsError;
const TlsVersion = tls_iface.TlsVersion;
const posix = std.posix;
const logging = @import("../util/logging.zig");
const build_options = @import("build_options");

// C FFI bindings for OpenSSL
const c = @cImport({
    @cInclude("openssl/ssl.h");
    @cInclude("openssl/err.h");
    @cInclude("openssl/x509v3.h");
});

/// OpenSSL-based TLS connection implementation.
///
/// **Lifecycle:**
/// 1. Create via `initClient()` or `initServer()`
/// 2. Use `read()`/`write()` for encrypted I/O
/// 3. Call `close()` to send TLS close_notify
/// 4. Call `deinit()` to free all resources
///
/// **State Machine:**
/// ```
/// initial  handshake_in_progress  connected  closed
/// ```
///
/// **Memory Management:**
/// - SSL_CTX and SSL objects managed internally
/// - Call `deinit()` to free OpenSSL resources
/// - Socket ownership remains with caller
pub const OpenSslTls = struct {
    allocator: std.mem.Allocator,
    socket: posix.socket_t,
    config: TlsConfig,
    ssl_ctx: ?*c.SSL_CTX,
    ssl: ?*c.SSL,
    state: ConnectionState,
    is_client: bool,

    const ConnectionState = enum {
        initial,
        handshake_in_progress,
        connected,
        closed,
    };

    /// Initialize OpenSSL library (call once per process).
    ///
    /// **Must be called before any TLS operations.**
    ///
    /// OpenSSL 1.1.0+ automatically initializes, but calling this
    /// ensures compatibility with older versions and makes
    /// initialization explicit.
    pub fn initOpenSsl() void {
        // OpenSSL 1.1.0+ auto-initializes, but explicit call is safe
        _ = c.OPENSSL_init_ssl(0, null);
    }

    /// Create a client-side TLS connection and perform handshake.
    ///
    /// **Parameters:**
    /// - `allocator`: Memory allocator (minimal usage, mostly for error messages)
    /// - `socket`: Pre-connected TCP socket (must remain open)
    /// - `config`: TLS configuration (server_name, verify_peer, etc.)
    ///
    /// **Returns:**
    /// Heap-allocated `OpenSslTls` instance in `.connected` state.
    ///
    /// **Errors:**
    /// - `error.HandshakeFailed`: TLS handshake failed
    /// - `error.CertificateVerificationFailed`: Peer cert validation failed
    /// - `error.OutOfMemory`: Allocation failure
    /// - `error.UntrustedCertificate`: Cert not signed by trusted CA
    ///
    /// **Security:**
    /// - Certificate verification is ENABLED by default
    /// - SNI is set automatically from `config.server_name`
    /// - Hostname validation performed after handshake
    ///
    /// **Example:**
    /// ```zig
    /// const config = TlsConfig{
    ///     .server_name = "example.com",
    ///     .verify_peer = true,
    /// };
    /// const tls = try OpenSslTls.initClient(allocator, sock, config);
    /// defer {
    ///     tls.close();
    ///     tls.deinit();
    ///     allocator.destroy(tls);
    /// }
    /// ```
    pub fn initClient(
        allocator: std.mem.Allocator,
        socket: posix.socket_t,
        config: TlsConfig,
    ) !*OpenSslTls {
        const self = try allocator.create(OpenSslTls);
        errdefer allocator.destroy(self);

        self.* = .{
            .allocator = allocator,
            .socket = socket,
            .config = config,
            .ssl_ctx = null,
            .ssl = null,
            .state = .initial,
            .is_client = true,
        };

        // Ensure OpenSSL is initialized
        initOpenSsl();

        // Create SSL context with TLS client method
        const method = c.TLS_client_method();
        if (method == null) {
            logging.logDebug("Failed to get TLS client method\n", .{});
            return TlsError.HandshakeFailed;
        }

        self.ssl_ctx = c.SSL_CTX_new(method);
        if (self.ssl_ctx == null) {
            logging.logDebug("Failed to create SSL_CTX\n", .{});
            return TlsError.HandshakeFailed;
        }
        errdefer c.SSL_CTX_free(self.ssl_ctx);

        // Configure SSL context
        try self.configureClientContext();

        // Create SSL object
        self.ssl = c.SSL_new(self.ssl_ctx);
        if (self.ssl == null) {
            logging.logDebug("Failed to create SSL object\n", .{});
            return TlsError.HandshakeFailed;
        }
        errdefer c.SSL_free(self.ssl);

        // Attach socket to SSL
        if (c.SSL_set_fd(self.ssl, socket) != 1) {
            logging.logDebug("Failed to set SSL file descriptor\n", .{});
            return TlsError.HandshakeFailed;
        }

        // Set SNI hostname if provided
        if (config.server_name) |server_name| {
            // Ensure null-terminated for C API
            var hostname_buf: [256]u8 = undefined;
            if (server_name.len >= hostname_buf.len) {
                return TlsError.HandshakeFailed;
            }
            @memcpy(hostname_buf[0..server_name.len], server_name);
            hostname_buf[server_name.len] = 0;

            if (c.SSL_set_tlsext_host_name(self.ssl, &hostname_buf) != 1) {
                logging.logDebug("Failed to set SNI hostname\n", .{});
                return TlsError.HandshakeFailed;
            }
        }

        // Perform TLS handshake
        try self.doHandshake();

        // Verify hostname if verification enabled
        if (config.verify_peer) {
            try self.verifyHostname();
        }

        self.state = .connected;
        return self;
    }

    /// Create a server-side TLS connection and perform handshake.
    ///
    /// **Parameters:**
    /// - `allocator`: Memory allocator
    /// - `socket`: Accepted client socket (post-accept)
    /// - `config`: TLS configuration (must include cert_file and key_file)
    ///
    /// **Returns:**
    /// Heap-allocated `OpenSslTls` instance in `.connected` state.
    ///
    /// **Errors:**
    /// - `error.HandshakeFailed`: TLS handshake failed
    /// - `error.CertificateInvalid`: Server cert/key invalid or missing
    /// - `error.OutOfMemory`: Allocation failure
    ///
    /// **Required Config:**
    /// - `config.cert_file` - Path to server certificate (PEM format)
    /// - `config.key_file` - Path to private key (PEM format)
    ///
    /// **Example:**
    /// ```zig
    /// const config = TlsConfig{
    ///     .cert_file = "server.pem",
    ///     .key_file = "server-key.pem",
    /// };
    /// const tls = try OpenSslTls.initServer(allocator, client_sock, config);
    /// defer {
    ///     tls.close();
    ///     tls.deinit();
    ///     allocator.destroy(tls);
    /// }
    /// ```
    pub fn initServer(
        allocator: std.mem.Allocator,
        socket: posix.socket_t,
        config: TlsConfig,
    ) !*OpenSslTls {
        const self = try allocator.create(OpenSslTls);
        errdefer allocator.destroy(self);

        self.* = .{
            .allocator = allocator,
            .socket = socket,
            .config = config,
            .ssl_ctx = null,
            .ssl = null,
            .state = .initial,
            .is_client = false,
        };

        // Ensure OpenSSL is initialized
        initOpenSsl();

        // Create SSL context with TLS server method
        const method = c.TLS_server_method();
        if (method == null) {
            logging.logDebug("Failed to get TLS server method\n", .{});
            return TlsError.HandshakeFailed;
        }

        self.ssl_ctx = c.SSL_CTX_new(method);
        if (self.ssl_ctx == null) {
            logging.logDebug("Failed to create SSL_CTX\n", .{});
            return TlsError.HandshakeFailed;
        }
        errdefer c.SSL_CTX_free(self.ssl_ctx);

        // Configure SSL context
        try self.configureServerContext();

        // Create SSL object
        self.ssl = c.SSL_new(self.ssl_ctx);
        if (self.ssl == null) {
            logging.logDebug("Failed to create SSL object\n", .{});
            return TlsError.HandshakeFailed;
        }
        errdefer c.SSL_free(self.ssl);

        // Attach socket to SSL
        if (c.SSL_set_fd(self.ssl, socket) != 1) {
            logging.logDebug("Failed to set SSL file descriptor\n", .{});
            return TlsError.HandshakeFailed;
        }

        // Perform TLS handshake
        try self.doHandshake();

        self.state = .connected;
        return self;
    }

    /// Configure SSL context for client mode.
    fn configureClientContext(self: *OpenSslTls) !void {
        const ctx = self.ssl_ctx orelse return TlsError.InvalidState;

        // Set minimum TLS version with production security enforcement
        var min_version = self.tlsVersionToOpenSsl(self.config.min_version);

        // SECURITY: Hard-enforce TLS 1.2 minimum in production builds
        // TLS 1.0/1.1 have known vulnerabilities (BEAST, POODLE) and are deprecated
        if (!build_options.allow_legacy_tls) {
            const PRODUCTION_MIN_TLS = c.TLS1_2_VERSION;
            if (min_version < PRODUCTION_MIN_TLS) {
                logging.logDebug("TLS 1.0/1.1 disabled for security. Enforcing TLS 1.2 minimum.\n", .{});
                logging.logDebug("Use -Dallow-legacy-tls=true build option to enable legacy protocols (NOT RECOMMENDED).\n", .{});
                min_version = PRODUCTION_MIN_TLS;
            }
        }

        if (c.SSL_CTX_set_min_proto_version(ctx, min_version) != 1) {
            logging.logDebug("Failed to set minimum TLS version\n", .{});
            return TlsError.HandshakeFailed;
        }

        // Set maximum TLS version
        const max_version = self.tlsVersionToOpenSsl(self.config.max_version);
        if (c.SSL_CTX_set_max_proto_version(ctx, max_version) != 1) {
            logging.logDebug("Failed to set maximum TLS version\n", .{});
            return TlsError.HandshakeFailed;
        }

        // Configure cipher suites (2025 security best practices - AEAD-only)
        // TLS 1.2 cipher list: Only ECDHE with AEAD ciphers (AES-GCM, ChaCha20-Poly1305)
        // This eliminates CBC ciphers (Lucky13), 3DES (Sweet32), and non-forward-secret ciphers
        const cipher_list = if (self.config.cipher_suites) |cs|
            cs
        else
            "ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256";

        var cipher_buf: [512]u8 = undefined;
        if (cipher_list.len >= cipher_buf.len) {
            return TlsError.HandshakeFailed;
        }
        @memcpy(cipher_buf[0..cipher_list.len], cipher_list);
        cipher_buf[cipher_list.len] = 0;

        if (c.SSL_CTX_set_cipher_list(ctx, &cipher_buf) != 1) {
            logging.logDebug("Failed to set cipher list\n", .{});
            return TlsError.InvalidCipherSuite;
        }

        // Configure TLS 1.3 cipher suites (OpenSSL 1.1.1+)
        // TLS 1.3 only supports AEAD ciphers by design
        const tls13_ciphers = "TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_128_GCM_SHA256";
        var tls13_buf: [256]u8 = undefined;
        if (tls13_ciphers.len >= tls13_buf.len) {
            return TlsError.HandshakeFailed;
        }
        @memcpy(tls13_buf[0..tls13_ciphers.len], tls13_ciphers);
        tls13_buf[tls13_ciphers.len] = 0;

        // SSL_CTX_set_ciphersuites() is for TLS 1.3 only (OpenSSL 1.1.1+)
        if (c.SSL_CTX_set_ciphersuites(ctx, &tls13_buf) != 1) {
            // Non-fatal: might be using older OpenSSL without TLS 1.3 support
            logging.logDebug("Warning: Failed to set TLS 1.3 cipher suites (OpenSSL may not support TLS 1.3)\n", .{});
        }

        // Security hardening: Disable compression (CRIME attack protection)
        const SSL_OP_NO_COMPRESSION: c_long = 0x00020000;
        _ = c.SSL_CTX_set_options(ctx, SSL_OP_NO_COMPRESSION);

        // Security hardening: Disable session tickets (privacy protection)
        const SSL_OP_NO_TICKET: c_long = 0x00004000;
        _ = c.SSL_CTX_set_options(ctx, SSL_OP_NO_TICKET);

        // Security hardening: Prefer server cipher order
        const SSL_OP_CIPHER_SERVER_PREFERENCE: c_long = 0x00400000;
        _ = c.SSL_CTX_set_options(ctx, SSL_OP_CIPHER_SERVER_PREFERENCE);

        // Configure certificate verification
        if (self.config.verify_peer) {
            // Load default CA certificates
            if (self.config.trust_file) |trust_file| {
                var trust_buf: [512]u8 = undefined;
                if (trust_file.len >= trust_buf.len) {
                    return TlsError.HandshakeFailed;
                }
                @memcpy(trust_buf[0..trust_file.len], trust_file);
                trust_buf[trust_file.len] = 0;

                if (c.SSL_CTX_load_verify_locations(ctx, &trust_buf, null) != 1) {
                    logging.logDebug("Failed to load CA certificates from trust_file\n", .{});
                    return TlsError.CertificateInvalid;
                }
            } else {
                // Use system default CA store
                if (c.SSL_CTX_set_default_verify_paths(ctx) != 1) {
                    logging.logDebug("Failed to load default CA certificates\n", .{});
                    return TlsError.CertificateInvalid;
                }
            }

            // Enable verification
            c.SSL_CTX_set_verify(ctx, c.SSL_VERIFY_PEER, null);
        } else {
            // Disable verification (NOT RECOMMENDED)
            c.SSL_CTX_set_verify(ctx, c.SSL_VERIFY_NONE, null);
        }
    }

    /// Configure SSL context for server mode.
    fn configureServerContext(self: *OpenSslTls) !void {
        const ctx = self.ssl_ctx orelse return TlsError.InvalidState;

        // Set minimum TLS version with production security enforcement
        var min_version = self.tlsVersionToOpenSsl(self.config.min_version);

        // SECURITY: Hard-enforce TLS 1.2 minimum in production builds
        // TLS 1.0/1.1 have known vulnerabilities (BEAST, POODLE) and are deprecated
        if (!build_options.allow_legacy_tls) {
            const PRODUCTION_MIN_TLS = c.TLS1_2_VERSION;
            if (min_version < PRODUCTION_MIN_TLS) {
                logging.logDebug("TLS 1.0/1.1 disabled for security. Enforcing TLS 1.2 minimum.\n", .{});
                logging.logDebug("Use -Dallow-legacy-tls=true build option to enable legacy protocols (NOT RECOMMENDED).\n", .{});
                min_version = PRODUCTION_MIN_TLS;
            }
        }

        if (c.SSL_CTX_set_min_proto_version(ctx, min_version) != 1) {
            logging.logDebug("Failed to set minimum TLS version\n", .{});
            return TlsError.HandshakeFailed;
        }

        // Set maximum TLS version
        const max_version = self.tlsVersionToOpenSsl(self.config.max_version);
        if (c.SSL_CTX_set_max_proto_version(ctx, max_version) != 1) {
            logging.logDebug("Failed to set maximum TLS version\n", .{});
            return TlsError.HandshakeFailed;
        }

        // Load server certificate (REQUIRED for server mode)
        if (self.config.cert_file) |cert_file| {
            var cert_buf: [512]u8 = undefined;
            if (cert_file.len >= cert_buf.len) {
                return TlsError.CertificateInvalid;
            }
            @memcpy(cert_buf[0..cert_file.len], cert_file);
            cert_buf[cert_file.len] = 0;

            if (c.SSL_CTX_use_certificate_file(ctx, &cert_buf, c.SSL_FILETYPE_PEM) != 1) {
                logging.logDebug("Failed to load server certificate\n", .{});
                return TlsError.CertificateInvalid;
            }
        } else {
            logging.logDebug("Server certificate not provided\n", .{});
            return TlsError.CertificateInvalid;
        }

        // Load server private key (REQUIRED for server mode)
        if (self.config.key_file) |key_file| {
            var key_buf: [512]u8 = undefined;
            if (key_file.len >= key_buf.len) {
                return TlsError.CertificateInvalid;
            }
            @memcpy(key_buf[0..key_file.len], key_file);
            key_buf[key_file.len] = 0;

            if (c.SSL_CTX_use_PrivateKey_file(ctx, &key_buf, c.SSL_FILETYPE_PEM) != 1) {
                logging.logDebug("Failed to load server private key\n", .{});
                return TlsError.CertificateInvalid;
            }
        } else {
            logging.logDebug("Server private key not provided\n", .{});
            return TlsError.CertificateInvalid;
        }

        // Verify that certificate and key match
        if (c.SSL_CTX_check_private_key(ctx) != 1) {
            logging.logDebug("Server certificate and private key do not match\n", .{});
            return TlsError.CertificateInvalid;
        }

        // Configure cipher suites (2025 security best practices - AEAD-only)
        // TLS 1.2 cipher list: Only ECDHE with AEAD ciphers (AES-GCM, ChaCha20-Poly1305)
        // This eliminates CBC ciphers (Lucky13), 3DES (Sweet32), and non-forward-secret ciphers
        const cipher_list = if (self.config.cipher_suites) |cs|
            cs
        else
            "ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256";

        var cipher_buf: [512]u8 = undefined;
        if (cipher_list.len >= cipher_buf.len) {
            return TlsError.HandshakeFailed;
        }
        @memcpy(cipher_buf[0..cipher_list.len], cipher_list);
        cipher_buf[cipher_list.len] = 0;

        if (c.SSL_CTX_set_cipher_list(ctx, &cipher_buf) != 1) {
            logging.logDebug("Failed to set cipher list\n", .{});
            return TlsError.InvalidCipherSuite;
        }

        // Configure TLS 1.3 cipher suites (OpenSSL 1.1.1+)
        // TLS 1.3 only supports AEAD ciphers by design
        const tls13_ciphers = "TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_128_GCM_SHA256";
        var tls13_buf: [256]u8 = undefined;
        if (tls13_ciphers.len >= tls13_buf.len) {
            return TlsError.HandshakeFailed;
        }
        @memcpy(tls13_buf[0..tls13_ciphers.len], tls13_ciphers);
        tls13_buf[tls13_ciphers.len] = 0;

        // SSL_CTX_set_ciphersuites() is for TLS 1.3 only (OpenSSL 1.1.1+)
        if (c.SSL_CTX_set_ciphersuites(ctx, &tls13_buf) != 1) {
            // Non-fatal: might be using older OpenSSL without TLS 1.3 support
            logging.logDebug("Warning: Failed to set TLS 1.3 cipher suites (OpenSSL may not support TLS 1.3)\n", .{});
        }

        // Security hardening: Disable compression (CRIME attack protection)
        const SSL_OP_NO_COMPRESSION: c_long = 0x00020000;
        _ = c.SSL_CTX_set_options(ctx, SSL_OP_NO_COMPRESSION);

        // Security hardening: Disable session tickets (privacy protection)
        const SSL_OP_NO_TICKET: c_long = 0x00004000;
        _ = c.SSL_CTX_set_options(ctx, SSL_OP_NO_TICKET);

        // Security hardening: Prefer server cipher order
        const SSL_OP_CIPHER_SERVER_PREFERENCE: c_long = 0x00400000;
        _ = c.SSL_CTX_set_options(ctx, SSL_OP_CIPHER_SERVER_PREFERENCE);
    }

    /// Convert TlsVersion enum to OpenSSL version constant.
    fn tlsVersionToOpenSsl(self: *OpenSslTls, version: TlsVersion) c_int {
        _ = self;
        return switch (version) {
            .tls_1_0 => c.TLS1_VERSION,
            .tls_1_1 => c.TLS1_1_VERSION,
            .tls_1_2 => c.TLS1_2_VERSION,
            .tls_1_3 => c.TLS1_3_VERSION,
        };
    }

    /// Perform TLS handshake (client or server) with retry logic for non-blocking sockets.
    ///
    /// **Behavior:**
    /// - Retries handshake when socket returns WANT_READ/WANT_WRITE
    /// - Uses poll() with 1-second timeout per retry
    /// - Maximum 30 retries (30 seconds total timeout)
    /// - Returns error on real handshake failures
    fn doHandshake(self: *OpenSslTls) !void {
        const ssl = self.ssl orelse return TlsError.InvalidState;
        self.state = .handshake_in_progress;

        var handshake_complete = false;
        var retry_count: u32 = 0;
        const max_retries: u32 = 30; // 30 seconds total timeout

        while (!handshake_complete and retry_count < max_retries) {
            const ret = if (self.is_client)
                c.SSL_connect(ssl)
            else
                c.SSL_accept(ssl);

            if (ret == 1) {
                // Handshake successful
                handshake_complete = true;
                break;
            }

            const err = c.SSL_get_error(ssl, ret);

            if (err == c.SSL_ERROR_WANT_READ or err == c.SSL_ERROR_WANT_WRITE) {
                // Socket not ready, wait with poll()
                var pollfds = [_]posix.pollfd{.{
                    .fd = self.socket,
                    .events = if (err == c.SSL_ERROR_WANT_READ) posix.POLL.IN else posix.POLL.OUT,
                    .revents = 0,
                }};

                const ready = try posix.poll(&pollfds, 1000); // 1 second timeout
                if (ready == 0) {
                    retry_count += 1;
                    continue; // Timeout, retry
                }

                // Check for socket errors
                if (pollfds[0].revents & (posix.POLL.ERR | posix.POLL.HUP) != 0) {
                    logging.logDebug("Socket error during TLS handshake\n", .{});
                    return TlsError.HandshakeFailed;
                }

                // Socket ready, retry handshake
                continue;
            } else {
                // Real error, not just blocking
                self.logOpenSslError("Handshake failed", err);
                return self.mapOpenSslError(err);
            }
        }

        if (!handshake_complete) {
            logging.logDebug("TLS handshake timeout after {d} retries\n", .{retry_count});
            return TlsError.HandshakeFailed;
        }
    }

    /// Verify hostname matches certificate (client mode only).
    fn verifyHostname(self: *OpenSslTls) !void {
        const ssl = self.ssl orelse return TlsError.InvalidState;

        // Get server name from config
        const server_name = self.config.server_name orelse {
            logging.logDebug("No server_name provided for hostname verification\n", .{});
            return TlsError.HostnameMismatch;
        };

        // Get peer certificate
        const cert = c.SSL_get_peer_certificate(ssl);
        if (cert == null) {
            logging.logDebug("No peer certificate received\n", .{});
            return TlsError.CertificateVerificationFailed;
        }
        defer c.X509_free(cert);

        // Verify hostname using OpenSSL's built-in verification
        var hostname_buf: [256]u8 = undefined;
        if (server_name.len >= hostname_buf.len) {
            return TlsError.HostnameMismatch;
        }
        @memcpy(hostname_buf[0..server_name.len], server_name);
        hostname_buf[server_name.len] = 0;

        const verify_result = c.X509_check_host(
            cert,
            &hostname_buf,
            server_name.len,
            0,
            null,
        );

        if (verify_result != 1) {
            logging.logDebug("Hostname verification failed for: {s}\n", .{server_name});
            return TlsError.HostnameMismatch;
        }
    }

    /// Read decrypted data from TLS connection.
    ///
    /// **Parameters:**
    /// - `buffer`: Destination buffer for plaintext data
    ///
    /// **Returns:**
    /// Number of bytes read (0 indicates clean shutdown by peer).
    ///
    /// **Errors:**
    /// - `error.InvalidState`: Connection not in `.connected` state
    /// - `error.AlertReceived`: Received TLS alert from peer
    /// - `error.WouldBlock`: No data available (non-blocking mode)
    ///
    /// **Blocking Behavior:**
    /// This call blocks until data is available. For non-blocking I/O,
    /// set the underlying socket to non-blocking mode before calling.
    pub fn read(self: *OpenSslTls, buffer: []u8) !usize {
        if (self.state != .connected) {
            return TlsError.InvalidState;
        }

        const ssl = self.ssl orelse return TlsError.InvalidState;
        const result = c.SSL_read(ssl, buffer.ptr, @intCast(buffer.len));

        if (result > 0) {
            return @intCast(result);
        }

        // Handle zero or negative return
        if (result == 0) {
            // Clean shutdown
            return 0;
        }

        // Error occurred
        const err = c.SSL_get_error(ssl, result);
        return self.mapOpenSslError(err);
    }

    /// Write data to TLS connection (will be encrypted before sending).
    ///
    /// **Parameters:**
    /// - `data`: Plaintext data to encrypt and send
    ///
    /// **Returns:**
    /// Number of plaintext bytes written.
    ///
    /// **Errors:**
    /// - `error.InvalidState`: Connection not in `.connected` state
    /// - `error.WouldBlock`: Send buffer full (non-blocking mode)
    ///
    /// **Note:**
    /// The return value indicates how many plaintext bytes were accepted,
    /// not how many encrypted bytes were sent over the wire.
    pub fn write(self: *OpenSslTls, data: []const u8) !usize {
        if (self.state != .connected) {
            return TlsError.InvalidState;
        }

        const ssl = self.ssl orelse return TlsError.InvalidState;
        const result = c.SSL_write(ssl, data.ptr, @intCast(data.len));

        if (result > 0) {
            return @intCast(result);
        }

        // Error occurred
        const err = c.SSL_get_error(ssl, result);
        return self.mapOpenSslError(err);
    }

    /// Close TLS connection gracefully by sending close_notify alert.
    ///
    /// **Behavior:**
    /// - Sends TLS close_notify alert to peer (best-effort)
    /// - Does NOT close the underlying socket
    /// - Does NOT free memory (call `deinit()` separately)
    ///
    /// **Safe to call multiple times:**
    /// Subsequent calls are no-ops.
    pub fn close(self: *OpenSslTls) void {
        if (self.state == .connected) {
            if (self.ssl) |ssl| {
                // Send close_notify (ignore errors, best-effort)
                _ = c.SSL_shutdown(ssl);
            }
            self.state = .closed;
        }
    }

    /// Free all TLS resources.
    ///
    /// **Behavior:**
    /// - Frees SSL object and SSL_CTX
    /// - Does NOT close the underlying socket
    /// - Does NOT send close_notify (call `close()` first if needed)
    ///
    /// **MUST be called** to prevent memory leaks.
    pub fn deinit(self: *OpenSslTls) void {
        if (self.ssl) |ssl| {
            c.SSL_free(ssl);
            self.ssl = null;
        }

        if (self.ssl_ctx) |ctx| {
            c.SSL_CTX_free(ctx);
            self.ssl_ctx = null;
        }
    }

    /// Map OpenSSL error code to TlsError.
    fn mapOpenSslError(self: *OpenSslTls, ssl_error: c_int) TlsError {
        _ = self;
        return switch (ssl_error) {
            c.SSL_ERROR_NONE => TlsError.InvalidState, // Should not reach here
            c.SSL_ERROR_ZERO_RETURN => TlsError.InvalidState, // Clean shutdown (handled separately)
            c.SSL_ERROR_WANT_READ, c.SSL_ERROR_WANT_WRITE => TlsError.WouldBlock, // Non-blocking I/O
            c.SSL_ERROR_SYSCALL => TlsError.AlertReceived,
            c.SSL_ERROR_SSL => TlsError.HandshakeFailed,
            else => TlsError.AlertReceived,
        };
    }

    /// Log OpenSSL error details (verbose mode only).
    fn logOpenSslError(self: *OpenSslTls, context: []const u8, ssl_error: c_int) void {
        _ = self;
        logging.logDebug("{s}: SSL error code {d}\n", .{ context, ssl_error });

        // Print error queue
        var err = c.ERR_get_error();
        while (err != 0) : (err = c.ERR_get_error()) {
            var buf: [256]u8 = undefined;
            c.ERR_error_string_n(err, &buf, buf.len);
            logging.logDebug("  OpenSSL: {s}\n", .{buf});
        }
    }
};

// Unit tests
const testing = std.testing;

test "OpenSslTls initialization" {
    // Basic compile-time test to ensure structure is well-formed
    const tls = OpenSslTls{
        .allocator = testing.allocator,
        .socket = 0,
        .config = .{},
        .ssl_ctx = null,
        .ssl = null,
        .state = .initial,
        .is_client = true,
    };

    try testing.expectEqual(OpenSslTls.ConnectionState.initial, tls.state);
    try testing.expect(tls.is_client);
}

test "TLS version mapping" {
    var tls = OpenSslTls{
        .allocator = testing.allocator,
        .socket = 0,
        .config = .{},
        .ssl_ctx = null,
        .ssl = null,
        .state = .initial,
        .is_client = true,
    };

    const v12 = tls.tlsVersionToOpenSsl(.tls_1_2);
    const v13 = tls.tlsVersionToOpenSsl(.tls_1_3);

    try testing.expectEqual(c.TLS1_2_VERSION, v12);
    try testing.expectEqual(c.TLS1_3_VERSION, v13);
}
</file>

<file path="tls/tls_state.zig">
//! TLS connection state management with atomic thread-safe operations.
//!
//! This module provides state tracking for TLS connections with:
//! - State machine validation to prevent invalid transitions
//! - Atomic operations for thread-safe state updates
//! - State history logging for debugging handshake failures
//! - Integration with existing OpenSSL TLS implementation
//!
//! State Machine:
//! ```
//! uninitialized  handshaking  connected  closed
//!                       
//!                   error_state
//! ```
//!
//! Thread Safety:
//! - Uses std.atomic.Value for lock-free state updates
//! - All transitions validated atomically via compareAndSwap
//! - Safe for concurrent reads and single-writer scenarios

const std = @import("std");
const logging = @import("../util/logging.zig");

/// TLS connection lifecycle states.
///
/// State transitions:
/// - uninitialized: Initial state, no SSL context created
/// - handshaking: TLS handshake in progress (SSL_connect/SSL_accept)
/// - connected: Handshake complete, ready for encrypted I/O
/// - error_state: Irrecoverable error (cert verification failed, etc.)
/// - closed: Connection closed gracefully (close_notify sent)
pub const TlsState = enum(u8) {
    uninitialized = 0,
    handshaking = 1,
    connected = 2,
    error_state = 3,
    closed = 4,

    /// Get human-readable state name for logging.
    pub fn toString(self: TlsState) []const u8 {
        return switch (self) {
            .uninitialized => "uninitialized",
            .handshaking => "handshaking",
            .connected => "connected",
            .error_state => "error",
            .closed => "closed",
        };
    }
};

/// TLS connection state tracker with atomic thread-safe operations.
///
/// **Usage:**
/// ```zig
/// var state_tracker = TlsConnectionState.init();
/// try state_tracker.transition(.uninitialized, .handshaking);
/// // ... perform handshake ...
/// try state_tracker.transition(.handshaking, .connected);
/// ```
///
/// **Thread Safety:**
/// Uses std.atomic.Value for lock-free concurrent access.
/// Safe for multiple readers and single writer pattern.
///
/// **History Tracking:**
/// Maintains last 8 state transitions for debugging.
/// Access via getHistory() for failure analysis.
pub const TlsConnectionState = struct {
    /// Current state (atomic for thread safety)
    current: std.atomic.Value(TlsState),

    /// State transition history (circular buffer, last 8 transitions)
    history: [8]StateTransition,
    history_index: usize,

    /// State transition record for debugging
    const StateTransition = struct {
        from: TlsState,
        to: TlsState,
        timestamp_ns: i128,
    };

    /// Initialize state tracker in uninitialized state.
    pub fn init() TlsConnectionState {
        return .{
            .current = std.atomic.Value(TlsState).init(.uninitialized),
            .history = [_]StateTransition{.{
                .from = .uninitialized,
                .to = .uninitialized,
                .timestamp_ns = 0,
            }} ** 8,
            .history_index = 0,
        };
    }

    /// Get current state (atomic read).
    ///
    /// **Thread Safety:** Safe for concurrent reads.
    pub fn get(self: *const TlsConnectionState) TlsState {
        return self.current.load(.acquire);
    }

    /// Attempt state transition with validation.
    ///
    /// **Parameters:**
    /// - expected: State we expect to transition from
    /// - new_state: State we want to transition to
    ///
    /// **Returns:**
    /// - error.InvalidStateTransition: Current state != expected
    /// - error.StateTransitionFailed: Concurrent modification detected
    ///
    /// **Thread Safety:**
    /// Uses compareAndSwap for atomic validation and update.
    /// Only one transition can succeed if multiple threads attempt.
    ///
    /// **Valid Transitions:**
    /// - uninitialized  handshaking
    /// - handshaking  connected
    /// - handshaking  error_state
    /// - connected  closed
    /// - connected  error_state
    /// - Any state  error_state (emergency fallback)
    pub fn transition(self: *TlsConnectionState, expected: TlsState, new_state: TlsState) !void {
        // Validate transition is allowed
        if (!isValidTransition(expected, new_state)) {
            logging.logDebug("Invalid TLS state transition: {s}  {s}\n", .{
                expected.toString(),
                new_state.toString(),
            });
            return error.InvalidStateTransition;
        }

        // Atomic compare-and-swap to ensure expected state
        const result = self.current.cmpxchgWeak(
            expected,
            new_state,
            .acq_rel, // Success ordering: acquire on read, release on write
            .acquire, // Failure ordering: acquire to read current value
        );

        if (result != null) {
            // Transition failed, state was not as expected
            const actual = result.?;
            logging.logDebug("TLS state transition failed: expected {s}, actual {s}\n", .{
                expected.toString(),
                actual.toString(),
            });
            return error.StateTransitionFailed;
        }

        // Record transition in history
        self.recordTransition(expected, new_state);

        logging.logDebug("TLS state transition: {s}  {s}\n", .{
            expected.toString(),
            new_state.toString(),
        });
    }

    /// Force state change without validation (use with caution).
    ///
    /// **Warning:** Bypasses state machine validation.
    /// Only use for error recovery or initialization.
    ///
    /// **Thread Safety:** Atomic write.
    pub fn set(self: *TlsConnectionState, new_state: TlsState) void {
        const old_state = self.current.swap(new_state, .acq_rel);
        self.recordTransition(old_state, new_state);

        logging.logDebug("TLS state forced: {s}  {s}\n", .{
            old_state.toString(),
            new_state.toString(),
        });
    }

    /// Check if state transition is valid according to state machine.
    fn isValidTransition(from: TlsState, to: TlsState) bool {
        // Allow any state  error_state (emergency fallback)
        if (to == .error_state) {
            return true;
        }

        return switch (from) {
            .uninitialized => to == .handshaking,
            .handshaking => to == .connected or to == .error_state,
            .connected => to == .closed or to == .error_state,
            .error_state => to == .closed, // Allow cleanup after error
            .closed => false, // Terminal state
        };
    }

    /// Record state transition in history buffer (circular).
    fn recordTransition(self: *TlsConnectionState, from: TlsState, to: TlsState) void {
        const index = self.history_index % self.history.len;
        self.history[index] = .{
            .from = from,
            .to = to,
            .timestamp_ns = std.time.nanoTimestamp(),
        };
        self.history_index += 1;
    }

    /// Get state transition history for debugging.
    ///
    /// **Returns:** Slice of recent transitions (up to 8).
    ///
    /// **Usage:**
    /// ```zig
    /// const history = state_tracker.getHistory();
    /// for (history) |transition| {
    ///     logging.logDebug("  {s}  {s} at {d}ns\n", .{
    ///         transition.from.toString(),
    ///         transition.to.toString(),
    ///         transition.timestamp_ns,
    ///     });
    /// }
    /// ```
    pub fn getHistory(self: *const TlsConnectionState) []const StateTransition {
        const count = @min(self.history_index, self.history.len);
        if (count == 0) {
            return &[_]StateTransition{};
        }

        // Return most recent transitions (circular buffer)
        const start = if (self.history_index >= self.history.len)
            (self.history_index % self.history.len)
        else
            0;

        return self.history[start..][0..count];
    }

    /// Log current state and history for debugging.
    pub fn logState(self: *const TlsConnectionState) void {
        const current_state = self.get();
        logging.logDebug("TLS State: {s}\n", .{current_state.toString()});

        const history = self.getHistory();
        if (history.len > 0) {
            logging.logDebug("Recent transitions:\n", .{});
            for (history) |t| {
                logging.logDebug("  {s}  {s} at {d}ns\n", .{
                    t.from.toString(),
                    t.to.toString(),
                    t.timestamp_ns,
                });
            }
        }
    }
};

// Unit tests
const testing = std.testing;

test "TlsState toString" {
    try testing.expectEqualStrings("uninitialized", TlsState.uninitialized.toString());
    try testing.expectEqualStrings("handshaking", TlsState.handshaking.toString());
    try testing.expectEqualStrings("connected", TlsState.connected.toString());
    try testing.expectEqualStrings("error", TlsState.error_state.toString());
    try testing.expectEqualStrings("closed", TlsState.closed.toString());
}

test "TlsConnectionState init" {
    var state = TlsConnectionState.init();
    try testing.expectEqual(TlsState.uninitialized, state.get());
}

test "TlsConnectionState valid transitions" {
    var state = TlsConnectionState.init();

    // Valid: uninitialized  handshaking
    try state.transition(.uninitialized, .handshaking);
    try testing.expectEqual(TlsState.handshaking, state.get());

    // Valid: handshaking  connected
    try state.transition(.handshaking, .connected);
    try testing.expectEqual(TlsState.connected, state.get());

    // Valid: connected  closed
    try state.transition(.connected, .closed);
    try testing.expectEqual(TlsState.closed, state.get());
}

test "TlsConnectionState invalid transition" {
    var state = TlsConnectionState.init();

    // Invalid: uninitialized  connected (skip handshaking)
    const result = state.transition(.uninitialized, .connected);
    try testing.expectError(error.InvalidStateTransition, result);
    try testing.expectEqual(TlsState.uninitialized, state.get());
}

test "TlsConnectionState error state transition" {
    var state = TlsConnectionState.init();

    // Any state  error_state is allowed
    try state.transition(.uninitialized, .error_state);
    try testing.expectEqual(TlsState.error_state, state.get());
}

test "TlsConnectionState concurrent modification" {
    var state = TlsConnectionState.init();

    // Transition to handshaking
    try state.transition(.uninitialized, .handshaking);

    // Try to transition from wrong state (simulates concurrent modification)
    const result = state.transition(.uninitialized, .connected);
    try testing.expectError(error.StateTransitionFailed, result);
    try testing.expectEqual(TlsState.handshaking, state.get());
}

test "TlsConnectionState history tracking" {
    var state = TlsConnectionState.init();

    // Perform some transitions
    try state.transition(.uninitialized, .handshaking);
    try state.transition(.handshaking, .connected);

    const history = state.getHistory();
    try testing.expect(history.len >= 2);
    try testing.expectEqual(TlsState.uninitialized, history[0].from);
    try testing.expectEqual(TlsState.handshaking, history[0].to);
    try testing.expectEqual(TlsState.handshaking, history[1].from);
    try testing.expectEqual(TlsState.connected, history[1].to);
}

test "TlsConnectionState force set" {
    var state = TlsConnectionState.init();

    // Force set to connected (bypasses validation)
    state.set(.connected);
    try testing.expectEqual(TlsState.connected, state.get());

    // Verify history recorded the forced transition
    const history = state.getHistory();
    try testing.expect(history.len > 0);
}
</file>

<file path="tls/tls.zig">
//! TLS interface for secure network connections using OpenSSL.
//!
//! Provides client and server TLS functionality with configuration validation.
//! Requires OpenSSL development libraries and `-Dtls=true` build flag.

pub const TlsConnection = @import("tls_iface.zig").TlsConnection;
pub const TlsConfig = @import("tls_iface.zig").TlsConfig;
pub const TlsVersion = @import("tls_iface.zig").TlsVersion;
pub const TlsError = @import("tls_iface.zig").TlsError;

pub const validateTlsConfig = @import("tls_config.zig").validateTlsConfig;
pub const ValidationMode = @import("tls_config.zig").ValidationMode;
pub const ConfigError = @import("tls_config.zig").ConfigError;
pub const getSecureClientDefaults = @import("tls_config.zig").getSecureClientDefaults;
pub const getSecureServerDefaults = @import("tls_config.zig").getSecureServerDefaults;

const std = @import("std");
const builtin = @import("builtin");
const build_options = @import("build_options");
const OpenSslTls = @import("tls_openssl.zig").OpenSslTls;
const tls_config = @import("tls_config.zig");
const posix = std.posix;
const logging = @import("../util/logging.zig");

/// Create a TLS client connection wrapping an existing socket.
/// Validates configuration before attempting connection.
/// Returns error if TLS was disabled at build time.
pub fn connectTls(
    allocator: std.mem.Allocator,
    socket: posix.socket_t,
    config: TlsConfig,
) !TlsConnection {
    if (!build_options.enable_tls) {
        return TlsConnection{
            .allocator = allocator,
            .backend = .{ .disabled = {} },
        };
    }

    comptime {
        if (!build_options.use_openssl) {
            @compileError(
                \\TLS support requires OpenSSL.
                \\
                \\To fix this:
                \\  1. Install OpenSSL: apt-get install libssl-dev (Debian/Ubuntu)
                \\                      brew install openssl (macOS)
                \\  2. Rebuild with: zig build
                \\
                \\Alternatively, disable TLS: zig build -Dtls=false
            );
        }
    }

    tls_config.validateTlsConfig(config, .client) catch |err| {
        displayTlsConfigError(err, "client");
        switch (err) {
            tls_config.ConfigError.TlsNotEnabled => return TlsError.TlsNotEnabled,
            tls_config.ConfigError.CertificateFileNotFound, tls_config.ConfigError.PrivateKeyFileNotFound, tls_config.ConfigError.TrustFileNotFound, tls_config.ConfigError.CrlFileNotFound => return TlsError.CertificateInvalid,
            tls_config.ConfigError.InvalidCertificateFormat, tls_config.ConfigError.InvalidPrivateKeyFormat, tls_config.ConfigError.CertificateKeyMismatch, tls_config.ConfigError.CertificateExpired, tls_config.ConfigError.CertificateNotYetValid => return TlsError.CertificateInvalid,
            tls_config.ConfigError.ServerNameRequired => return TlsError.HandshakeFailed,
            tls_config.ConfigError.InvalidTlsVersion => return TlsError.ProtocolVersionMismatch,
            tls_config.ConfigError.InsecureCipherSuite => return TlsError.InvalidCipherSuite,
            tls_config.ConfigError.ParameterTooLong => return TlsError.HandshakeFailed,
            tls_config.ConfigError.ServerConfigurationMissing => return TlsError.CertificateInvalid,
        }
    };

    const tls = try OpenSslTls.initClient(allocator, socket, config);
    return TlsConnection{
        .allocator = allocator,
        .backend = .{ .openssl = tls },
    };
}

/// Create a TLS server connection for an accepted client socket.
/// Validates server configuration (cert_file and key_file required).
/// Returns error if TLS was disabled at build time.
pub fn acceptTls(
    allocator: std.mem.Allocator,
    socket: posix.socket_t,
    config: TlsConfig,
) !TlsConnection {
    if (!build_options.enable_tls) {
        return TlsConnection{
            .allocator = allocator,
            .backend = .{ .disabled = {} },
        };
    }

    comptime {
        if (!build_options.use_openssl) {
            @compileError(
                \\TLS support requires OpenSSL.
                \\
                \\To fix this:
                \\  1. Install OpenSSL: apt-get install libssl-dev (Debian/Ubuntu)
                \\                      brew install openssl (macOS)
                \\  2. Rebuild with: zig build
                \\
                \\Alternatively, disable TLS: zig build -Dtls=false
            );
        }
    }

    tls_config.validateTlsConfig(config, .server) catch |err| {
        displayTlsConfigError(err, "server");
        switch (err) {
            tls_config.ConfigError.TlsNotEnabled => return TlsError.TlsNotEnabled,
            tls_config.ConfigError.CertificateFileNotFound, tls_config.ConfigError.PrivateKeyFileNotFound, tls_config.ConfigError.TrustFileNotFound, tls_config.ConfigError.CrlFileNotFound => return TlsError.CertificateInvalid,
            tls_config.ConfigError.InvalidCertificateFormat, tls_config.ConfigError.InvalidPrivateKeyFormat, tls_config.ConfigError.CertificateKeyMismatch, tls_config.ConfigError.CertificateExpired, tls_config.ConfigError.CertificateNotYetValid => return TlsError.CertificateInvalid,
            tls_config.ConfigError.ServerNameRequired => return TlsError.HandshakeFailed,
            tls_config.ConfigError.InvalidTlsVersion => return TlsError.ProtocolVersionMismatch,
            tls_config.ConfigError.InsecureCipherSuite => return TlsError.InvalidCipherSuite,
            tls_config.ConfigError.ParameterTooLong => return TlsError.HandshakeFailed,
            tls_config.ConfigError.ServerConfigurationMissing => return TlsError.CertificateInvalid,
        }
    };

    const tls = try OpenSslTls.initServer(allocator, socket, config);
    return TlsConnection{
        .allocator = allocator,
        .backend = .{ .openssl = tls },
    };
}

/// Check if TLS support is enabled at build time.
pub fn isTlsEnabled() bool {
    return build_options.enable_tls;
}

/// Display error message when TLS is requested but not available at build time.
pub fn displayTlsNotAvailableError() void {
    logging.log(0, "\n", .{});
    logging.log(0, "\n", .{});
    logging.log(0, "    TLS/SSL SUPPORT NOT AVAILABLE                       \n", .{});
    logging.log(0, "                                                           \n", .{});
    logging.log(0, "  TLS support was disabled when this binary was built.    \n", .{});
    logging.log(0, "  To use TLS/SSL features, rebuild with TLS enabled:      \n", .{});
    logging.log(0, "                                                           \n", .{});
    logging.log(0, "    zig build -Dtls=true                                   \n", .{});
    logging.log(0, "                                                           \n", .{});
    logging.log(0, "  Note: This requires OpenSSL development libraries.      \n", .{});
    logging.log(0, "  See build documentation for installation instructions.  \n", .{});
    logging.log(0, "\n", .{});
    logging.log(0, "\n", .{});
}

/// Display error message for TLS configuration validation failures.
pub fn displayTlsConfigError(err: tls_config.ConfigError, context: []const u8) void {
    logging.log(0, "\n", .{});
    logging.log(0, "\n", .{});
    logging.log(0, "    TLS CONFIGURATION ERROR                             \n", .{});
    logging.log(0, "                                                           \n", .{});

    switch (err) {
        tls_config.ConfigError.CertificateFileNotFound => {
            logging.log(0, "  Certificate file not found or not readable.             \n", .{});
            logging.log(0, "                                                           \n", .{});
            logging.log(0, "  Solutions:                                               \n", .{});
            logging.log(0, "   Check the certificate file path is correct            \n", .{});
            logging.log(0, "   Ensure the file exists and is readable                \n", .{});
            logging.log(0, "   Use absolute path if relative path fails              \n", .{});
        },
        tls_config.ConfigError.PrivateKeyFileNotFound => {
            logging.log(0, "  Private key file not found or not readable.             \n", .{});
            logging.log(0, "                                                           \n", .{});
            logging.log(0, "  Solutions:                                               \n", .{});
            logging.log(0, "   Check the private key file path is correct            \n", .{});
            logging.log(0, "   Ensure the file exists and is readable                \n", .{});
            logging.log(0, "   Use absolute path if relative path fails              \n", .{});
        },
        tls_config.ConfigError.InvalidCertificateFormat => {
            logging.log(0, "  Certificate file is not in valid PEM format.            \n", .{});
            logging.log(0, "                                                           \n", .{});
            logging.log(0, "  Solutions:                                               \n", .{});
            logging.log(0, "   Ensure certificate is in PEM format (not DER/P12)    \n", .{});
            logging.log(0, "   Check file contains -----BEGIN CERTIFICATE-----       \n", .{});
            logging.log(0, "   Convert from other formats: openssl x509 -inform ... \n", .{});
        },
        tls_config.ConfigError.InvalidPrivateKeyFormat => {
            logging.log(0, "  Private key file is not in valid PEM format.            \n", .{});
            logging.log(0, "                                                           \n", .{});
            logging.log(0, "  Solutions:                                               \n", .{});
            logging.log(0, "   Ensure key is in PEM format (not DER/P12)             \n", .{});
            logging.log(0, "   Check file contains -----BEGIN PRIVATE KEY-----       \n", .{});
            logging.log(0, "   Convert from other formats: openssl rsa -inform ...   \n", .{});
        },
        tls_config.ConfigError.ServerConfigurationMissing => {
            logging.log(0, "  Server mode requires both certificate and private key.  \n", .{});
            logging.log(0, "                                                           \n", .{});
            logging.log(0, "  Solutions:                                               \n", .{});
            logging.log(0, "   Provide --ssl-cert and --ssl-key options              \n", .{});
            logging.log(0, "   Generate self-signed cert: openssl req -x509 -newkey \n", .{});
            logging.log(0, "    rsa:2048 -keyout key.pem -out cert.pem -days 365      \n", .{});
        },
        tls_config.ConfigError.ServerNameRequired => {
            logging.log(0, "  Server name required for certificate verification.       \n", .{});
            logging.log(0, "                                                           \n", .{});
            logging.log(0, "  Solutions:                                               \n", .{});
            logging.log(0, "   Provide --ssl-servername option                       \n", .{});
            logging.log(0, "   Use --ssl-verify=false to disable verification        \n", .{});
            logging.log(0, "    (NOT recommended for production)                      \n", .{});
        },
        tls_config.ConfigError.InvalidTlsVersion => {
            logging.log(0, "  Invalid TLS version configuration.                       \n", .{});
            logging.log(0, "                                                           \n", .{});
            logging.log(0, "  Solutions:                                               \n", .{});
            logging.log(0, "   Ensure min_version <= max_version                     \n", .{});
            logging.log(0, "   Use TLS 1.2 or higher for security                    \n", .{});
        },
        else => {
            logging.log(0, "  TLS configuration validation failed.                     \n", .{});
            logging.log(0, "                                                           \n", .{});
            logging.log(0, "  Error: {any}                                 \n", .{err});
            logging.log(0, "                                                           \n", .{});
            logging.log(0, "  Check your TLS configuration and try again.             \n", .{});
        },
    }

    logging.log(0, "                                                           \n", .{});
    logging.log(0, "  Context: {s} mode                                    \n", .{context});
    logging.log(0, "\n", .{});
    logging.log(0, "\n", .{});
}
</file>

<file path="util/io_ring_buffer.zig">
//! Ring buffer for non-blocking I/O operations.
//!
//! Provides contiguous slices for reading/writing without additional copying.
//! Designed for use by the exec session poll loop to stage socket and child
//! process data while respecting memory limits.
const std = @import("std");

/// Errors for buffer management
pub const BufferError = error{
    /// Operation exceeded configured capacity
    Overflow,
    /// Buffer capacity must be greater than zero
    InvalidCapacity,
};

/// Ring buffer for non-blocking I/O operations.
///
/// Provides contiguous slices for reading/writing without additional copying.
/// Designed for use by the exec session poll loop to stage socket and child
/// process data while respecting memory limits.
pub const IoRingBuffer = struct {
    allocator: std.mem.Allocator,
    storage: []u8,
    capacity: usize,
    read_index: usize = 0,
    write_index: usize = 0,
    len: usize = 0,
    high_water_mark: usize = 0,
    overflowed: bool = false,

    /// Initialize a ring buffer with specified capacity.
    pub fn init(allocator: std.mem.Allocator, capacity: usize) !IoRingBuffer {
        if (capacity == 0) {
            return BufferError.InvalidCapacity;
        }

        const storage = try allocator.alloc(u8, capacity);
        return .{
            .allocator = allocator,
            .storage = storage,
            .capacity = capacity,
        };
    }

    /// Free storage associated with the ring buffer.
    pub fn deinit(self: *IoRingBuffer) void {
        if (self.storage.len != 0) {
            self.allocator.free(self.storage);
        }
        self.storage = &[_]u8{};
        self.capacity = 0;
        self.read_index = 0;
        self.write_index = 0;
        self.len = 0;
        self.high_water_mark = 0;
        self.overflowed = false;
    }

    /// Number of bytes currently buffered.
    pub fn availableRead(self: *const IoRingBuffer) usize {
        return self.len;
    }

    /// Remaining capacity available for writes.
    pub fn availableWrite(self: *const IoRingBuffer) usize {
        return self.capacity - self.len;
    }

    /// Whether the buffer has recorded an overflow.
    pub fn hasOverflowed(self: *const IoRingBuffer) bool {
        return self.overflowed;
    }

    /// Reset overflow tracking.
    pub fn clearOverflow(self: *IoRingBuffer) void {
        self.overflowed = false;
    }

    /// Obtain first contiguous writable slice.
    pub fn writableSlice(self: *IoRingBuffer) []u8 {
        if (self.len == self.capacity) {
            return self.storage[0..0];
        }

        if (self.write_index >= self.read_index) {
            const tail_space = self.capacity - self.write_index;
            if (tail_space == 0) {
                const max_len = self.read_index;
                return self.storage[0..max_len];
            }
            const max_len = @min(tail_space, self.capacity - self.len);
            return self.storage[self.write_index .. self.write_index + max_len];
        }

        const max_len = self.read_index - self.write_index;
        return self.storage[self.write_index .. self.write_index + max_len];
    }

    /// Commit bytes written into previously obtained writable slice.
    ///
    /// SECURITY: Performs index math in widened (u128) space to avoid overflow.
    /// Guarantees `(write_index + amount) % capacity` semantics even when
    /// capacity exceeds half of the native usize range on 32-bit targets.
    pub fn commitWrite(self: *IoRingBuffer, amount: usize) void {
        if (amount == 0) return;

        if (amount > self.availableWrite()) {
            self.overflowed = true;
            return;
        }

        // SECURITY: Advance index using widened arithmetic to avoid overflow on 32-bit
        self.write_index = advanceIndex(self.write_index, amount, self.capacity);
        self.len += amount;
        if (self.len > self.high_water_mark) {
            self.high_water_mark = self.len;
        }
    }

    /// Obtain first contiguous readable slice.
    pub fn readableSlice(self: *const IoRingBuffer) []const u8 {
        if (self.len == 0) {
            return self.storage[0..0];
        }

        if (self.read_index < self.write_index) {
            return self.storage[self.read_index .. self.read_index + self.len];
        }

        const chunk_len = @min(self.len, self.capacity - self.read_index);
        return self.storage[self.read_index .. self.read_index + chunk_len];
    }

    /// Consume bytes from the buffer after reading.
    ///
    /// SECURITY: Performs index math in widened (u128) space to avoid overflow,
    /// preserving `(read_index + amount) % capacity` semantics on 32-bit targets.
    pub fn consume(self: *IoRingBuffer, amount: usize) void {
        if (amount == 0) return;

        if (amount > self.len) {
            self.len = 0;
            self.read_index = self.write_index;
            return;
        }

        // SECURITY: Advance index using widened arithmetic to avoid overflow on 32-bit
        self.read_index = advanceIndex(self.read_index, amount, self.capacity);
        self.len -= amount;
    }

    /// Copy data into the buffer, returning error if it does not fit.
    pub fn writeAll(self: *IoRingBuffer, data: []const u8) !void {
        if (data.len > self.availableWrite()) {
            self.overflowed = true;
            return BufferError.Overflow;
        }

        var remaining = data;
        while (remaining.len > 0) {
            const span = self.writableSlice();
            const to_copy = @min(span.len, remaining.len);
            std.mem.copyForwards(u8, span[0..to_copy], remaining[0..to_copy]);
            self.commitWrite(to_copy);
            remaining = remaining[to_copy..];
        }
    }

    /// Copy data out of the buffer into destination slice.
    pub fn readInto(self: *IoRingBuffer, dest: []u8) usize {
        var copied: usize = 0;
        var remaining = dest;

        while (remaining.len > 0 and self.len > 0) {
            const span = self.readableSlice();
            if (span.len == 0) break;
            const to_copy = @min(span.len, remaining.len);
            std.mem.copyForwards(u8, remaining[0..to_copy], span[0..to_copy]);
            self.consume(to_copy);
            copied += to_copy;
            remaining = remaining[to_copy..];
        }

        return copied;
    }

    /// Reset buffer contents while retaining allocated storage.
    pub fn reset(self: *IoRingBuffer) void {
        self.read_index = 0;
        self.write_index = 0;
        self.len = 0;
        self.high_water_mark = 0;
        self.overflowed = false;
    }
};

/// Advance an index by `amount` modulo `capacity` without intermediate overflow.
fn advanceIndex(index: usize, amount: usize, capacity: usize) usize {
    std.debug.assert(capacity != 0);
    const widened = @as(u128, index) + @as(u128, amount);
    const wrapped = widened % @as(u128, capacity);
    return @intCast(wrapped);
}

test "IoRingBuffer basic read/write" {
    const allocator = std.testing.allocator;
    var buffer = try IoRingBuffer.init(allocator, 8);
    defer buffer.deinit();

    try buffer.writeAll("abcd");
    try std.testing.expectEqual(@as(usize, 4), buffer.availableRead());
    try std.testing.expectEqualStrings("abcd", buffer.readableSlice());

    var tmp: [2]u8 = undefined;
    const copied = buffer.readInto(&tmp);
    try std.testing.expectEqual(@as(usize, 2), copied);
    try std.testing.expectEqualStrings("ab", tmp[0..2]);

    try buffer.writeAll("efgh");
    try std.testing.expectEqual(@as(usize, 6), buffer.availableRead());

    var out: [6]u8 = undefined;
    const copied2 = buffer.readInto(&out);
    try std.testing.expectEqual(@as(usize, 6), copied2);
    try std.testing.expectEqualStrings("cdefgh", out[0..6]);
    try std.testing.expectEqual(@as(usize, 0), buffer.availableRead());
}

test "IoRingBuffer overflow detection" {
    const allocator = std.testing.allocator;
    var buffer = try IoRingBuffer.init(allocator, 4);
    defer buffer.deinit();

    try buffer.writeAll("abcd");
    try std.testing.expectEqual(@as(usize, 4), buffer.availableRead());

    const result = buffer.writeAll("x");
    try std.testing.expectError(BufferError.Overflow, result);
    try std.testing.expect(buffer.hasOverflowed());
}

test "IoRingBuffer integer overflow protection - commitWrite" {
    const allocator = std.testing.allocator;
    var buffer = try IoRingBuffer.init(allocator, 16);
    defer buffer.deinit();

    // Simulate near-overflow scenario by manually setting write_index
    // to a value close to usize max
    buffer.write_index = std.math.maxInt(usize) - 5;

    // Attempt to commit a write that would overflow with standard addition
    // With +% wrapping addition, this should work correctly
    const slice = buffer.writableSlice();
    if (slice.len > 0) {
        // Write some data
        const to_write = @min(slice.len, 8);
        @memset(slice[0..to_write], 'X');
        buffer.commitWrite(to_write);

        // Buffer should still be in valid state
        // write_index should have wrapped correctly via modulo
        try std.testing.expect(buffer.write_index < buffer.capacity);
        try std.testing.expectEqual(@as(usize, to_write), buffer.availableRead());
    }
}

test "IoRingBuffer integer overflow protection - consume" {
    const allocator = std.testing.allocator;
    var buffer = try IoRingBuffer.init(allocator, 16);
    defer buffer.deinit();

    // Write some data first
    try buffer.writeAll("test data");

    // Simulate near-overflow scenario for read_index
    buffer.read_index = std.math.maxInt(usize) - 5;
    // Adjust write_index to maintain valid buffer state
    buffer.write_index = (buffer.read_index +% buffer.len) % buffer.capacity;

    // Consume bytes - should handle wrapping correctly
    const to_consume = @min(buffer.availableRead(), 4);
    buffer.consume(to_consume);

    // Buffer should still be in valid state
    try std.testing.expect(buffer.read_index < buffer.capacity);
    try std.testing.expectEqual(@as(usize, 9 - to_consume), buffer.availableRead());
}

test "IoRingBuffer wrapping behavior across capacity boundary" {
    const allocator = std.testing.allocator;
    var buffer = try IoRingBuffer.init(allocator, 8);
    defer buffer.deinit();

    // Fill buffer
    try buffer.writeAll("12345678");
    try std.testing.expectEqual(@as(usize, 8), buffer.availableRead());

    // Consume some data to advance read_index
    buffer.consume(5);
    try std.testing.expectEqual(@as(usize, 3), buffer.availableRead());
    try std.testing.expectEqual(@as(usize, 5), buffer.read_index);
    try std.testing.expectEqual(@as(usize, 0), buffer.write_index); // Wrapped to 0

    // Write more data - should wrap write_index correctly
    try buffer.writeAll("ABCDE");
    try std.testing.expectEqual(@as(usize, 8), buffer.availableRead());

    // Verify write_index wrapped correctly
    // With wrapping arithmetic: (0 +% 5) % 8 = 5
    try std.testing.expectEqual(@as(usize, 5), buffer.write_index);

    // Read all data to verify correctness
    var out: [8]u8 = undefined;
    const copied = buffer.readInto(&out);
    try std.testing.expectEqual(@as(usize, 8), copied);
    try std.testing.expectEqualStrings("678ABCDE", out[0..8]);
}
</file>

<file path="util/iocp_windows.zig">
const std = @import("std");
const windows = std.os.windows;

const IOCP_HANDLE = windows.HANDLE;

pub const Iocp = struct {
    handle: IOCP_HANDLE,

    pub fn init() !Iocp {
        const handle = windows.kernel32.CreateIoCompletionPort(
            windows.INVALID_HANDLE_VALUE,
            null,
            0,
            0,
        ) orelse return error.IocpCreateFailed;

        return Iocp{ .handle = handle };
    }

    pub fn deinit(self: *Iocp) void {
        _ = windows.kernel32.CloseHandle(self.handle);
    }

    pub fn associateSocket(self: *Iocp, socket: windows.SOCKET, completion_key: usize) !void {
        const result = windows.kernel32.CreateIoCompletionPort(
            @ptrFromInt(socket),
            self.handle,
            completion_key,
            0,
        );

        if (result == null) {
            return error.IocpAssociateFailed;
        }
    }

    pub fn getStatus(self: *Iocp, timeout: u32) !CompletionPacket {
        var bytes_transferred: u32 = 0;
        var completion_key: usize = 0;
        var overlapped: ?*windows.OVERLAPPED = null;

        const success = windows.kernel32.GetQueuedCompletionStatus(
            self.handle,
            &bytes_transferred,
            &completion_key,
            &overlapped,
            timeout,
        );

        if (success == 0) {
            const err = windows.kernel32.GetLastError();
            if (err == windows.WAIT_TIMEOUT) {
                return error.Timeout;
            }
            return error.IocpGetStatusFailed;
        }

        return CompletionPacket{
            .bytes_transferred = bytes_transferred,
            .completion_key = completion_key,
            .overlapped = overlapped,
        };
    }
};

pub const CompletionPacket = struct {
    bytes_transferred: u32,
    completion_key: usize,
    overlapped: ?*windows.OVERLAPPED,
};
</file>

<file path="util/logging.zig">
//! Verbose output logging system
//!
//! Provides leveled logging for zigcat with runtime verbosity control.
//! Used via -v flag (can be specified multiple times for higher verbosity).
//!
//! Verbosity Levels:
//! - quiet (0): Silent (errors only)
//! - normal (1): Default (connections, warnings)
//! - verbose (2): Connection details (via -v)
//! - debug (3): Protocol details (via -vv)
//! - trace (4): All internal state (via -vvv)
//!
//! Architecture:
//! - Global verbose_level variable controls output filtering
//! - All log functions check level before printing
//! - Errors always print regardless of verbosity
//! - Uses std.debug.print for immediate stderr output
//!
//! Usage:
//! ```zig
//! const cfg = Config{ .verbosity = .verbose };
//! logging.logVerbose(&cfg, "Connected to {s}\n", .{host});  // Level 2
//! logging.logDebug(&cfg, "Data: {x}\n", .{data});  // Level 3
//! logging.logTrace(&cfg, "Protocol state: {}\n", .{state});  // Level 4
//! ```

const std = @import("std");
const config = @import("../config.zig");

/// Global verbosity level (0-4)
/// Modified via setVerbosity(), checked by all log functions
/// Deprecated: Use Config.verbosity instead
var verbose_level: u8 = 0;

/// Set the verbosity level (deprecated)
///
/// Deprecated: Use Config.verbosity instead for type safety
///
/// Controls which log messages are printed to stderr.
///
/// Levels:
/// - 0: Quiet (errors only via logError)
/// - 1: Normal (connections, warnings, transfer stats)
/// - 2: Verbose (connection details)
/// - 3: Debug (protocol details)
/// - 4: Trace (all internal state)
///
/// Parameters:
/// - level: New verbosity level (0-4)
pub fn setVerbosity(level: u8) void {
    verbose_level = level;
}

/// Get current verbosity level (deprecated)
///
/// Deprecated: Use Config.verbosity instead
///
/// Returns: Current global verbosity level
pub fn getVerbosity() u8 {
    return verbose_level;
}

/// Log message at a specific verbosity level
///
/// Generic logging function that checks level before printing.
///
/// Parameters:
/// - level: Required verbosity level for this message (comptime)
/// - fmt: Format string (comptime)
/// - args: Format arguments (tuple of values)
///
/// Note: Only prints if current verbose_level >= level
pub fn log(comptime level: u8, comptime fmt: []const u8, args: anytype) void {
    if (level <= verbose_level) {
        std.debug.print(fmt, args);
    }
}

/// Log connection events (level 1)
///
/// Logs connection accept/close events with IP address.
///
/// Parameters:
/// - address: Client/server network address
/// - action: Event type (e.g., "ACCEPT", "CONNECT", "CLOSE")
///
/// Example output: "[ACCEPT] Connection from 127.0.0.1:54321"
pub fn logConnection(address: std.net.Address, action: []const u8) void {
    if (verbose_level > 0) {
        std.debug.print("[{s}] Connection from {any}\n", .{ action, address });
    }
}

/// Log connection event with custom format (level 1)
///
/// Logs connection events with explicit host:port instead of Address.
///
/// Parameters:
/// - host: Hostname or IP address string
/// - port: Port number
/// - action: Event type (e.g., "CONNECT", "RESOLVE")
///
/// Example output: "[CONNECT] google.com:80"
pub fn logConnectionString(host: []const u8, port: u16, action: []const u8) void {
    if (verbose_level > 0) {
        std.debug.print("[{s}] {s}:{d}\n", .{ action, host, port });
    }
}

/// Log errors (always printed regardless of verbosity)
///
/// Error logging bypasses verbosity check for critical failures.
///
/// Parameters:
/// - err: Error value to display
/// - context: Operation context (e.g., "connect", "bind", "read")
///
/// Example output: "Error in connect: ConnectionRefused"
pub fn logError(err: anyerror, context: []const u8) void {
    std.debug.print("Error in {s}: {}\n", .{ context, err });
}

/// Log warning messages (level 0)
///
/// Warnings are always printed (level 0) for important non-error conditions.
///
/// Parameters:
/// - fmt: Format string (comptime)
/// - args: Format arguments
///
/// Example output: "Warning: TLS verification disabled"
pub fn logWarning(comptime fmt: []const u8, args: anytype) void {
    std.debug.print("Warning: ", .{});
    std.debug.print(fmt, args);
}

/// Log debug messages (level 2+)
///
/// Debug logging for development and troubleshooting.
///
/// Parameters:
/// - fmt: Format string (comptime)
/// - args: Format arguments
///
/// Example output: "[DEBUG] Socket buffer size: 8192"
pub fn logDebug(comptime fmt: []const u8, args: anytype) void {
    if (verbose_level >= 2) {
        std.debug.print("[DEBUG] ", .{});
        std.debug.print(fmt, args);
    }
}

/// Log trace messages (level 3+)
///
/// Detailed tracing for protocol debugging.
///
/// Parameters:
/// - fmt: Format string (comptime)
/// - args: Format arguments
///
/// Example output: "[TRACE] TLS handshake: ClientHello sent"
pub fn logTrace(comptime fmt: []const u8, args: anytype) void {
    if (verbose_level >= 3) {
        std.debug.print("[TRACE] ", .{});
        std.debug.print(fmt, args);
    }
}

/// Log data transfer statistics (level 1)
///
/// Prints summary of bidirectional transfer at completion.
///
/// Parameters:
/// - bytes_sent: Number of bytes sent to remote
/// - bytes_recv: Number of bytes received from remote
///
/// Example output:
/// ```
/// Transfer complete:
///   Sent: 1024 bytes
///   Received: 2048 bytes
/// ```
pub fn logTransferStats(bytes_sent: usize, bytes_recv: usize) void {
    if (verbose_level > 0) {
        std.debug.print("\nTransfer complete:\n", .{});
        std.debug.print("  Sent: {d} bytes\n", .{bytes_sent});
        std.debug.print("  Received: {d} bytes\n", .{bytes_recv});
    }
}

/// Log hex dump of data (level 2+)
///
/// Prints hexadecimal and ASCII representation of binary data.
/// Useful for debugging protocol implementations.
///
/// Format: 16 bytes per line with offset, hex bytes, and ASCII
///
/// Parameters:
/// - data: Binary data to display
/// - label: Description label for the dump
///
/// Example output:
/// ```
/// [TLS Handshake] Hex dump (32 bytes):
/// 0000:  16 03 01 00 1c 01 00 00 18 03 03 00 00 00 00 00  ................
/// 0010:  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
/// ```
pub fn logHexDump(data: []const u8, label: []const u8) void {
    if (verbose_level >= 2) {
        std.debug.print("[{s}] Hex dump ({d} bytes):\n", .{ label, data.len });

        var i: usize = 0;
        while (i < data.len) {
            std.debug.print("{x:0>4}:  ", .{i});

            // Print hex bytes
            var j: usize = 0;
            while (j < 16 and i + j < data.len) : (j += 1) {
                std.debug.print("{x:0>2} ", .{data[i + j]});
            }

            // Padding if last line is incomplete
            while (j < 16) : (j += 1) {
                std.debug.print("   ", .{});
            }

            std.debug.print(" ", .{});

            // Print ASCII representation
            j = 0;
            while (j < 16 and i + j < data.len) : (j += 1) {
                const byte = data[i + j];
                const char = if (byte >= 32 and byte < 127) byte else '.';
                std.debug.print("{c}", .{char});
            }

            std.debug.print("\n", .{});
            i += 16;
        }
    }
}

// =============================================================================
// NEW CONFIG-BASED LOGGING FUNCTIONS (Multi-Level Verbosity)
// =============================================================================

/// Check if a verbosity level is enabled in the configuration
///
/// Helper function for readable verbosity checks.
///
/// Parameters:
/// - cfg: Configuration with verbosity level
/// - level: Minimum level required (comptime constant)
///
/// Returns: true if cfg.verbosity >= level
pub fn isVerbosityEnabled(cfg: *const config.Config, comptime level: config.VerbosityLevel) bool {
    return @intFromEnum(cfg.verbosity) >= @intFromEnum(level);
}

/// Log normal message (level 1 - normal)
///
/// Logs basic connection events, important messages.
/// Prints only if verbosity >= normal (not quiet)
///
/// Parameters:
/// - cfg: Configuration with verbosity level
/// - fmt: Format string (comptime)
/// - args: Format arguments
pub fn logNormal(cfg: *const config.Config, comptime fmt: []const u8, args: anytype) void {
    if (isVerbosityEnabled(cfg, .normal)) {
        std.debug.print(fmt, args);
    }
}

/// Log verbose message (level 2 - verbose)
///
/// Logs connection details, transfer stats, etc.
/// Prints only if verbosity >= verbose (enabled with -v)
///
/// Parameters:
/// - cfg: Configuration with verbosity level
/// - fmt: Format string (comptime)
/// - args: Format arguments
pub fn logVerbose(cfg: *const config.Config, comptime fmt: []const u8, args: anytype) void {
    if (isVerbosityEnabled(cfg, .verbose)) {
        std.debug.print(fmt, args);
    }
}

/// Log debug message (level 3 - debug)
///
/// Logs protocol details, hex dumps, etc.
/// Prints only if verbosity >= debug (enabled with -vv)
///
/// Parameters:
/// - cfg: Configuration with verbosity level
/// - fmt: Format string (comptime)
/// - args: Format arguments
pub fn logDebugCfg(cfg: *const config.Config, comptime fmt: []const u8, args: anytype) void {
    if (isVerbosityEnabled(cfg, .debug)) {
        std.debug.print("[DEBUG] ", .{});
        std.debug.print(fmt, args);
    }
}

/// Log trace message (level 4 - trace)
///
/// Logs all internal state, detailed tracing.
/// Prints only if verbosity >= trace (enabled with -vvv)
///
/// Parameters:
/// - cfg: Configuration with verbosity level
/// - fmt: Format string (comptime)
/// - args: Format arguments
pub fn logTraceCfg(cfg: *const config.Config, comptime fmt: []const u8, args: anytype) void {
    if (isVerbosityEnabled(cfg, .trace)) {
        std.debug.print("[TRACE] ", .{});
        std.debug.print(fmt, args);
    }
}
</file>

<file path="util/path_safety.zig">
//! Path safety helpers used to reject directory traversal sequences.
//!
//! These helpers are intentionally lightweight and perform purely lexical
//! validation so they can be used during argument parsing before any file
//! system interaction occurs.

const std = @import("std");

/// Return true when `path` contains a `..` component that would traverse
/// upwards in the directory tree. Both POSIX (`/`) and Windows (`\`) path
/// separators are treated as delimiters and empty components are ignored.
pub fn hasParentDirectoryTraversal(path: []const u8) bool {
    var it = std.mem.splitAny(u8, path, "/\\");
    while (it.next()) |component| {
        if (component.len == 0) continue;
        if (std.mem.eql(u8, component, ".")) continue;
        if (std.mem.eql(u8, component, "..")) {
            return true;
        }
    }
    return false;
}

/// Basic guard that checks for traversal segments and rejects empty inputs.
/// Returns false if the path is empty or contains parent-directory references.
pub fn isSafePath(path: []const u8) bool {
    if (path.len == 0) return false;
    return !hasParentDirectoryTraversal(path);
}
</file>

<file path="util/platform.zig">
//! Platform detection and capability checking for zigcat.
//!
//! This module provides runtime detection of platform features including:
//! - Linux kernel version parsing
//! - io_uring support detection
//! - Platform-specific capability checks
//!
//! Used to enable/disable features based on platform capabilities.

const std = @import("std");
const builtin = @import("builtin");
const posix = std.posix;

/// Linux kernel version structure
pub const KernelVersion = struct {
    major: u32,
    minor: u32,
    patch: u32,

    /// Check if this version is >= the specified version
    pub fn isAtLeast(self: KernelVersion, major: u32, minor: u32) bool {
        if (self.major > major) return true;
        if (self.major < major) return false;
        return self.minor >= minor;
    }

    /// Format kernel version as string (e.g., "5.10.0")
    pub fn format(
        self: KernelVersion,
        comptime fmt: []const u8,
        options: std.fmt.FormatOptions,
        writer: anytype,
    ) !void {
        _ = fmt;
        _ = options;
        try writer.print("{d}.{d}.{d}", .{ self.major, self.minor, self.patch });
    }
};

/// Parse Linux kernel version from uname release string.
///
/// Handles various distribution formats:
/// - "5.10.0" (vanilla kernel)
/// - "5.10.0-23-generic" (Ubuntu/Debian)
/// - "5.10.0-23.fc35.x86_64" (Fedora)
/// - "5.10.0-arch1-1" (Arch Linux)
///
/// Parameters:
///   release: Release string from uname (e.g., "5.10.0-23-generic")
///
/// Returns: Parsed kernel version or error.InvalidKernelVersion
///
/// Example:
/// ```zig
/// const version = try parseKernelVersion("5.10.0-23-generic");
/// std.debug.print("Kernel: {}\n", .{version}); // "Kernel: 5.10.0"
/// ```
pub fn parseKernelVersion(release: []const u8) !KernelVersion {
    // Find the first dash or end of string to isolate version part
    const version_end = std.mem.indexOf(u8, release, "-") orelse release.len;
    const version_str = release[0..version_end];

    // Split by dots to get major.minor.patch
    var it = std.mem.splitScalar(u8, version_str, '.');

    const major_str = it.next() orelse return error.InvalidKernelVersion;
    const minor_str = it.next() orelse return error.InvalidKernelVersion;
    const patch_str = it.next() orelse "0";

    const major = std.fmt.parseInt(u32, major_str, 10) catch return error.InvalidKernelVersion;
    const minor = std.fmt.parseInt(u32, minor_str, 10) catch return error.InvalidKernelVersion;
    const patch = std.fmt.parseInt(u32, patch_str, 10) catch 0; // Patch is optional

    return KernelVersion{
        .major = major,
        .minor = minor,
        .patch = patch,
    };
}

/// Get current Linux kernel version at runtime.
///
/// Uses std.posix.uname() to query the kernel and parses the release string.
/// Only works on Linux - returns error on other platforms.
///
/// Returns: Current kernel version or error
///
/// Errors:
/// - error.UnsupportedPlatform: Not running on Linux
/// - error.InvalidKernelVersion: Failed to parse version string
///
/// Example:
/// ```zig
/// if (getLinuxKernelVersion()) |version| {
///     std.debug.print("Running kernel {}\n", .{version});
/// } else |err| {
///     std.debug.print("Not on Linux: {}\n", .{err});
/// }
/// ```
pub fn getLinuxKernelVersion() !KernelVersion {
    if (builtin.os.tag != .linux) {
        return error.UnsupportedPlatform;
    }

    var uts: posix.utsname = undefined;
    const result = posix.system.uname(&uts);
    if (result != 0) {
        return error.UnameCallFailed;
    }

    // Extract release string (null-terminated C string)
    const release_len = std.mem.indexOfScalar(u8, &uts.release, 0) orelse uts.release.len;
    const release = uts.release[0..release_len];

    return parseKernelVersion(release);
}

/// Check if io_uring is supported on the current system.
///
/// Requirements for io_uring support:
/// 1. Linux platform (compile-time check)
/// 2. Kernel version >= 5.1 (runtime check)
/// 3. CONFIG_IO_URING enabled in kernel (syscall probe)
///
/// This function performs a lightweight check by attempting to create
/// an io_uring instance. If it succeeds, io_uring is available.
///
/// Returns: true if io_uring is fully supported, false otherwise
///
/// Performance Note:
/// - First call performs syscall probe (~1-2ms overhead)
/// - Result should be cached if called frequently
///
/// Example:
/// ```zig
/// if (isIoUringSupported()) {
///     std.debug.print("io_uring available, using high-performance scanner\n", .{});
/// } else {
///     std.debug.print("io_uring not available, using thread pool\n", .{});
/// }
/// ```
pub fn isIoUringSupported() bool {
    // Compile-time check: Only available on Linux
    if (builtin.os.tag != .linux) {
        return false;
    }

    // Runtime check: Kernel version >= 5.1
    const version = getLinuxKernelVersion() catch return false;
    if (!version.isAtLeast(5, 1)) {
        return false;
    }

    // Syscall probe: Try to create an io_uring instance
    // If the syscall succeeds, CONFIG_IO_URING is enabled
    const IO_Uring = std.os.linux.IO_Uring;

    // Try to initialize with minimal 1-entry ring
    var ring = IO_Uring.init(1, 0) catch {
        // io_uring syscall failed (CONFIG_IO_URING=n or permission denied)
        return false;
    };
    defer ring.deinit();

    // Successfully created io_uring instance
    return true;
}

/// Get a human-readable platform description.
///
/// Returns a string describing the current platform, kernel version,
/// and available features. Useful for verbose logging and debugging.
///
/// Parameters:
///   allocator: Memory allocator for building the string
///
/// Returns: Formatted platform description (caller must free)
///
/// Example output:
/// - "Linux 5.10.0 (io_uring: supported)"
/// - "Linux 4.19.0 (io_uring: not supported - kernel too old)"
/// - "macOS (io_uring: not supported - platform)"
pub fn getPlatformDescription(allocator: std.mem.Allocator) ![]const u8 {
    if (builtin.os.tag == .linux) {
        const version = getLinuxKernelVersion() catch {
            return try std.fmt.allocPrint(allocator, "Linux (version unknown)", .{});
        };

        const uring_status = if (isIoUringSupported())
            "supported"
        else if (version.isAtLeast(5, 1))
            "not supported - CONFIG_IO_URING disabled"
        else
            "not supported - kernel too old (need 5.1+)";

        return try std.fmt.allocPrint(
            allocator,
            "Linux {} (io_uring: {s})",
            .{ version, uring_status },
        );
    } else {
        return try std.fmt.allocPrint(
            allocator,
            "{s} (io_uring: not supported - Linux-only)",
            .{@tagName(builtin.os.tag)},
        );
    }
}
</file>

<file path="util/poll_wrapper.zig">
//! Cross-platform `poll()` abstraction shared by all event loops.
//!
//! ## Platform Implementations
//!
//! - **Unix/Linux/macOS**: Delegates directly to `posix.poll()` - full native semantics
//! - **Windows Vista+**: Uses `WSAPoll()` by default - no connection limit, preferred backend
//! - **Windows (fallback)**: Uses `select()` emulation - limited to ~21 concurrent connections
//!
//! ## Windows Backend Selection
//!
//! The Windows implementation automatically selects the best available backend:
//! 1. **Primary**: WSAPoll (Windows Vista+) - no FD_SETSIZE limitation, handles 1000+ connections
//! 2. **Fallback**: select() - limited to FD_SETSIZE=64, safe for ~21 connections max
//!
//! ## Security Features
//!
//! - **DoS Protection**: FD_SETSIZE overflow detection prevents silent connection failures
//! - **Explicit Errors**: Returns `error.TooManyFileDescriptors` instead of silently dropping connections
//! - **Bounds Checking**: Validates fd_set capacity before adding file descriptors
//!
//! ## Known Limitations (select() backend only)
//!
//! - Limited to ~21 concurrent connections due to FD_SETSIZE=64 constraint
//! - Each connection requires up to 3 fd_set entries (read/write/error sets)
//! - No `POLLPRI` support (out-of-band data)
//! - Replaced by WSAPoll backend on Windows Vista and later
//!
//! ## Usage
//!
//! ```zig
//! const poll_wrapper = @import("util/poll_wrapper.zig");
//! var pollfds = [_]poll_wrapper.pollfd{
//!     .{ .fd = sock, .events = poll_wrapper.POLL.IN, .revents = 0 },
//! };
//! const ready = try poll_wrapper.poll(&pollfds, timeout_ms);
//! ```
//!
//! ## Error Handling
//!
//! - `error.TooManyFileDescriptors`: Too many connections for select() backend (>21 on Windows)
//! - `error.FdSetOverflow`: FD_SET capacity exceeded (internal error)
//! - `error.NetworkDown`: Network subsystem failure (Windows)
//! - `error.InvalidArgument`: Invalid parameters
//! - `error.NoBufferSpace`: System resource exhaustion

const std = @import("std");
const builtin = @import("builtin");
const posix = std.posix;

// Export poll constants
pub const POLL = struct {
    pub const IN: i16 = if (builtin.os.tag == .windows) 0x0001 else posix.POLL.IN;
    pub const OUT: i16 = if (builtin.os.tag == .windows) 0x0004 else posix.POLL.OUT;
    pub const ERR: i16 = if (builtin.os.tag == .windows) 0x0008 else posix.POLL.ERR;
    pub const HUP: i16 = if (builtin.os.tag == .windows) 0x0010 else posix.POLL.HUP;
    pub const NVAL: i16 = if (builtin.os.tag == .windows) 0x0020 else posix.POLL.NVAL;
};

// Cross-platform pollfd structure
pub const pollfd = if (builtin.os.tag == .windows)
    struct {
        fd: posix.socket_t,
        events: i16,
        revents: i16,
    }
else
    posix.pollfd;

// Cross-platform poll() function
pub fn poll(fds: []pollfd, timeout_ms: i32) !usize {
    if (builtin.os.tag == .windows) {
        // Use WSAPoll on Windows Vista+ for better scalability
        // Falls back to select() if WSAPoll is not available
        return pollWindowsWSAPoll(fds, timeout_ms) catch |err| {
            // If WSAPoll fails or is unavailable, try select() backend
            if (err == error.WSAPollNotAvailable or err == error.Unexpected) {
                return pollWindowsSelect(fds, timeout_ms);
            }
            return err;
        };
    } else {
        return posix.poll(fds, timeout_ms);
    }
}

// Windows-specific poll() implementation using WSAPoll (Windows Vista+)
// This is the preferred backend as it has no FD_SETSIZE limitation
fn pollWindowsWSAPoll(fds: []pollfd, timeout_ms: i32) !usize {
    const windows = std.os.windows;
    const ws2_32 = windows.ws2_32;

    // WSAPoll uses the same structure as our pollfd on Windows
    // No conversion needed - we can cast directly
    const result = ws2_32.WSAPoll(
        @ptrCast(fds.ptr),
        @intCast(fds.len),
        timeout_ms,
    );

    if (result == ws2_32.SOCKET_ERROR) {
        const wsa_error = ws2_32.WSAGetLastError();
        return switch (wsa_error) {
            .WSAENETDOWN => error.NetworkDown,
            .WSAEFAULT => error.BadAddress,
            .WSAEINVAL => error.InvalidArgument,
            .WSAENOBUFS => error.NoBufferSpace,
            .WSAEINTR => error.Interrupted,
            else => error.Unexpected,
        };
    }

    return @intCast(result);
}

// Windows-specific poll() implementation using select() (legacy fallback)
// Limited to ~21 clients due to FD_SETSIZE=64 constraint
// Kept for compatibility with older Windows versions or as fallback
fn pollWindowsSelect(fds: []pollfd, timeout_ms: i32) !usize {
    const windows = std.os.windows;
    const ws2_32 = windows.ws2_32;

    // SECURITY: Prevent FD_SETSIZE overflow DoS vulnerability
    // Each pollfd can require up to 3 fd_set entries (read + write + error sets)
    // We need to check worst-case scenario where all fds request both IN and OUT events.
    // FD_SETSIZE is typically 64 on Windows, so we can safely handle ~21 clients max.
    const max_fd_set_entries_needed = fds.len * 3; // Worst case: all fds in all 3 sets
    if (max_fd_set_entries_needed > ws2_32.FD_SETSIZE) {
        // Fail fast with explicit error instead of silently dropping file descriptors
        // This prevents the server from accepting connections it cannot monitor
        return error.TooManyFileDescriptors;
    }

    // Initialize fd_sets
    var read_fds: ws2_32.fd_set = undefined;
    var write_fds: ws2_32.fd_set = undefined;
    var error_fds: ws2_32.fd_set = undefined;

    // Clear all fd_sets
    FD_ZERO(&read_fds);
    FD_ZERO(&write_fds);
    FD_ZERO(&error_fds);

    var max_fd: usize = 0;

    // Add file descriptors to appropriate sets
    for (fds) |*pfd| {
        pfd.revents = 0; // Clear revents

        if (pfd.events & POLL.IN != 0) {
            try FD_SET(pfd.fd, &read_fds);
        }
        if (pfd.events & POLL.OUT != 0) {
            try FD_SET(pfd.fd, &write_fds);
        }
        // Always include the descriptor in the error set so `POLLERR` maps
        // to `select()`'s exceptional condition; callers must keep probing
        // `revents & POLL.ERR` just like they would on POSIX.
        try FD_SET(pfd.fd, &error_fds);

        if (pfd.fd > max_fd) {
            max_fd = pfd.fd;
        }
    }

    // Convert timeout to timeval
    var tv: ws2_32.timeval = undefined;
    const timeout_ptr: ?*ws2_32.timeval = if (timeout_ms < 0)
        null // Infinite timeout, mirroring POSIX poll semantics
    else blk: {
        tv.tv_sec = @intCast(@divFloor(timeout_ms, 1000));
        tv.tv_usec = @intCast(@mod(timeout_ms, 1000) * 1000);
        break :blk &tv;
    };

    // Call select()
    const result = ws2_32.select(
        @intCast(max_fd + 1),
        &read_fds,
        &write_fds,
        &error_fds,
        timeout_ptr,
    );

    if (result == ws2_32.SOCKET_ERROR) {
        return error.SelectFailed;
    }

    if (result == 0) {
        return 0; // Timeout
    }

    // Use a hash map for efficient lookup of revents
    var revents_map = std.HashMap(posix.socket_t, i16).init(std.heap.page_allocator);
    defer revents_map.deinit();

    var i: u32 = 0;
    while (i < read_fds.fd_count) : (i += 1) {
        const fd = read_fds.fd_array[i];
        const entry = try revents_map.getOrPut(fd);
        entry.value_ptr.* |= POLL.IN;
    }

    i = 0;
    while (i < write_fds.fd_count) : (i += 1) {
        const fd = write_fds.fd_array[i];
        const entry = try revents_map.getOrPut(fd);
        entry.value_ptr.* |= POLL.OUT;
    }

    i = 0;
    while (i < error_fds.fd_count) : (i += 1) {
        const fd = error_fds.fd_array[i];
        const entry = try revents_map.getOrPut(fd);
        entry.value_ptr.* |= POLL.ERR;
    }

    // Update revents for each fd
    var ready_count: usize = 0;
    for (fds) |*pfd| {
        if (revents_map.get(pfd.fd)) |revents| {
            pfd.revents = revents;
            ready_count += 1;
        }
    }

    return ready_count;
}

// Windows fd_set helper functions
fn FD_ZERO(set: *std.os.windows.ws2_32.fd_set) void {
    set.fd_count = 0;
}

fn FD_SET(fd: posix.socket_t, set: *std.os.windows.ws2_32.fd_set) !void {
    const ws2_32 = std.os.windows.ws2_32;
    if (set.fd_count >= ws2_32.FD_SETSIZE) {
        // SECURITY: Fail explicitly instead of silently dropping the file descriptor
        // This prevents the DoS condition where connections are accepted but not monitored
        return error.FdSetOverflow;
    }
    set.fd_array[set.fd_count] = fd;
    set.fd_count += 1;
}

fn FD_ISSET(fd: posix.socket_t, set: *const std.os.windows.ws2_32.fd_set) bool {
    var i: u32 = 0;
    while (i < set.fd_count) : (i += 1) {
        if (set.fd_array[i] == fd) {
            return true;
        }
    }
    return false;
}

// Unit tests
test "poll wrapper - timeout on empty set" {
    const testing = std.testing;

    var fds: [0]pollfd = undefined;
    const ready = try poll(&fds, 10); // 10ms timeout
    try testing.expectEqual(@as(usize, 0), ready);
}

test "poll wrapper - POLL constants defined" {
    const testing = std.testing;

    // Verify constants are non-zero
    try testing.expect(POLL.IN != 0);
    try testing.expect(POLL.OUT != 0);
    try testing.expect(POLL.ERR != 0);
    try testing.expect(POLL.HUP != 0);
    try testing.expect(POLL.NVAL != 0);
}

test "poll wrapper - pollfd structure compatibility" {
    const testing = std.testing;

    // Verify we can create pollfd structures
    const pfd = pollfd{
        .fd = @bitCast(@as(i32, -1)),
        .events = POLL.IN,
        .revents = 0,
    };

    try testing.expectEqual(POLL.IN, pfd.events);
    try testing.expectEqual(@as(i16, 0), pfd.revents);
}

test "poll wrapper - invalid fd handling" {
    const testing = std.testing;

    // Create a pollfd with an invalid fd
    const pfd = pollfd{
        .fd = @bitCast(@as(i32, -1)),
        .events = POLL.IN,
        .revents = 0,
    };

    var fds = [_]pollfd{pfd};

    // Should timeout or return immediately depending on platform
    // Both behaviors are acceptable for invalid fd
    const ready = poll(&fds, 10) catch |err| {
        // Error is acceptable for invalid fd
        try testing.expect(err == error.SelectFailed or err == error.Unexpected);
        return;
    };

    // If no error, should timeout (0) or detect invalid fd
    try testing.expect(ready == 0 or fds[0].revents & POLL.NVAL != 0);
}

test "poll wrapper - event flags" {
    const testing = std.testing;

    const pfd = pollfd{
        .fd = @bitCast(@as(i32, -1)),
        .events = POLL.IN | POLL.OUT,
        .revents = 0,
    };

    // Verify we can set multiple event flags
    try testing.expect(pfd.events & POLL.IN != 0);
    try testing.expect(pfd.events & POLL.OUT != 0);
}

test "poll wrapper - FD_SETSIZE overflow protection (Windows)" {
    if (builtin.os.tag != .windows) return error.SkipZigTest;

    const testing = std.testing;

    // Create more pollfds than FD_SETSIZE can handle
    // FD_SETSIZE is typically 64, and each pollfd needs 3 entries (read/write/error)
    // So 22+ pollfds should trigger the overflow protection
    const excessive_fd_count = 25; // 25 * 3 = 75 > 64
    var fds: [excessive_fd_count]pollfd = undefined;

    for (&fds, 0..) |*pfd, i| {
        pfd.* = pollfd{
            .fd = @intCast(i), // Dummy socket FD
            .events = POLL.IN | POLL.OUT, // Request both read and write
            .revents = 0,
        };
    }

    // Attempt to poll with select() backend - should return TooManyFileDescriptors error
    const result = pollWindowsSelect(&fds, 10);
    try testing.expectError(error.TooManyFileDescriptors, result);
}

test "poll wrapper - FD_SET overflow protection (Windows)" {
    if (builtin.os.tag != .windows) return error.SkipZigTest;

    const testing = std.testing;

    var fd_set: std.os.windows.ws2_32.fd_set = undefined;
    FD_ZERO(&fd_set);

    // Fill the fd_set to capacity
    var i: u32 = 0;
    while (i < std.os.windows.ws2_32.FD_SETSIZE) : (i += 1) {
        try FD_SET(@intCast(i), &fd_set);
    }

    // Verify the set is at capacity
    try testing.expectEqual(std.os.windows.ws2_32.FD_SETSIZE, fd_set.fd_count);

    // Attempt to add one more - should return FdSetOverflow error
    const result = FD_SET(@intCast(std.os.windows.ws2_32.FD_SETSIZE), &fd_set);
    try testing.expectError(error.FdSetOverflow, result);

    // Verify fd_count hasn't changed
    try testing.expectEqual(std.os.windows.ws2_32.FD_SETSIZE, fd_set.fd_count);
}

test "poll wrapper - WSAPoll handles many connections (Windows)" {
    if (builtin.os.tag != .windows) return error.SkipZigTest;

    const testing = std.testing;

    // Test that WSAPoll can handle more connections than FD_SETSIZE
    // This test uses dummy FDs, so it won't actually poll real sockets
    // But it verifies that WSAPoll doesn't have the FD_SETSIZE limitation

    const large_fd_count = 100; // Far exceeds FD_SETSIZE (64)
    var fds: [large_fd_count]pollfd = undefined;

    for (&fds, 0..) |*pfd, i| {
        pfd.* = pollfd{
            .fd = @intCast(i), // Dummy socket FD
            .events = POLL.IN,
            .revents = 0,
        };
    }

    // Attempt to poll with WSAPoll backend
    // This should NOT return TooManyFileDescriptors error
    // It may return other errors (like InvalidArgument for dummy FDs), but not FD_SETSIZE-related errors
    const result = pollWindowsWSAPoll(&fds, 0); // 0 timeout for immediate return

    // We expect either:
    // 1. Success (0 ready FDs since these are dummy FDs)
    // 2. An error other than TooManyFileDescriptors
    if (result) |ready_count| {
        // Success - WSAPoll can handle 100+ FDs
        try testing.expectEqual(@as(usize, 0), ready_count);
    } else |err| {
        // Error is OK as long as it's not TooManyFileDescriptors
        try testing.expect(err != error.TooManyFileDescriptors);
    }
}
</file>

<file path="util/portscan.zig">
//! Zero-I/O port scanning (-z flag)
//!
//! Implements fast port scanning by connecting and immediately closing.
//! Does NOT perform any data transfer - success means port is listening.
//!
//! TIMEOUT SAFETY:
//! - All scans use validated timeout (min 10ms, max 60s)
//! - Uses tcp.openTcpClient with explicit timeout_ms parameter
//! - Timeout enforced via poll() in tcp module to prevent hangs
//!
//! Features:
//! - Single port scan: scanPort()
//! - Multiple ports: scanPorts() - sequential
//! - Port range: scanPortRange() - sequential
//! - Parallel port scan: scanPortsParallel() - concurrent
//! - Parallel port range: scanPortRangeParallel() - concurrent
//!
//! Usage:
//! ```zig
//! const is_open = try scanPort(allocator, "192.168.1.1", 80, 5000);
//! try scanPortRange(allocator, "localhost", 8000, 8100, 1000);
//! try scanPortRangeParallel(allocator, "localhost", 1, 1024, 1000, 10); // 10 threads
//! ```
//!
//! Performance:
//! - No data transfer (zero-I/O mode)
//! - Immediate socket close after connection
//! - Parallel scanning with configurable worker threads
//! - 10-100x faster for large port ranges (with parallel mode)

const std = @import("std");
const tcp = @import("../net/tcp.zig");
const socket_mod = @import("../net/socket.zig");
const logging = @import("logging.zig");

/// Scan result for parallel scanning
const ScanResult = struct {
    port: u16,
    is_open: bool,
};

/// Randomize port scanning order (stealth mode).
///
/// Uses Fisher-Yates shuffle algorithm to randomize the order of ports.
/// This helps evade IDS/IPS systems that detect sequential port scans.
///
/// Security Note:
/// - Port randomization reduces detection by signature-based IDS
/// - Does NOT provide complete anonymity or undetectability
/// - Use only for authorized security testing
///
/// Parameters:
///   ports: Array of port numbers to shuffle in-place
///
/// Example:
/// ```zig
/// var ports = [_]u16{ 80, 443, 8080, 3000 };
/// randomizePortOrder(&ports);
/// // ports is now in random order, e.g., [3000, 80, 8080, 443]
/// ```
pub fn randomizePortOrder(ports: []u16) void {
    if (ports.len <= 1) return; // Nothing to shuffle

    // Seed PRNG with current timestamp for randomness
    var prng = std.rand.DefaultPrng.init(@intCast(std.time.nanoTimestamp()));
    const random = prng.random();

    // Fisher-Yates shuffle algorithm
    std.rand.shuffle(random, u16, ports);
}

/// Port range specification (e.g., "80", "1-1024")
pub const PortRange = struct {
    start: u16,
    end: u16,

    /// Parse port specification from string
    ///
    /// Supported formats:
    /// - Single port: "80"  (80, 80)
    /// - Port range: "1-1024"  (1, 1024)
    /// - Inclusive range: "8000-9000"  (8000, 9000)
    ///
    /// Parameters:
    ///   spec: Port specification string
    ///
    /// Returns: PortRange or error.InvalidPortRange
    ///
    /// Example:
    /// ```zig
    /// const range1 = try PortRange.parse("80"); // Single port
    /// const range2 = try PortRange.parse("1-1024"); // Range
    /// ```
    pub fn parse(spec: []const u8) !PortRange {
        // Check for range separator
        if (std.mem.indexOf(u8, spec, "-")) |dash_pos| {
            const start_str = spec[0..dash_pos];
            const end_str = spec[dash_pos + 1 ..];

            const start = try std.fmt.parseInt(u16, start_str, 10);
            const end = try std.fmt.parseInt(u16, end_str, 10);

            if (start > end) {
                return error.InvalidPortRange;
            }

            return PortRange{ .start = start, .end = end };
        } else {
            // Single port
            const port = try std.fmt.parseInt(u16, spec, 10);
            return PortRange{ .start = port, .end = port };
        }
    }

    /// Check if this is a single port (not a range)
    pub fn isSinglePort(self: PortRange) bool {
        return self.start == self.end;
    }

    /// Get the number of ports in this range
    pub fn count(self: PortRange) usize {
        return @as(usize, self.end - self.start + 1);
    }
};

/// Work queue for parallel scanning
const ScanTask = struct {
    host: []const u8,
    port: u16,
    timeout_ms: u32,
};

/// Worker context for parallel scanning
const WorkerContext = struct {
    allocator: std.mem.Allocator,
    tasks: *std.ArrayList(ScanTask),
    results: *std.ArrayList(ScanResult),
    task_index: *std.atomic.Value(usize),
    mutex: *std.Thread.Mutex,
    delay_ms: u32, // Inter-scan delay in milliseconds (stealth mode)
};

/// Zero-I/O mode: connect to port and immediately close
///
/// TIMEOUT SAFETY: Uses validated timeout range (10ms-60s) to prevent hangs.
///
/// Architecture:
/// 1. Validates timeout to safe range (min 10ms, max 60s)
/// 2. Attempts TCP connection via tcp.openTcpClient
/// 3. Immediately closes socket (zero data transfer)
/// 4. Returns true if connection succeeded, false if refused/timeout
///
/// Parameters:
/// - allocator: Memory allocator (unused, kept for API consistency)
/// - host: Target hostname or IP address
/// - port: Target port number
/// - timeout_ms: Connection timeout in milliseconds (validated to 10-60000ms)
///
/// Returns:
/// - true if port is open (connection succeeded)
/// - false if port is closed/filtered (connection refused or timeout)
///
/// Errors:
/// - No errors returned (connection failure = port closed)
///
/// Timeout Validation:
/// - Input timeout clamped to [10ms, 60000ms] range
/// - Prevents instant failures (< 10ms) and indefinite hangs (> 60s)
///
/// Example:
/// ```zig
/// const is_open = try scanPort(allocator, "google.com", 443, 5000);
/// if (is_open) {
///     std.debug.print("Port 443 is open\n", .{});
/// }
/// ```
pub fn scanPort(
    allocator: std.mem.Allocator,
    host: []const u8,
    port: u16,
    timeout_ms: u32,
) !bool {
    _ = allocator;

    // CRITICAL: Ensure timeout is reasonable (min 10ms, max 60s)
    const safe_timeout = @max(10, @min(timeout_ms, 60000));

    const sock = tcp.openTcpClient(host, port, safe_timeout) catch {
        logging.logVerbose(null, "Port {any} closed (connection refused or timeout)\n", .{port});
        return false; // Connection refused or timeout = port closed/unreachable
    };
    defer socket_mod.closeSocket(sock);

    // Port is open if we got here
    logging.logVerbose(null, "Port {any} open\n", .{port});
    return true;
}

/// Scan multiple ports from explicit list
///
/// Scans each port in the provided array sequentially.
/// Prints results to stdout for each port.
///
/// Parameters:
/// - allocator: Memory allocator
/// - host: Target hostname or IP address
/// - ports: Array of port numbers to scan
/// - timeout_ms: Connection timeout per port in milliseconds
///
/// Output format (per port):
/// ```
/// example.com:80 - open
/// example.com:443 - open
/// example.com:8080 - closed
/// ```
///
/// Example:
/// ```zig
/// const ports = [_]u16{ 80, 443, 8080, 3000 };
/// try scanPorts(allocator, "localhost", &ports, 2000);
/// ```
pub fn scanPorts(
    allocator: std.mem.Allocator,
    host: []const u8,
    ports: []const u16,
    timeout_ms: u32,
) !void {
    for (ports) |port| {
        const is_open = try scanPort(allocator, host, port, timeout_ms);
        logging.logVerbose(null, "{s}:{any} - {s}\n", .{
            host,
            port,
            if (is_open) "open" else "closed",
        });
    }
}

/// Scan a range of ports (inclusive)
///
/// Scans all ports from start_port to end_port (inclusive).
/// Only prints results for OPEN ports to reduce output volume.
///
/// Parameters:
/// - allocator: Memory allocator
/// - host: Target hostname or IP address
/// - start_port: First port to scan (inclusive)
/// - end_port: Last port to scan (inclusive)
/// - timeout_ms: Connection timeout per port in milliseconds
///
/// Returns:
/// - error.InvalidPortRange if start_port > end_port
///
/// Output format (open ports only):
/// ```
/// 192.168.1.1:22 - open
/// 192.168.1.1:80 - open
/// 192.168.1.1:443 - open
/// ```
///
/// Performance Note:
/// - Sequential scanning (not parallel)
/// - Large ranges may take significant time
/// - Consider using smaller timeout for faster scans
///
/// Example:
/// ```zig
/// // Scan common web ports
/// try scanPortRange(allocator, "example.com", 80, 8080, 1000);
///
/// // Scan all ports (slow!)
/// try scanPortRange(allocator, "localhost", 1, 65535, 100);
/// ```
pub fn scanPortRange(
    allocator: std.mem.Allocator,
    host: []const u8,
    start_port: u16,
    end_port: u16,
    timeout_ms: u32,
) !void {
    if (start_port > end_port) {
        return error.InvalidPortRange;
    }

    var port = start_port;
    while (port <= end_port) : (port += 1) {
        const is_open = try scanPort(allocator, host, port, timeout_ms);
        if (is_open) {
            logging.logVerbose(null, "{s}:{any} - open\n", .{ host, port });
        }
    }
}

// ============================================================================
// PARALLEL SCANNING IMPLEMENTATION
// ============================================================================

/// Worker thread function for parallel port scanning
///
/// Architecture:
/// 1. Atomically fetch next task index from shared counter
/// 2. Scan port using existing scanPort() function
/// 3. Store result in thread-safe results array
/// 4. Repeat until all tasks completed
///
/// Thread Safety:
/// - Task assignment via atomic counter (lock-free)
/// - Result storage protected by mutex
/// - No shared mutable state between workers
///
/// Parameters:
/// - ctx: Worker context containing tasks, results, and synchronization primitives
fn scanWorker(ctx: WorkerContext) void {
    while (true) {
        // Atomically get next task index
        const task_idx = ctx.task_index.fetchAdd(1, .monotonic);
        if (task_idx >= ctx.tasks.items.len) {
            break; // No more tasks
        }

        const task = ctx.tasks.items[task_idx];

        // Perform scan (uses existing scanPort function)
        const is_open = scanPort(ctx.allocator, task.host, task.port, task.timeout_ms) catch false;

        // Store result (thread-safe)
        ctx.mutex.lock();
        defer ctx.mutex.unlock();
        ctx.results.append(.{
            .port = task.port,
            .is_open = is_open,
        }) catch {
            // Silently ignore append errors (results may be incomplete)
            // Better than crashing the worker thread
        };

        // Apply inter-scan delay if configured (stealth mode)
        if (ctx.delay_ms > 0) {
            std.Thread.sleep(ctx.delay_ms * std.time.ns_per_ms);
        }
    }
}

/// Scan multiple ports in parallel using a thread pool
///
/// Uses a pool of worker threads to scan ports concurrently.
/// Significantly faster than sequential scanning for large port lists.
///
/// Architecture:
/// 1. Create work queue with all ports to scan
/// 2. Spawn worker threads (default: 10)
/// 3. Workers atomically fetch tasks from queue
/// 4. Collect results in thread-safe array
/// 5. Sort results by port number before returning
///
/// Thread Safety:
/// - Lock-free task distribution via atomic counter
/// - Mutex-protected result collection
/// - All threads joined before returning
///
/// Parameters:
/// - allocator: Memory allocator for tasks/results/threads
/// - host: Target hostname or IP address
/// - ports: Array of port numbers to scan
/// - timeout_ms: Connection timeout per port in milliseconds
/// - num_workers: Number of concurrent worker threads (default: 10)
///
/// Returns:
/// - ArrayList of ScanResult sorted by port number
/// - Caller must call deinit() on returned list
///
/// Performance:
/// - ~10x faster than sequential for 100+ ports
/// - Scales well up to ~50 workers (diminishing returns after)
/// - Limited by network bandwidth and target rate limiting
///
/// Example:
/// ```zig
/// const ports = [_]u16{ 80, 443, 8080, 3000, 5432, 6379 };
/// var results = try scanPortsParallel(allocator, "localhost", &ports, 2000, 10);
/// defer results.deinit(allocator);
///
/// for (results.items) |result| {
///     if (result.is_open) {
///         std.debug.print("Port {d} is open\n", .{result.port});
///     }
/// }
/// ```
pub fn scanPortsParallel(
    allocator: std.mem.Allocator,
    host: []const u8,
    ports: []const u16,
    timeout_ms: u32,
    num_workers: usize,
    delay_ms: u32,
) !std.ArrayList(ScanResult) {
    // Validate worker count (min 1, max 100)
    const workers = @max(1, @min(num_workers, 100));

    // Build task list
    var tasks = std.ArrayList(ScanTask).init(allocator);
    defer tasks.deinit(allocator);

    for (ports) |port| {
        try tasks.append(.{
            .host = host,
            .port = port,
            .timeout_ms = timeout_ms,
        });
    }

    // Initialize result collection
    var results = std.ArrayList(ScanResult).init(allocator);
    errdefer results.deinit(allocator);

    // Initialize synchronization primitives
    var task_index = std.atomic.Value(usize).init(0);
    var mutex = std.Thread.Mutex{};

    // Create worker context
    const ctx = WorkerContext{
        .allocator = allocator,
        .tasks = &tasks,
        .results = &results,
        .task_index = &task_index,
        .mutex = &mutex,
        .delay_ms = delay_ms,
    };

    // Spawn worker threads
    var threads = std.ArrayList(std.Thread).init(allocator);
    defer threads.deinit(allocator);

    var i: usize = 0;
    while (i < workers) : (i += 1) {
        const thread = try std.Thread.spawn(.{}, scanWorker, .{ctx});
        try threads.append(thread);
    }

    // Wait for all workers to complete
    for (threads.items) |thread| {
        thread.join();
    }

    // Sort results by port number for consistent output
    std.mem.sort(ScanResult, results.items, {}, struct {
        fn lessThan(_: void, a: ScanResult, b: ScanResult) bool {
            return a.port < b.port;
        }
    }.lessThan);

    return results;
}

/// Scan a range of ports in parallel using a thread pool
///
/// High-performance parallel port range scanning.
/// Uses thread pool to scan multiple ports concurrently.
///
/// Architecture:
/// 1. Builds array of ports in range
/// 2. Delegates to scanPortsParallel()
/// 3. Filters and prints only open ports
///
/// Parameters:
/// - allocator: Memory allocator
/// - host: Target hostname or IP address
/// - start_port: First port to scan (inclusive)
/// - end_port: Last port to scan (inclusive)
/// - timeout_ms: Connection timeout per port in milliseconds
/// - num_workers: Number of concurrent worker threads (default: 10)
///
/// Returns:
/// - error.InvalidPortRange if start_port > end_port
///
/// Output format (open ports only):
/// ```
/// 192.168.1.1:22 - open
/// 192.168.1.1:80 - open
/// 192.168.1.1:443 - open
/// ```
///
/// Performance Comparison (1000 port scan):
/// - Sequential: ~30-60 seconds (depending on timeout)
/// - Parallel (10 workers): ~3-6 seconds
/// - Parallel (50 workers): ~1-2 seconds
///
/// Example:
/// ```zig
/// // Scan common ports with 20 workers (fast!)
/// try scanPortRangeParallel(allocator, "example.com", 1, 1024, 500, 20);
///
/// // Scan all ports with 50 workers (very fast, but aggressive)
/// try scanPortRangeParallel(allocator, "localhost", 1, 65535, 100, 50);
/// ```
pub fn scanPortRangeParallel(
    allocator: std.mem.Allocator,
    host: []const u8,
    start_port: u16,
    end_port: u16,
    timeout_ms: u32,
    num_workers: usize,
) !void {
    if (start_port > end_port) {
        return error.InvalidPortRange;
    }

    // Build port array
    const port_count = @as(usize, @intCast(end_port - start_port + 1));
    const ports = try allocator.alloc(u16, port_count);
    defer allocator.free(ports);

    var port = start_port;
    var idx: usize = 0;
    while (port <= end_port) : (port += 1) {
        ports[idx] = port;
        idx += 1;
    }

    // Scan in parallel
    var results = try scanPortsParallel(allocator, host, ports, timeout_ms, num_workers);
    defer results.deinit(allocator);

    // Print open ports only
    for (results.items) |result| {
        if (result.is_open) {
            logging.logVerbose(null, "{s}:{d} - open\n", .{ host, result.port });
        }
    }
}
</file>

<file path="util/security.zig">
//! Security validation and privilege management
//!
//! This module provides security features for safe network service operation:
//! - Privilege dropping (Unix only) - run as unprivileged user after binding
//! - Exec mode validation - enforce access control for remote command execution
//! - Security event logging - track dangerous operations
//!
//! Key Security Functions:
//! - dropPrivileges() - Drop root privileges to target user (Unix only)
//! - validateExecSecurity() - Ensure exec mode has access control configured
//! - displayExecWarning() - Show operator warning about dangerous exec mode
//! - logSecurityEvent() - Log security-relevant events with client addresses
//!
//! Platform Support:
//! - Unix/Linux: Full privilege dropping with setuid/setgid
//! - Windows: Privilege operations not implemented (logs info message)
//!
//! Usage Pattern:
//! 1. Bind to privileged port (<1024) as root
//! 2. Call dropPrivileges("nobody") to become unprivileged user
//! 3. Validate exec mode with validateExecSecurity() before accepting connections
//! 4. Log all security events with logSecurityEvent()

const std = @import("std");
const builtin = @import("builtin");
const logging = @import("logging.zig");

// Import C functions for group management (not available in std.posix)
const c = @cImport({
    @cInclude("unistd.h");
    @cInclude("grp.h");
    @cInclude("pwd.h");
});

/// Errors that can occur during security operations
pub const SecurityError = error{
    /// Target user not found in common users and not valid UID
    UserNotFound,

    /// Failed to set user ID (setuid syscall failed)
    SetuidFailed,

    /// Failed to set group ID (setgid syscall failed)
    SetgidFailed,

    /// Failed to set supplementary groups (setgroups syscall failed)
    SetgroupsFailed,

    /// Attempted privilege drop without root privileges
    NotRoot,
};

/// Drop privileges after binding to port (Unix only)
///
/// SECURITY CRITICAL: This function irreversibly drops root privileges
/// to run as an unprivileged user. Must be called AFTER binding to
/// privileged ports (<1024) but BEFORE accepting connections.
///
/// Architecture:
/// 1. Check if running as root (euid == 0)
/// 2. Look up target user (e.g., "nobody", "www-data")
/// 3. Clear supplementary groups with setgroups() (prevents retaining wheel/admin)
/// 4. Set primary GID with setgid() (can't change after UID drop)
/// 5. Set UID with setuid() (irreversible - can't regain root)
/// 6. Verify privilege drop succeeded and log final groups
///
/// Platform Support:
/// - Unix/Linux: Full implementation with setuid/setgid
/// - Windows: No-op (logs info message and returns)
///
/// Parameters:
/// - target_user: Username or numeric UID to switch to
///   - Common users: "nobody" (65534), "daemon" (1), "www-data" (33)
///   - Numeric UID: "1000" parsed as UID (primary group resolved via getpwuid)
///
/// Returns:
/// - error.NotRoot if not running as root (euid != 0)
/// - error.UserNotFound if target_user not in common users and not numeric UID
/// - error.SetgroupsFailed if supplementary group clearing fails
/// - error.SetgidFailed if group ID change fails
/// - error.SetuidFailed if user ID change fails or still root after drop
///
/// Security:
/// - Clears supplementary groups first to prevent retaining wheel/admin groups
/// - GID must be changed before UID (UID drop is permanent)
/// - Verifies euid != 0 after drop to confirm privilege loss
/// - Logs before/after UID/GID/groups for complete audit trail
///
/// Example:
/// ```zig
/// // Bind to privileged port while root
/// const sock = try posix.socket(...);
/// try posix.bind(sock, ...);  // Port 80 requires root
///
/// // Drop privileges before accepting connections
/// try dropPrivileges("nobody");  // Now running as nobody:nobody
/// ```
pub fn dropPrivileges(target_user: []const u8) !void {
    if (builtin.os.tag == .windows) {
        logging.log(1, "Privilege dropping not implemented on Windows\n", .{});
        return;
    }

    // Check if we're running as root
    const euid = std.os.linux.geteuid();
    if (euid != 0) {
        logging.log(1, "Not running as root (euid={any}), skipping privilege drop\n", .{euid});
        return;
    }

    logging.log(1, "Running as root, attempting to drop privileges to user '{s}'\n", .{target_user});

    // Look up target user (e.g., "nobody")
    const pw = try getUserInfo(target_user);

    // Drop privileges: clear supplementary groups first, then set GID, then UID
    // Order is critical:
    // 1. setgroups() - Clear supplementary groups (requires root)
    // 2. setgid() - Set primary group (requires root)
    // 3. setuid() - Set user ID (irreversible, must be last)

    // SECURITY: Clear all supplementary groups to prevent retaining privileged
    // groups like "wheel" or "admin" after dropping to an unprivileged user.
    // Calling setgroups with size 0 and a null list is the standard way to do this.
    if (c.setgroups(0, null) != 0) {
        const errno = std.posix.errno(-1);
        std.debug.print("Error: Failed to clear supplementary groups with setgroups(0, null): errno={any}\n", .{errno});
        return SecurityError.SetgroupsFailed;
    }

    // SECURITY FIX (2025-10-10): Use 'try' to propagate errors immediately.
    // Previous catch blocks could theoretically allow partial privilege drop if setgid
    // failed but execution continued. Using 'try' ensures the entire privilege drop
    // operation aborts on any failure, preventing insecure partial drops.
    //
    // CRITICAL: If setgid fails, the process retains privileged group membership.
    // If execution then continued to setuid, we'd have an unprivileged user with
    // privileged group access - a serious security vulnerability.
    try std.posix.setgid(pw.gid);
    try std.posix.setuid(pw.uid);

    // Verify we can't get root back
    const new_euid = std.os.linux.geteuid();
    const new_egid = std.os.linux.getegid();

    // Verify supplementary groups were cleared
    var group_buf: [32]c.gid_t = undefined;
    const ngroups = c.getgroups(group_buf.len, &group_buf);

    logging.log(1, " Privileges dropped successfully:\n", .{});
    logging.log(1, "  User: {s}\n", .{target_user});
    logging.log(1, "  UID:  {any} -> {any}\n", .{ euid, new_euid });
    logging.log(1, "  GID:  {any} -> {any}\n", .{ std.os.linux.getegid(), new_egid });

    // Log supplementary groups for security audit
    if (ngroups > 0) {
        logging.log(1, "  Supplementary groups ({any} total):\n", .{ngroups});
        var i: usize = 0;
        while (i < ngroups) : (i += 1) {
            logging.log(1, "    - GID {any}\n", .{group_buf[i]});
        }
    } else {
        logging.log(1, "  Supplementary groups: (none)\n", .{});
    }

    // Safety check
    if (new_euid == 0) {
        std.debug.print("Error: SECURITY: Still running as root after privilege drop!\n", .{});
        return SecurityError.SetuidFailed;
    }
}

/// User information for privilege dropping
const UserInfo = struct {
    /// User ID (numeric identifier)
    uid: std.posix.uid_t,

    /// Group ID (numeric identifier)
    gid: std.posix.gid_t,

    /// Username (for logging)
    name: []const u8,
};

/// Look up user by name or numeric UID (Unix only)
///
/// Resolves username to UID/GID for privilege dropping.
/// Supports common system users and numeric UID fallback.
/// Numeric fallback resolves the primary group via getpwuid when available.
///
/// Common system users:
/// - "nobody": UID 65534, GID 65534 (unprivileged user)
/// - "daemon": UID 1, GID 1 (system daemon user)
/// - "www-data": UID 33, GID 33 (web server user)
///
/// Parameters:
/// - username: User name or numeric UID string
///
/// Returns:
/// - UserInfo struct with UID/GID/name
/// - error.UserNotFound if name not in common users and not numeric UID
///
/// Example:
/// ```zig
/// const user = try getUserInfo("nobody");  // UID 65534
/// const user2 = try getUserInfo("1000");   // UID 1000 (numeric)
/// ```
fn getUserInfo(username: []const u8) !UserInfo {
    if (builtin.os.tag == .windows) {
        return SecurityError.UserNotFound;
    }

    // Create a null-terminated copy of the username for C compatibility
    var buf: [256]u8 = undefined;
    const new_len = @min(username.len, buf.len - 1);
    @memcpy(buf[0..new_len], username[0..new_len]);
    buf[new_len] = 0;
    const username_z: [*:0]const u8 = @ptrCast(buf[0 .. new_len + 1 :0].ptr);

    // Try to look up the user with getpwnam
    const pwent = c.getpwnam(username_z);

    if (pwent != null) {
        // User found, return their info
        return UserInfo{
            .uid = pwent.*.pw_uid,
            .gid = pwent.*.pw_gid,
            .name = username,
        };
    }

    // If user not found by name, try parsing as a numeric UID
    const uid = std.fmt.parseInt(std.posix.uid_t, username, 10) catch {
        logging.log(1, "Error: User '{s}' not found in system database and not a valid UID\n", .{username});
        return SecurityError.UserNotFound;
    };

    // Numeric UID successfully parsed, attempt to resolve primary group
    const pwuid = c.getpwuid(@intCast(uid));
    if (pwuid != null) {
        return UserInfo{
            .uid = uid,
            .gid = @intCast(pwuid.*.pw_gid),
            .name = username,
        };
    }

    logging.logWarning("Could not resolve primary group for UID {any}; defaulting to GID {any}\n", .{ uid, uid });

    return UserInfo{
        .uid = uid,
        .gid = @intCast(uid), // Fallback: assume GID = UID
        .name = username,
    };
}

/// Log security-relevant event
///
/// Logs security-critical operations for audit trail.
/// Always uses std.log.warn for visibility in production.
///
/// Parameters:
/// - event_type: Event category (e.g., "EXEC", "CONNECT", "DENY")
/// - client_addr: Client IP address involved in event
/// - details: Additional context about the event
///
/// Example:
/// ```zig
/// logSecurityEvent("EXEC", client_addr, "Running /bin/sh");
/// logSecurityEvent("DENY", client_addr, "IP not in allow list");
/// ```
pub fn logSecurityEvent(
    comptime event_type: []const u8,
    client_addr: std.net.Address,
    details: []const u8,
) void {
    logging.logWarning("SECURITY[{s}]: {any} - {s}\n", .{ event_type, client_addr, details });
}

/// Validate that exec mode has proper restrictions
///
/// SECURITY CRITICAL: Ensures exec mode (-e/-c flags) has access control
/// configured to prevent unrestricted remote command execution.
///
/// Security Check:
/// - If require_allow is true AND allow_list_count is 0:
///   - Displays prominent error box to stderr
///   - Returns error.ExecRequiresAllow to abort server startup
///
/// This prevents the dangerous scenario where ANY client can execute
/// the configured program without IP-based access restrictions.
///
/// Parameters:
/// - exec_program: Program path being executed (for error message)
/// - allow_list_count: Number of IPs in allow list (0 = no restrictions)
/// - require_allow: Whether to enforce access control (default: true)
///
/// Returns:
/// - error.ExecRequiresAllow if require_allow && allow_list_count == 0
/// - Success if access control is properly configured
///
/// Example:
/// ```zig
/// // FAILS: No access control
/// validateExecSecurity("/bin/sh", 0, true);  // Error!
///
/// // SUCCEEDS: Access control configured
/// validateExecSecurity("/bin/sh", 3, true);  // 3 allowed IPs
/// ```
pub fn validateExecSecurity(
    exec_program: []const u8,
    allow_list_count: usize,
    require_allow: bool,
) !void {
    if (require_allow and allow_list_count == 0) {
        std.debug.print("\n", .{});
        std.debug.print("\n", .{});
        std.debug.print("    SECURITY ERROR                    \n", .{});
        std.debug.print("  Exec mode requires access control!     \n", .{});
        std.debug.print("  Program: {s:<30}\n", .{exec_program});
        std.debug.print("  NO ACCESS RESTRICTIONS CONFIGURED!     \n", .{});
        std.debug.print("                                          \n", .{});
        std.debug.print("  Any client could execute this program! \n", .{});
        std.debug.print("  Use --allow to restrict access.        \n", .{});
        std.debug.print("\n", .{});
        std.debug.print("\n", .{});
        return error.ExecRequiresAllow;
    }
}

/// Display security warning for exec mode
///
/// Shows prominent boxed warning to operator about dangerous exec mode.
/// Called during server startup to ensure operator awareness.
///
/// Warning content varies based on access control:
/// - If allow_list_count == 0: Emphasizes lack of restrictions
/// - If allow_list_count > 0: Shows number of allowed addresses
///
/// Parameters:
/// - exec_program: Program path being executed (shown in warning)
/// - allow_list_count: Number of IPs in allow list (0 = unrestricted)
///
/// Example output (no restrictions):
/// ```
/// 
///     SECURITY WARNING                  
///   Exec mode (-e) is DANGEROUS!           
///   Program: /bin/sh                       
///   NO ACCESS RESTRICTIONS CONFIGURED!     
///   Any client can execute this program!   
/// 
/// ```
pub fn displayExecWarning(exec_program: []const u8, allow_list_count: usize) void {
    logging.logWarning("\n", .{});
    logging.logWarning("\n", .{});
    logging.logWarning("    SECURITY WARNING                  \n", .{});
    logging.logWarning("  Exec mode (-e) is DANGEROUS!           \n", .{});
    logging.logWarning("  Program: {s:<30}\n", .{exec_program});

    if (allow_list_count == 0) {
        logging.logWarning("  NO ACCESS RESTRICTIONS CONFIGURED!     \n", .{});
        logging.logWarning("  Any client can execute this program!   \n", .{});
    } else {
        logging.logWarning("  Access restricted to {any} addresses       \n", .{allow_list_count});
    }

    logging.logWarning("\n", .{});
    logging.logWarning("\n", .{});
}

/// Validate Unix socket file permissions for security
///
/// SECURITY CRITICAL: Validates that Unix socket files do not have overly
/// permissive file permissions that could allow unauthorized access.
///
/// Security checks:
/// - World-readable/writable permissions (0o007) - HIGH RISK
/// - Group-writable permissions (0o020) - MEDIUM RISK
///
/// This provides defense-in-depth security by catching misconfigured socket
/// files that could allow unintended access even with other access controls.
///
/// Architecture:
/// 1. Stat the socket file to get permissions
/// 2. Extract permission bits (mode & 0o777)
/// 3. Check for world permissions (other: rwx)
/// 4. Check for group-write permission
/// 5. Log warnings with remediation advice
///
/// Platform Support:
/// - Unix/Linux: Full permission checking
/// - Windows: No-op (returns immediately)
///
/// Parameters:
/// - socket_path: Path to Unix socket file to validate
///
/// Returns:
/// - error.FileNotFound if socket file doesn't exist
/// - error.AccessDenied if cannot stat the file
/// - Success after logging any warnings
///
/// Security Impact:
/// - Prevents overly-permissive socket files
/// - Provides operator feedback on risky configurations
/// - Suggests remediation commands (chmod)
///
/// Example:
/// ```zig
/// // After creating Unix socket server
/// const sock_path = "/tmp/myapp.sock";
/// try validateUnixSocketPermissions(sock_path);  // Warns if 0o777
/// ```
pub fn validateUnixSocketPermissions(socket_path: []const u8) !void {
    if (builtin.os.tag == .windows) {
        // Unix sockets not supported on Windows
        return;
    }

    // Stat the socket file to get permissions
    const stat_result = std.fs.cwd().statFile(socket_path) catch |err| {
        // FileNotFound is expected if socket not yet created
        if (err == error.FileNotFound) {
            return err;
        }
        // AccessDenied means we can't validate, but socket exists
        if (err == error.AccessDenied) {
            logging.logWarning("Cannot validate permissions for Unix socket '{s}': Access denied\n", .{socket_path});
            return err;
        }
        return err;
    };

    // Extract permission bits (lower 9 bits: rwxrwxrwx)
    const perms = stat_result.mode & 0o777;

    // Check for world permissions (other: rwx) - HIGH RISK
    const world_perms = perms & 0o007;
    if (world_perms != 0) {
        logging.logWarning("\n", .{});
        logging.logWarning("\n", .{});
        logging.logWarning("    SECURITY WARNING: Unix Socket Permissions           \n", .{});
        logging.logWarning("                                                           \n", .{});
        logging.logWarning("  Socket has WORLD-READABLE/WRITABLE permissions!         \n", .{});
        logging.logWarning("  Path: {s:<50}\n", .{socket_path});
        logging.logWarning("  Permissions: 0o{o:<46}\n", .{perms});
        logging.logWarning("                                                           \n", .{});
        logging.logWarning("  Any user on the system can access this socket!          \n", .{});
        logging.logWarning("  Recommended: chmod 770 {s:<34}\n", .{socket_path});
        logging.logWarning("\n", .{});
        logging.logWarning("\n", .{});
        return;
    }

    // Check for group-writable permission - MEDIUM RISK
    const group_write = perms & 0o020;
    if (group_write != 0) {
        logging.log(1, "Unix socket is group-writable (0o{o}): {s}\n", .{ perms, socket_path });
        logging.log(1, "Consider: chmod 750 {s} (if group access not needed)\n", .{socket_path});
    }
}

test "getUserInfo system user (root)" {
    if (builtin.os.tag == .windows) return error.SkipZigTest;

    const root = try getUserInfo("root");
    try std.testing.expectEqual(@as(u32, 0), root.uid);
    try std.testing.expectEqualStrings("root", root.name);
}

test "getUserInfo numeric UID" {
    if (builtin.os.tag == .windows) return error.SkipZigTest;

    const user = try getUserInfo("1000");
    try std.testing.expectEqual(@as(u32, 1000), user.uid);
}

test "validateExecSecurity requires allow" {
    // Skip this test to avoid log pollution in test output
    // The functionality is validated by checking that error is returned
    // and the security warnings are displayed during integration tests
    return error.SkipZigTest;
}

test "validateExecSecurity allows with restrictions" {
    try validateExecSecurity("/bin/sh", 5, true);
}

test "validateUnixSocketPermissions on nonexistent file" {
    if (builtin.os.tag == .windows) return error.SkipZigTest;

    // Test with nonexistent file
    const result = validateUnixSocketPermissions("/tmp/nonexistent_socket_test_xyz.sock");
    try std.testing.expectError(error.FileNotFound, result);
}

test "validateUnixSocketPermissions on real file" {
    if (builtin.os.tag == .windows) return error.SkipZigTest;

    // Create a temporary file to test with (unique name to avoid conflicts)
    const test_path = "/tmp/zigcat_security_perm_test_unique.sock";

    // Ensure cleanup even if test fails
    defer std.fs.cwd().deleteFile(test_path) catch {};

    // Create the file with specific permissions
    const file = std.fs.cwd().createFile(test_path, .{ .mode = 0o600 }) catch |err| {
        logging.logWarning("Cannot create test file: {any}\n", .{err});
        return error.SkipZigTest;
    };
    file.close();

    // Test validation on file with safe permissions (should pass quietly)
    validateUnixSocketPermissions(test_path) catch |err| {
        logging.logWarning("Validation failed on safe permissions: {any}\n", .{err});
    };

    // Now set world-readable permissions (0o644) - This should trigger warning
    // Open the file and use File.chmod
    const file_to_chmod = std.fs.cwd().openFile(test_path, .{}) catch |err| {
        logging.logWarning("Cannot open test file for chmod: {any}\n", .{err});
        return error.SkipZigTest;
    };
    defer file_to_chmod.close();

    file_to_chmod.chmod(0o644) catch |err| {
        logging.logWarning("Cannot chmod test file: {any}\n", .{err});
        return error.SkipZigTest;
    };

    // Test validation with world-readable permissions (should warn but not error)
    validateUnixSocketPermissions(test_path) catch {};
}
</file>

<file path="util/timeout_tracker.zig">
//! Timeout tracker for managing execution, idle, and connection timeouts.
const std = @import("std");

/// Timeout configuration (milliseconds).
pub const TimeoutConfig = struct {
    /// Maximum total execution time (0 = unlimited)
    execution_ms: u32 = 0,
    /// Maximum idle duration without I/O activity (0 = unlimited)
    idle_ms: u32 = 0,
    /// Deadline for initial connection activity (0 = unlimited)
    connection_ms: u32 = 0,
};

/// Timeout events reported by the tracker.
pub const TimeoutEvent = enum {
    /// No timeout triggered
    none,
    /// Total execution time exceeded
    execution,
    /// Idle timeout triggered
    idle,
    /// Connection timeout triggered
    connection,
};

/// Tracks execution, idle, and connection timeouts for exec sessions.
pub const TimeoutTracker = struct {
    config: TimeoutConfig,
    start_ms: i64,
    last_activity_ms: i64,
    connection_established: bool = false,

    /// Initialize tracker with current timestamp.
    pub fn init(config: TimeoutConfig) TimeoutTracker {
        const now = std.time.milliTimestamp();
        return .{
            .config = config,
            .start_ms = now,
            .last_activity_ms = now,
        };
    }

    /// Mark that I/O activity occurred.
    pub fn markActivity(self: *TimeoutTracker) void {
        const now = std.time.milliTimestamp();
        self.last_activity_ms = now;
        self.connection_established = true;
    }

    /// Mark that connection is fully established without recording activity.
    pub fn markConnectionEstablished(self: *TimeoutTracker) void {
        self.connection_established = true;
        self.last_activity_ms = std.time.milliTimestamp();
    }

    /// Check if any timeout has been reached.
    pub fn check(self: *const TimeoutTracker) TimeoutEvent {
        const now = std.time.milliTimestamp();

        if (self.config.execution_ms > 0) {
            const elapsed = elapsedSince(self.start_ms, now);
            if (elapsed >= self.config.execution_ms) {
                return .execution;
            }
        }

        if (self.config.connection_ms > 0 and !self.connection_established) {
            const elapsed = elapsedSince(self.start_ms, now);
            if (elapsed >= self.config.connection_ms) {
                return .connection;
            }
        }

        if (self.config.idle_ms > 0) {
            const idle_elapsed = elapsedSince(self.last_activity_ms, now);
            if (idle_elapsed >= self.config.idle_ms) {
                return .idle;
            }
        }

        return .none;
    }

    /// Determine poll timeout until next deadline in milliseconds.
    pub fn nextPollTimeout(self: *const TimeoutTracker, base_timeout_ms: ?u32) ?u32 {
        const now = std.time.milliTimestamp();
        var minimum: ?u64 = if (base_timeout_ms) |base| @as(u64, base) else null;

        if (self.config.execution_ms > 0) {
            const elapsed = elapsedSince(self.start_ms, now);
            const remaining = if (elapsed >= self.config.execution_ms)
                0
            else
                @as(u64, self.config.execution_ms - elapsed);
            updateMinimum(&minimum, remaining);
        }

        if (self.config.connection_ms > 0 and !self.connection_established) {
            const elapsed = elapsedSince(self.start_ms, now);
            const remaining = if (elapsed >= self.config.connection_ms)
                0
            else
                @as(u64, self.config.connection_ms - elapsed);
            updateMinimum(&minimum, remaining);
        }

        if (self.config.idle_ms > 0) {
            const elapsed = elapsedSince(self.last_activity_ms, now);
            const remaining = if (elapsed >= self.config.idle_ms)
                0
            else
                @as(u64, self.config.idle_ms - elapsed);
            updateMinimum(&minimum, remaining);
        }

        return @intCast(minimum orelse (base_timeout_ms orelse 0));
    }
};

/// Compute elapsed milliseconds between timestamps, clamping to zero.
fn elapsedSince(start_ms: i64, now_ms: i64) u64 {
    if (now_ms <= start_ms) return 0;
    return @intCast(now_ms - start_ms);
}

/// Update minimum remaining time helper.
fn updateMinimum(current: *?u64, candidate: u64) void {
    if (current.*) |existing| {
        if (candidate < existing) {
            current.* = candidate;
        }
    } else {
        current.* = candidate;
    }
}

test "TimeoutTracker execution timeout" {
    const cfg = TimeoutConfig{
        .execution_ms = 50,
        .idle_ms = 0,
        .connection_ms = 0,
    };
    var tracker = TimeoutTracker.init(cfg);

    // Simulate time passing by sleeping
    std.Thread.sleep(60 * std.time.ns_per_ms);

    const event = tracker.check();
    try std.testing.expect(event == .execution);
}

test "TimeoutTracker idle timeout resets on activity" {
    const cfg = TimeoutConfig{
        .execution_ms = 1000,
        .idle_ms = 50,
        .connection_ms = 0,
    };
    var tracker = TimeoutTracker.init(cfg);

    std.Thread.sleep(30 * std.time.ns_per_ms);
    tracker.markActivity();
    std.Thread.sleep(30 * std.time.ns_per_ms);
    const event = tracker.check();
    try std.testing.expect(event == .none);
}
</file>

<file path="cli.zig">
//! Command-line interface module for zigcat.
//!
//! This module re-exports functions from specialized CLI submodules:
//! - cli/parser.zig: Argument parsing logic
//! - cli/help.zig: Help and version display
//!
//! Maintains backward compatibility by re-exporting all public functions
//! at the top level.

const std = @import("std");
const config = @import("config.zig");

// Re-export parser functions
const parser = @import("cli/parser.zig");
pub const CliError = parser.CliError;
pub const parseArgs = parser.parseArgs;

// Re-export help functions
const help = @import("cli/help.zig");
pub const printHelp = help.printHelp;
pub const printVersion = help.printVersion;
pub const printVersionAll = help.printVersionAll;

// =============================================================================
// TESTS
// =============================================================================

const testing = std.testing;

// =============================================================================
// I/O CONTROL CLI TESTS
// =============================================================================

test "CLI parser - send-only flag" {
    var args = [_][:0]const u8{ "zigcat", "--send-only", "example.com", "80" };

    var cfg = try parseArgs(testing.allocator, &args);
    defer cfg.deinit(testing.allocator);

    try testing.expect(cfg.send_only);
    try testing.expect(!cfg.recv_only);
}

test "CLI parser - recv-only flag" {
    var args = [_][:0]const u8{ "zigcat", "--recv-only", "example.com", "80" };

    var cfg = try parseArgs(testing.allocator, &args);
    defer cfg.deinit(testing.allocator);

    try testing.expect(cfg.recv_only);
    try testing.expect(!cfg.send_only);
}

test "CLI parser - conflicting I/O flags" {
    var args = [_][:0]const u8{ "zigcat", "--send-only", "--recv-only", "example.com", "80" };

    if (parseArgs(testing.allocator, &args)) |_| {
        try testing.expect(false); // Should not reach here
    } else |err| {
        try testing.expectEqual(CliError.ConflictingIOModes, err);
    }
}

test "CLI parser - output file short flag" {
    var args = [_][:0]const u8{ "zigcat", "-o", "/tmp/output.log", "example.com", "80" };

    var cfg = try parseArgs(testing.allocator, &args);
    defer cfg.deinit(testing.allocator);

    try testing.expectEqualStrings("/tmp/output.log", cfg.output_file.?);
    try testing.expect(!cfg.append_output);
}

test "CLI parser - output file long flag" {
    var args = [_][:0]const u8{ "zigcat", "--output", "/tmp/output.log", "example.com", "80" };

    var cfg = try parseArgs(testing.allocator, &args);
    defer cfg.deinit(testing.allocator);

    try testing.expectEqualStrings("/tmp/output.log", cfg.output_file.?);
}

test "CLI parser - append flag with output" {
    var args = [_][:0]const u8{ "zigcat", "-o", "/tmp/output.log", "--append", "example.com", "80" };

    var cfg = try parseArgs(testing.allocator, &args);
    defer cfg.deinit(testing.allocator);

    try testing.expect(cfg.append_output);
    try testing.expectEqualStrings("/tmp/output.log", cfg.output_file.?);
}

test "CLI parser - hex-dump flag without file" {
    var args = [_][:0]const u8{ "zigcat", "-x", "-v", "example.com", "80" };

    var cfg = try parseArgs(testing.allocator, &args);
    defer cfg.deinit(testing.allocator);

    try testing.expect(cfg.hex_dump);
    try testing.expect(cfg.hex_dump_file == null);
}

test "CLI parser - hex-dump flag with file" {
    var args = [_][:0]const u8{ "zigcat", "-x", "/tmp/dump.hex", "example.com", "80" };

    var cfg = try parseArgs(testing.allocator, &args);
    defer cfg.deinit(testing.allocator);

    try testing.expect(cfg.hex_dump);
    try testing.expectEqualStrings("/tmp/dump.hex", cfg.hex_dump_file.?);
}

test "CLI parser - hex-dump long flag with file" {
    var args = [_][:0]const u8{ "zigcat", "--hex-dump", "/tmp/dump.hex", "example.com", "80" };

    var cfg = try parseArgs(testing.allocator, &args);
    defer cfg.deinit(testing.allocator);

    try testing.expect(cfg.hex_dump);
    try testing.expectEqualStrings("/tmp/dump.hex", cfg.hex_dump_file.?);
}

test "CLI parser - invalid output file paths" {
    // Empty output file path
    var args1 = [_][:0]const u8{ "zigcat", "-o", "", "example.com", "80" };
    if (parseArgs(testing.allocator, &args1)) |_| {
        try testing.expect(false); // Should not reach here
    } else |err| {
        try testing.expectEqual(CliError.InvalidOutputPath, err);
    }

    // Empty hex dump file path
    var args2 = [_][:0]const u8{ "zigcat", "-x", "", "example.com", "80" };
    if (parseArgs(testing.allocator, &args2)) |_| {
        try testing.expect(false); // Should not reach here
    } else |err| {
        try testing.expectEqual(CliError.InvalidOutputPath, err);
    }

    // Null bytes in output path
    var args3 = [_][:0]const u8{ "zigcat", "-o", "/tmp/out\x00put.log", "example.com", "80" };
    if (parseArgs(testing.allocator, &args3)) |_| {
        try testing.expect(false); // Should not reach here
    } else |err| {
        try testing.expectEqual(CliError.InvalidOutputPath, err);
    }

    // Null bytes in hex dump path
    var args4 = [_][:0]const u8{ "zigcat", "-x", "/tmp/hex\x00dump.log", "example.com", "80" };
    if (parseArgs(testing.allocator, &args4)) |_| {
        try testing.expect(false); // Should not reach here
    } else |err| {
        try testing.expectEqual(CliError.InvalidOutputPath, err);
    }
}

test "CLI parser - missing values for I/O flags" {
    // Missing output file
    var args1 = [_][:0]const u8{ "zigcat", "-o" };
    try testing.expectError(CliError.MissingValue, parseArgs(testing.allocator, &args1));

    // Missing exec command
    var args2 = [_][:0]const u8{ "zigcat", "-e" };
    try testing.expectError(CliError.MissingValue, parseArgs(testing.allocator, &args2));

    // Missing shell command
    var args3 = [_][:0]const u8{ "zigcat", "-c" };
    try testing.expectError(CliError.MissingValue, parseArgs(testing.allocator, &args3));
}

// Integration test - CLI to Config validation
test "CLI integration - conflicting flags end-to-end" {
    var args = [_][:0]const u8{ "zigcat", "--send-only", "--recv-only", "example.com", "80" };

    // Should fail at CLI parsing level
    if (parseArgs(testing.allocator, &args)) |_| {
        try testing.expect(false); // Should not reach here
    } else |err| {
        try testing.expectEqual(CliError.ConflictingIOModes, err);
    }
}

test "CLI integration - complete I/O control parsing" {
    var args = [_][:0]const u8{ "zigcat", "-o", "/tmp/test.log", "-x", "/tmp/test.hex", "--send-only", "example.com", "80" };

    var cfg = try parseArgs(testing.allocator, &args);
    defer cfg.deinit(testing.allocator);

    // Verify all flags were parsed correctly
    try testing.expectEqualStrings("/tmp/test.log", cfg.output_file.?);
    try testing.expect(cfg.hex_dump);
    try testing.expectEqualStrings("/tmp/test.hex", cfg.hex_dump_file.?);
    try testing.expect(cfg.send_only);
    try testing.expect(!cfg.recv_only);

    // Validate configuration
    try config.validateIOControl(&cfg);
}

// =============================================================================
// BROKER/CHAT MODE CLI TESTS
// =============================================================================

test "CLI parser - broker mode flag" {
    var args = [_][:0]const u8{ "zigcat", "-l", "--broker", "8080" };

    var cfg = try parseArgs(testing.allocator, &args);
    defer cfg.deinit(testing.allocator);

    try testing.expect(cfg.broker_mode);
    try testing.expect(!cfg.chat_mode);
    try testing.expect(cfg.listen_mode);
}

test "CLI parser - chat mode flag" {
    var args = [_][:0]const u8{ "zigcat", "-l", "--chat", "8080" };

    var cfg = try parseArgs(testing.allocator, &args);
    defer cfg.deinit(testing.allocator);

    try testing.expect(cfg.chat_mode);
    try testing.expect(!cfg.broker_mode);
    try testing.expect(cfg.listen_mode);
}

test "CLI parser - conflicting broker and chat flags" {
    var args = [_][:0]const u8{ "zigcat", "-l", "--broker", "--chat", "8080" };

    if (parseArgs(testing.allocator, &args)) |_| {
        try testing.expect(false); // Should not reach here
    } else |err| {
        try testing.expectEqual(CliError.ConflictingIOModes, err);
    }
}

test "CLI parser - max-clients flag" {
    var args = [_][:0]const u8{ "zigcat", "-l", "--broker", "--max-clients", "100", "8080" };

    var cfg = try parseArgs(testing.allocator, &args);
    defer cfg.deinit(testing.allocator);

    try testing.expect(cfg.broker_mode);
    try testing.expectEqual(@as(u32, 100), cfg.max_clients);
}

test "CLI parser - max-clients with chat mode" {
    var args = [_][:0]const u8{ "zigcat", "-l", "--chat", "--max-clients", "25", "8080" };

    var cfg = try parseArgs(testing.allocator, &args);
    defer cfg.deinit(testing.allocator);

    try testing.expect(cfg.chat_mode);
    try testing.expectEqual(@as(u32, 25), cfg.max_clients);
}

test "CLI parser - missing max-clients value" {
    var args = [_][:0]const u8{ "zigcat", "-l", "--broker", "--max-clients" };

    try testing.expectError(CliError.MissingValue, parseArgs(testing.allocator, &args));
}

test "CLI parser - broker mode default values" {
    var args = [_][:0]const u8{ "zigcat", "-l", "--broker", "8080" };

    var cfg = try parseArgs(testing.allocator, &args);
    defer cfg.deinit(testing.allocator);

    try testing.expect(cfg.broker_mode);
    try testing.expectEqual(@as(u32, 50), cfg.max_clients); // Default value
    try testing.expectEqual(@as(usize, 32), cfg.chat_max_nickname_len); // Default value
    try testing.expectEqual(@as(usize, 1024), cfg.chat_max_message_len); // Default value
}

test "CLI parser - chat mode default values" {
    var args = [_][:0]const u8{ "zigcat", "-l", "--chat", "8080" };

    var cfg = try parseArgs(testing.allocator, &args);
    defer cfg.deinit(testing.allocator);

    try testing.expect(cfg.chat_mode);
    try testing.expectEqual(@as(u32, 50), cfg.max_clients); // Default value
    try testing.expectEqual(@as(usize, 32), cfg.chat_max_nickname_len); // Default value
    try testing.expectEqual(@as(usize, 1024), cfg.chat_max_message_len); // Default value
}

test "CLI integration - broker mode with other flags" {
    var args = [_][:0]const u8{ "zigcat", "-l", "-v", "--broker", "--max-clients", "75", "-k", "8080" };

    var cfg = try parseArgs(testing.allocator, &args);
    defer cfg.deinit(testing.allocator);

    try testing.expect(cfg.listen_mode);
    try testing.expect(cfg.verbose);
    try testing.expect(cfg.broker_mode);
    try testing.expect(cfg.keep_listening);
    try testing.expectEqual(@as(u32, 75), cfg.max_clients);
}

test "CLI integration - chat mode with other flags" {
    var args = [_][:0]const u8{ "zigcat", "-l", "-v", "--chat", "--max-clients", "30", "--ssl", "8080" };

    var cfg = try parseArgs(testing.allocator, &args);
    defer cfg.deinit(testing.allocator);

    try testing.expect(cfg.listen_mode);
    try testing.expect(cfg.verbose);
    try testing.expect(cfg.chat_mode);
    try testing.expect(cfg.ssl);
    try testing.expectEqual(@as(u32, 30), cfg.max_clients);
}

// =============================================================================
// UNIX SOCKET CLI TESTS
// =============================================================================

test "CLI parser - Unix socket short flag" {
    var args = [_][:0]const u8{ "zigcat", "-U", "/tmp/test.sock" };

    var cfg = try parseArgs(testing.allocator, &args);
    defer cfg.deinit(testing.allocator);

    try testing.expectEqualStrings("/tmp/test.sock", cfg.unix_socket_path.?);
}

test "CLI parser - Unix socket long flag" {
    var args = [_][:0]const u8{ "zigcat", "--unixsock", "/tmp/test.sock" };

    var cfg = try parseArgs(testing.allocator, &args);
    defer cfg.deinit(testing.allocator);

    try testing.expectEqualStrings("/tmp/test.sock", cfg.unix_socket_path.?);
}

test "CLI parser - Unix socket with listen mode" {
    var args = [_][:0]const u8{ "zigcat", "-l", "-U", "/tmp/server.sock" };

    var cfg = try parseArgs(testing.allocator, &args);
    defer cfg.deinit(testing.allocator);

    try testing.expect(cfg.listen_mode);
    try testing.expectEqualStrings("/tmp/server.sock", cfg.unix_socket_path.?);
}

test "CLI parser - missing Unix socket path" {
    var args = [_][:0]const u8{ "zigcat", "-U" };

    try testing.expectError(CliError.MissingValue, parseArgs(testing.allocator, &args));
}

test "CLI parser - Unix socket conflicts with host/port" {
    var args = [_][:0]const u8{ "zigcat", "-U", "/tmp/test.sock", "example.com", "80" };

    if (parseArgs(testing.allocator, &args)) |_| {
        try testing.expect(false); // Should not reach here on Unix platforms
    } else |err| {
        // On Unix platforms, this should fail with conflicting modes
        // On non-Unix platforms, it should fail with unsupported feature
        try testing.expect(err == CliError.ConflictingIOModes or err == CliError.UnknownOption);
    }
}

test "CLI parser - Unix socket conflicts with UDP" {
    var args = [_][:0]const u8{ "zigcat", "-U", "/tmp/test.sock", "-u" };

    if (parseArgs(testing.allocator, &args)) |_| {
        try testing.expect(false); // Should not reach here on Unix platforms
    } else |err| {
        // On Unix platforms, this should fail with conflicting modes
        // On non-Unix platforms, it should fail with unsupported feature
        try testing.expect(err == CliError.ConflictingIOModes or err == CliError.UnknownOption);
    }
}

test "CLI parser - Unix socket conflicts with TLS" {
    var args = [_][:0]const u8{ "zigcat", "-U", "/tmp/test.sock", "--ssl" };

    if (parseArgs(testing.allocator, &args)) |_| {
        try testing.expect(false); // Should not reach here on Unix platforms
    } else |err| {
        // On Unix platforms, this should fail with conflicting modes
        // On non-Unix platforms, it should fail with unsupported feature
        try testing.expect(err == CliError.ConflictingIOModes or err == CliError.UnknownOption);
    }
}

// =============================================================================
// MULTI-LEVEL VERBOSITY CLI TESTS
// =============================================================================

test "CLI parser - single -v flag (verbose level)" {
    var args = [_][:0]const u8{ "zigcat", "-v", "example.com", "80" };

    var cfg = try parseArgs(testing.allocator, &args);
    defer cfg.deinit(testing.allocator);

    try testing.expectEqual(config.VerbosityLevel.verbose, cfg.verbosity);
    try testing.expect(cfg.verbose); // Backward compatibility
}

test "CLI parser - double -v flag (debug level)" {
    var args = [_][:0]const u8{ "zigcat", "-v", "-v", "example.com", "80" };

    var cfg = try parseArgs(testing.allocator, &args);
    defer cfg.deinit(testing.allocator);

    try testing.expectEqual(config.VerbosityLevel.debug, cfg.verbosity);
}

test "CLI parser - triple -v flag (trace level)" {
    var args = [_][:0]const u8{ "zigcat", "-v", "-v", "-v", "example.com", "80" };

    var cfg = try parseArgs(testing.allocator, &args);
    defer cfg.deinit(testing.allocator);

    try testing.expectEqual(config.VerbosityLevel.trace, cfg.verbosity);
}

test "CLI parser - four -v flags (still trace level)" {
    var args = [_][:0]const u8{ "zigcat", "-v", "-v", "-v", "-v", "example.com", "80" };

    var cfg = try parseArgs(testing.allocator, &args);
    defer cfg.deinit(testing.allocator);

    // Should cap at trace level
    try testing.expectEqual(config.VerbosityLevel.trace, cfg.verbosity);
}

test "CLI parser - quiet flag short form" {
    var args = [_][:0]const u8{ "zigcat", "-q", "example.com", "80" };

    var cfg = try parseArgs(testing.allocator, &args);
    defer cfg.deinit(testing.allocator);

    try testing.expectEqual(config.VerbosityLevel.quiet, cfg.verbosity);
}

test "CLI parser - quiet flag long form" {
    var args = [_][:0]const u8{ "zigcat", "--quiet", "example.com", "80" };

    var cfg = try parseArgs(testing.allocator, &args);
    defer cfg.deinit(testing.allocator);

    try testing.expectEqual(config.VerbosityLevel.quiet, cfg.verbosity);
}

test "CLI parser - default verbosity level" {
    var args = [_][:0]const u8{ "zigcat", "example.com", "80" };

    var cfg = try parseArgs(testing.allocator, &args);
    defer cfg.deinit(testing.allocator);

    try testing.expectEqual(config.VerbosityLevel.normal, cfg.verbosity);
    try testing.expect(!cfg.verbose); // Backward compatibility
}

test "CLI parser - quiet overrides verbose flags" {
    // -q should override any -v flags
    var args = [_][:0]const u8{ "zigcat", "-v", "-v", "-q", "example.com", "80" };

    var cfg = try parseArgs(testing.allocator, &args);
    defer cfg.deinit(testing.allocator);

    // -q is processed after -v flags, so it stays quiet
    try testing.expectEqual(config.VerbosityLevel.quiet, cfg.verbosity);
}

test "CLI parser - verbose with long flag" {
    var args = [_][:0]const u8{ "zigcat", "--verbose", "example.com", "80" };

    var cfg = try parseArgs(testing.allocator, &args);
    defer cfg.deinit(testing.allocator);

    try testing.expectEqual(config.VerbosityLevel.verbose, cfg.verbosity);
}

test "CLI parser - mixed short and long verbose flags" {
    var args = [_][:0]const u8{ "zigcat", "-v", "--verbose", "example.com", "80" };

    var cfg = try parseArgs(testing.allocator, &args);
    defer cfg.deinit(testing.allocator);

    try testing.expectEqual(config.VerbosityLevel.debug, cfg.verbosity);
}

test "CLI parser - verbosity with other flags" {
    var args = [_][:0]const u8{ "zigcat", "-l", "-v", "-v", "-k", "8080" };

    var cfg = try parseArgs(testing.allocator, &args);
    defer cfg.deinit(testing.allocator);

    try testing.expect(cfg.listen_mode);
    try testing.expect(cfg.keep_listening);
    try testing.expectEqual(config.VerbosityLevel.debug, cfg.verbosity);
}
</file>

<file path="client.zig">
//! Client mode implementation for zigcat.
//!
//! This module handles all client-side functionality including:
//! - TCP/UDP connection establishment with timeout
//! - Proxy connections (HTTP CONNECT, SOCKS4/5)
//! - TLS/SSL handshake and encrypted communication
//! - Bidirectional data transfer with I/O control
//! - Zero-I/O mode for port scanning
//! - Command execution (exec mode)
//!
//! Client workflow:
//! 1. Parse target host:port from positional arguments
//! 2. Establish connection (direct or via proxy)
//! 3. Optional TLS handshake
//! 4. Handle zero-I/O mode (connect and close immediately)
//! 5. Execute command (-e flag) or bidirectional transfer
//!
//! Timeout enforcement:
//! - Uses wait_time (-w flag) if set, else connect_timeout
//! - All connections use poll()-based non-blocking I/O
//! - See TIMEOUT_SAFETY.md for timeout patterns

const std = @import("std");
const posix = std.posix;
const config = @import("config.zig");
const net = @import("net/socket.zig");
const tcp = @import("net/tcp.zig");
const udp = @import("net/udp.zig");
const sctp = @import("net/sctp.zig");
const unixsock = @import("net/unixsock.zig");
const tls = @import("tls/tls.zig");
const transfer = @import("io/transfer.zig");
const tls_transfer = @import("io/tls_transfer.zig");
const output = @import("io/output.zig");
const hexdump = @import("io/hexdump.zig");
const proxy = @import("net/proxy/mod.zig");
const logging = @import("util/logging.zig");
const portscan = @import("util/portscan.zig");
const Connection = @import("net/connection.zig").Connection;
const TelnetConnection = @import("protocol/telnet_connection.zig").TelnetConnection;

/// Run client mode - connect to remote host and transfer data.
///
/// Client mode workflow:
/// 1. Parse host and port from positional arguments (or use Unix socket path)
/// 2. Connect to target (direct TCP/UDP, Unix socket, or via proxy)
/// 3. Optional TLS handshake for encryption (not supported with Unix sockets)
/// 4. Handle special modes (zero-I/O, exec)
/// 5. Bidirectional data transfer with logging
///
/// Connection methods (in order of precedence):
/// - Unix socket: Connect to local Unix domain socket
/// - Proxy: Use HTTP CONNECT, SOCKS4, or SOCKS5 proxy
/// - UDP: Create UDP client socket
/// - TCP: Non-blocking connect with poll() timeout
///
/// Timeout behavior:
/// - Uses cfg.wait_time if set via -w flag
/// - Falls back to cfg.connect_timeout (default 30s)
/// - All operations respect timeout for reliability
/// - Unix sockets use same timeout for connection establishment
///
/// Parameters:
///   allocator: Memory allocator for dynamic allocations
///   cfg: Configuration with target, protocol, and connection options
///
/// Returns: Error if connection fails or I/O error occurs
pub fn runClient(allocator: std.mem.Allocator, cfg: *const config.Config) !void {
    // Check for Unix socket mode first
    if (cfg.unix_socket_path) |socket_path| {
        return runUnixSocketClient(allocator, cfg, socket_path);
    }

    // 1. Parse target host:port for TCP/UDP
    if (cfg.positional_args.len < 2) {
        logging.logError(error.MissingArguments, "client mode requires <host> <port> or Unix socket path (-U)");
        return error.MissingArguments;
    }

    const host = cfg.positional_args[0];
    const port_spec = cfg.positional_args[1];

    // Handle zero-I/O mode (port scanning) BEFORE attempting connection
    if (cfg.zero_io) {
        const timeout = if (cfg.wait_time > 0) cfg.wait_time else cfg.connect_timeout;

        // Parse port specification (single port or range)
        const port_range = try portscan.PortRange.parse(port_spec);

        if (port_range.isSinglePort()) {
            // Single port scan
            const is_open = try portscan.scanPort(allocator, host, port_range.start, timeout);
            std.debug.print("{s}:{d} - {s}\n", .{ host, port_range.start, if (is_open) "open" else "closed" });
        } else {
            // Port range scan
            if (cfg.scan_parallel) {
                // Parallel scanning
                if (cfg.verbose) {
                    logging.logVerbose(cfg, "Scanning {s}:{d}-{d} with {d} workers (parallel mode)\n", .{
                        host,
                        port_range.start,
                        port_range.end,
                        cfg.scan_workers,
                    });
                }
                try portscan.scanPortRangeParallel(allocator, host, port_range.start, port_range.end, timeout, cfg.scan_workers);
            } else {
                // Sequential scanning
                if (cfg.verbose) {
                    logging.logVerbose(cfg, "Scanning {s}:{d}-{d} (sequential mode)\n", .{ host, port_range.start, port_range.end });
                }
                try portscan.scanPortRange(allocator, host, port_range.start, port_range.end, timeout);
            }
        }

        // Port scanning complete, exit
        return;
    }

    // For non-scanning modes, parse as single port
    const port = try std.fmt.parseInt(u16, port_spec, 10);

    if (cfg.verbose) {
        logging.logVerbose(cfg, "Client mode configuration:\n", .{});
        logging.logVerbose(cfg, "  Target: {s}:{d}\n", .{ host, port });
        logging.logVerbose(cfg, "  Protocol: {s}\n", .{if (cfg.udp_mode) "UDP" else "TCP"});
        if (cfg.proxy) |proxy_addr| {
            logging.logVerbose(cfg, "  Proxy: {s} (type: {})\n", .{ proxy_addr, cfg.proxy_type });
        }
        if (cfg.ssl) {
            logging.logVerbose(cfg, "  TLS: enabled (verify: {})\n", .{cfg.ssl_verify});
        }
    }

    // 2. Connect to target (direct or via proxy)
    const raw_socket = blk: {
        if (cfg.proxy) |_| {
            // Connect through proxy
            if (cfg.verbose) {
                logging.logVerbose(cfg, "Connecting via proxy...\n", .{});
            }
            break :blk try proxy.connectThroughProxy(allocator, cfg, host, port);
        } else {
            // Direct connection
            if (cfg.verbose) {
                logging.logVerbose(cfg, "Connecting to {s}:{d}...\n", .{ host, port });
            }

            if (cfg.udp_mode) {
                break :blk try udp.openUdpClient(host, port);
            } else if (cfg.sctp_mode) {
                const timeout = if (cfg.wait_time > 0) cfg.wait_time else cfg.connect_timeout;
                break :blk try sctp.openSctpClient(host, port, timeout);
            } else {
                // Use wait_time if set via -w, otherwise fall back to connect_timeout default
                const timeout = if (cfg.wait_time > 0) cfg.wait_time else cfg.connect_timeout;

                // Handle --keep-source-port flag
                if (cfg.keep_source_port) {
                    const src_port = cfg.source_port orelse 0;
                    break :blk try tcp.openTcpClientWithSourcePort(host, port, timeout, src_port);
                } else {
                    break :blk try tcp.openTcpClient(host, port, timeout);
                }
            }
        }
    };

    // Ensure socket is cleaned up on error
    errdefer net.closeSocket(raw_socket);

    if (cfg.verbose) {
        logging.logVerbose(cfg, "Connection established.\n", .{});
    }

    // 3. Optional TLS handshake (not supported for UDP)
    var tls_connection: ?tls.TlsConnection = null;
    defer if (tls_connection) |*conn| conn.deinit();

    if (cfg.ssl and !cfg.udp_mode) {
        // Security warning if certificate verification is disabled
        if (!cfg.ssl_verify) {
            logging.logWarn("  SSL certificate verification is DISABLED. Connection is NOT secure!", .{});
            logging.logWarn("  Use --ssl-verify to enable certificate validation.", .{});
        }

        if (cfg.verbose) {
            logging.logVerbose(cfg, "Starting TLS handshake...\n", .{});
        }

        const tls_config = tls.TlsConfig{
            .verify_peer = cfg.ssl_verify,
            .server_name = cfg.ssl_servername orelse host,
            .trust_file = cfg.ssl_trustfile,
            .crl_file = cfg.ssl_crl,
            .alpn_protocols = cfg.ssl_alpn,
            .cipher_suites = cfg.ssl_ciphers,
        };

        tls_connection = try tls.connectTls(allocator, raw_socket, tls_config);

        if (cfg.verbose) {
            logging.logVerbose(cfg, "TLS handshake complete.\n", .{});
        }
    } else if (cfg.ssl and cfg.udp_mode) {
        logging.logWarn("TLS not supported with UDP, continuing without encryption", .{});
    }

    // 4. Execute command if specified
    if (cfg.exec_command) |cmd| {
        defer {
            if (tls_connection) |*conn| {
                conn.close();
            }
            net.closeSocket(raw_socket);
        }
        try executeCommand(allocator, raw_socket, cmd, cfg);
        return;
    }

    // 6. Bidirectional data transfer
    defer {
        if (tls_connection) |*conn| {
            conn.close();
        }
        net.closeSocket(raw_socket);
    }

    // Initialize output logger and hex dumper
    var output_logger = try output.OutputLogger.init(allocator, cfg.output_file, cfg.append_output);
    defer output_logger.deinit();

    var hex_dumper = try hexdump.HexDumper.init(allocator, cfg.hex_dump_file);
    defer hex_dumper.deinit();

    // Handle Telnet protocol mode
    if (cfg.telnet) {
        // Create Connection wrapper for the underlying socket/TLS connection
        const connection = if (tls_connection) |*conn|
            Connection.fromTls(conn.*)
        else
            Connection.fromSocket(raw_socket);

        // Wrap with TelnetConnection for protocol processing
        var telnet_conn = try TelnetConnection.init(connection, allocator, null, null, null);
        defer telnet_conn.deinit();

        if (cfg.verbose) {
            logging.logVerbose(cfg, "Telnet protocol mode enabled, performing initial negotiation...\n", .{});
        }

        // Perform initial Telnet negotiation
        try telnet_conn.performInitialNegotiation();

        // Use TelnetConnection for bidirectional transfer
        try transferWithTelnetConnection(allocator, &telnet_conn, cfg, &output_logger, &hex_dumper);
    } else {
        // Standard transfer without Telnet processing
        if (tls_connection) |*conn| {
            try tls_transfer.tlsBidirectionalTransfer(allocator, conn, cfg, &output_logger, &hex_dumper);
        } else {
            const stream = std.net.Stream{ .handle = raw_socket };
            try transfer.bidirectionalTransfer(allocator, stream, cfg, &output_logger, &hex_dumper);
        }
    }
}

/// Print data as hex dump to stdout with ASCII sidebar.
///
/// Format (16 bytes per line):
/// 00000000: 48 65 6c 6c 6f 20 57 6f 72 6c 64 0a             |Hello World.|
///
/// Used as fallback when HexDumper is not available.
///
/// Parameters:
///   data: Binary data to display in hex format
fn printHexDump(cfg: *const config.Config, data: []const u8) void {
    var i: usize = 0;
    while (i < data.len) : (i += 16) {
        logging.logTrace(cfg, "{x:0>8}: ", .{i});

        // Hex bytes
        var j: usize = 0;
        while (j < 16) : (j += 1) {
            if (i + j < data.len) {
                logging.logTrace(cfg, "{x:0>2} ", .{data[i + j]});
            } else {
                logging.logTrace(cfg, "   ", .{});
            }
        }

        logging.logTrace(cfg, " |", .{});

        // ASCII representation
        j = 0;
        while (j < 16 and i + j < data.len) : (j += 1) {
            const c = data[i + j];
            if (c >= 32 and c <= 126) {
                logging.logTrace(cfg, "{c}", .{c});
            } else {
                logging.logTrace(cfg, ".", .{});
            }
        }

        logging.logTrace(cfg, "|\n", .{});
    }
}

/// Execute command with socket connected to stdin/stdout (not yet implemented).
///
/// Planned functionality:
/// - Fork/exec child process with given command
/// - Redirect child stdin/stdout to socket
/// - Bidirectional I/O between socket and child process
/// - Proper signal handling and cleanup
///
/// Security note:
/// - Client-side exec is less dangerous than server-side
/// - Still requires proper command validation
/// - Should sanitize environment variables
///
/// Parameters:
///   allocator: For command parsing and buffer allocation
///   socket: Connected socket to use for child I/O
///   cmd: Command to execute
///   cfg: Configuration for verbose logging and options
fn executeCommand(allocator: std.mem.Allocator, socket: posix.socket_t, cmd: []const u8, cfg: *const config.Config) !void {
    _ = allocator;
    _ = socket;
    _ = cmd;
    _ = cfg;
    logging.logWarning("Command execution not yet implemented\n", .{});
    return error.NotImplemented;
}

/// Run Unix socket client mode - connect to Unix domain socket.
///
/// Unix socket client workflow:
/// 1. Validate Unix socket support on current platform
/// 2. Create Unix socket client and connect to server
/// 3. Handle special modes (zero-I/O, exec)
/// 4. Bidirectional data transfer with logging
///
/// Unix socket specific behavior:
/// - No TLS support (local communication doesn't need encryption)
/// - No proxy support (Unix sockets are local only)
/// - Uses filesystem permissions for access control
/// - Faster than TCP for local communication
/// - No network timeouts, but connection timeout still applies
///
/// Parameters:
///   allocator: Memory allocator for dynamic allocations
///   cfg: Configuration with Unix socket and connection options
///   socket_path: Path to Unix domain socket to connect to
///
/// Returns: Error if connection fails or I/O error occurs
fn runUnixSocketClient(allocator: std.mem.Allocator, cfg: *const config.Config, socket_path: []const u8) !void {
    // 1. Check platform support
    if (!unixsock.unix_socket_supported) {
        logging.logError(error.UnixSocketsNotSupported, "Unix domain sockets are not supported on this platform");
        return error.UnixSocketsNotSupported;
    }

    // 2. Validate configuration conflicts
    if (cfg.ssl) {
        logging.logError(error.InvalidConfiguration, "TLS is not meaningful with Unix domain sockets (local communication)");
        return error.InvalidConfiguration;
    }

    if (cfg.udp_mode) {
        logging.logError(error.InvalidConfiguration, "UDP mode is not supported with Unix domain sockets");
        return error.InvalidConfiguration;
    }

    if (cfg.proxy != null) {
        logging.logError(error.InvalidConfiguration, "Proxy connections are not supported with Unix domain sockets");
        return error.InvalidConfiguration;
    }

    if (cfg.verbose) {
        logging.logVerbose(cfg, "Unix socket client configuration:\n", .{});
        logging.logVerbose(cfg, "  Socket path: {s}\n", .{socket_path});
        if (cfg.exec_command) |cmd| {
            logging.logVerbose(cfg, "  Exec command: {s}\n", .{cmd});
        }
    }

    // 3. Validate socket path
    try unixsock.validatePath(socket_path);

    // 4. Create Unix socket client
    var unix_client = unixsock.UnixSocket.initClient(allocator, socket_path) catch |err| {
        logging.logError(err, "creating Unix socket client");
        logging.logWarning("  Check path format and system resources for: {s}\n", .{socket_path});
        return err;
    };
    defer unix_client.close();

    // 5. Connect to Unix socket server
    if (cfg.verbose) {
        logging.logVerbose(cfg, "Connecting to Unix socket: {s}\n", .{socket_path});
    }

    unix_client.connect() catch |err| {
        switch (err) {
            error.FileNotFound => {
                logging.logError(err, "Unix socket not found");
                logging.logWarning("  Socket path: {s}\n", .{socket_path});
                logging.logWarning("  Make sure the server is running and the path is correct\n", .{});
            },
            error.ConnectionRefused => {
                logging.logError(err, "Connection refused to Unix socket");
                logging.logWarning("  Socket path: {s}\n", .{socket_path});
                logging.logWarning("  The socket exists but no server is listening\n", .{});
            },
            error.PermissionDenied => {
                logging.logError(err, "Permission denied connecting to Unix socket");
                logging.logWarning("  Socket path: {s}\n", .{socket_path});
                logging.logWarning("  Check socket file permissions\n", .{});
            },
            else => {
                logging.logError(err, "connecting to Unix socket");
                logging.logWarning("  Socket path: {s}\n", .{socket_path});
            },
        }
        return err;
    };

    if (cfg.verbose) {
        logging.logVerbose(cfg, "Connected to Unix socket.\n", .{});
    }

    // 6. Handle zero-I/O mode (connection test)
    if (cfg.zero_io) {
        if (cfg.verbose) {
            logging.logVerbose(cfg, "Zero-I/O mode (-z): Unix socket connection test successful, closing.\n", .{});
        }
        return;
    }

    // 7. Execute command if specified
    if (cfg.exec_command) |cmd| {
        try executeCommand(allocator, unix_client.getSocket(), cmd, cfg);
        return;
    }

    // 8. Bidirectional data transfer
    // Initialize output logger and hex dumper
    var output_logger = try output.OutputLogger.init(allocator, cfg.output_file, cfg.append_output);
    defer output_logger.deinit();

    var hex_dumper = try hexdump.HexDumper.init(allocator, cfg.hex_dump_file);
    defer hex_dumper.deinit();

    // Handle Telnet protocol mode for Unix sockets
    if (cfg.telnet) {
        // Create Connection wrapper for Unix socket
        const connection = Connection.fromUnixSocket(unix_client.getSocket(), null);

        // Wrap with TelnetConnection for protocol processing
        var telnet_conn = try TelnetConnection.init(connection, allocator, null, null, null);
        defer telnet_conn.deinit();

        if (cfg.verbose) {
            logging.logVerbose(cfg, "Telnet protocol mode enabled for Unix socket, performing initial negotiation...\n", .{});
        }

        // Perform initial Telnet negotiation
        try telnet_conn.performInitialNegotiation();

        // Use TelnetConnection for bidirectional transfer
        try transferWithTelnetConnection(allocator, &telnet_conn, cfg, &output_logger, &hex_dumper);
    } else {
        // Use standard bidirectional transfer with Unix socket
        const stream = std.net.Stream{ .handle = unix_client.getSocket() };
        try transfer.bidirectionalTransfer(allocator, stream, cfg, &output_logger, &hex_dumper);
    }
}

/// Bidirectional data transfer using TelnetConnection.
/// Handles Telnet protocol processing while maintaining compatibility with existing I/O control features.
///
/// This function provides the same functionality as the standard bidirectional transfer
/// but processes data through the Telnet protocol layer for IAC sequence handling and
/// option negotiation.
///
/// Parameters:
///   allocator: Memory allocator for buffers and temporary data
///   telnet_conn: TelnetConnection handling protocol processing
///   cfg: Configuration with I/O control, timeouts, and logging options
///   output_logger: Logger for output file writing
///   hex_dumper: Hex dump formatter for debugging output
fn transferWithTelnetConnection(
    allocator: std.mem.Allocator,
    telnet_conn: *TelnetConnection,
    cfg: *const config.Config,
    output_logger: *output.OutputLogger,
    hex_dumper: *hexdump.HexDumper,
) !void {
    // Use the same transfer logic as the standard bidirectional transfer,
    // but create a wrapper that uses TelnetConnection's read/write methods
    const TelnetStream = struct {
        telnet_conn: *TelnetConnection,

        const Self = @This();

        pub fn read(self: Self, buffer: []u8) !usize {
            return self.telnet_conn.read(buffer);
        }

        pub fn write(self: Self, data: []const u8) !usize {
            return self.telnet_conn.write(data);
        }

        pub fn close(self: Self) void {
            self.telnet_conn.close();
        }
    };

    const telnet_stream = TelnetStream{ .telnet_conn = telnet_conn };

    // Create a std.net.Stream-compatible wrapper for the transfer function
    // Note: This is a bit of a hack since std.net.Stream expects a file handle,
    // but we need to use our TelnetConnection methods instead.
    // We'll need to implement our own transfer logic here.

    try telnetBidirectionalTransfer(allocator, telnet_stream, cfg, output_logger, hex_dumper);
}

/// Telnet-aware bidirectional data transfer between stdin/stdout and Telnet connection.
///
/// This function replicates the core logic of bidirectionalTransfer but uses
/// TelnetConnection methods for network I/O to ensure proper Telnet protocol handling.
///
/// Features:
/// - Telnet protocol processing (IAC sequences, option negotiation)
/// - I/O control modes (send-only, recv-only)
/// - Timeout handling with poll()
/// - Output logging and hex dump support
/// - Graceful shutdown on EOF or timeout
///
/// Parameters:
///   allocator: Memory allocator for buffers
///   telnet_stream: Wrapper around TelnetConnection
///   cfg: Configuration with I/O control and timeout settings
///   output_logger: Logger for output file writing
///   hex_dumper: Hex dump formatter for debugging
pub fn telnetBidirectionalTransfer(
    allocator: std.mem.Allocator,
    telnet_stream: anytype,
    cfg: *const config.Config,
    output_logger: *output.OutputLogger,
    hex_dumper: *hexdump.HexDumper,
) !void {
    _ = allocator; // May be used for future buffer allocation

    const stdin = std.fs.File.stdin();
    const stdout = std.fs.File.stdout();

    var buffer: [8192]u8 = undefined;
    const should_continue = true;

    // Get socket for poll operations
    const socket = telnet_stream.telnet_conn.getSocket();

    while (should_continue) {
        // Set up poll for both stdin and socket
        var poll_fds = [_]std.posix.pollfd{
            .{ .fd = stdin.handle, .events = std.posix.POLL.IN, .revents = 0 },
            .{ .fd = socket, .events = std.posix.POLL.IN, .revents = 0 },
        };

        // Apply I/O control modes
        if (cfg.recv_only) {
            poll_fds[0].events = 0; // Don't poll stdin in recv-only mode
        }
        if (cfg.send_only) {
            poll_fds[1].events = 0; // Don't poll socket in send-only mode
        }

        // Poll with timeout
        const timeout_ms: i32 = if (cfg.idle_timeout > 0) @intCast(cfg.idle_timeout) else -1;
        const poll_result = std.posix.poll(&poll_fds, timeout_ms) catch |err| {
            if (cfg.verbose) {
                logging.logVerbose(cfg, "Poll error: {}\n", .{err});
            }
            break;
        };

        if (poll_result == 0) {
            // Timeout
            if (cfg.verbose) {
                logging.logVerbose(cfg, "Idle timeout reached, closing connection.\n", .{});
            }
            break;
        }

        // Handle stdin data (send to network)
        if (poll_fds[0].revents & std.posix.POLL.IN != 0) {
            const bytes_read = stdin.read(&buffer) catch |err| {
                if (cfg.verbose) {
                    logging.logVerbose(cfg, "Stdin read error: {}\n", .{err});
                }
                break;
            };

            if (bytes_read == 0) {
                // EOF on stdin
                if (cfg.verbose) {
                    logging.logVerbose(cfg, "EOF on stdin\n", .{});
                }
                if (cfg.close_on_eof) {
                    break;
                }
                // Continue reading from network even after stdin EOF
                poll_fds[0].events = 0;
            } else {
                var data_to_send = buffer[0..bytes_read];

                // Apply CRLF conversion if enabled
                var crlf_buffer: [16384]u8 = undefined;
                if (cfg.crlf) {
                    var crlf_len: usize = 0;
                    for (data_to_send) |byte| {
                        if (byte == '\n' and crlf_len < crlf_buffer.len - 1) {
                            crlf_buffer[crlf_len] = '\r';
                            crlf_len += 1;
                        }
                        if (crlf_len < crlf_buffer.len) {
                            crlf_buffer[crlf_len] = byte;
                            crlf_len += 1;
                        }
                    }
                    data_to_send = crlf_buffer[0..crlf_len];
                }

                // Send through Telnet connection
                const bytes_written = telnet_stream.telnet_conn.write(data_to_send) catch |err| {
                    if (cfg.verbose) {
                        logging.logVerbose(cfg, "Network write error: {}\n", .{err});
                    }
                    break;
                };

                if (cfg.verbose) {
                    logging.logVerbose(cfg, "Sent {} bytes to network\n", .{bytes_written});
                }

                // Log to hex dump if enabled
                try hex_dumper.dump(data_to_send[0..bytes_written]);
            }
        }

        // Handle network data (send to stdout)
        if (poll_fds[1].revents & std.posix.POLL.IN != 0) {
            const bytes_read = telnet_stream.telnet_conn.read(&buffer) catch |err| {
                if (cfg.verbose) {
                    logging.logVerbose(cfg, "Network read error: {}\n", .{err});
                }
                break;
            };

            if (bytes_read == 0) {
                // EOF on network
                if (cfg.verbose) {
                    logging.logVerbose(cfg, "EOF on network connection\n", .{});
                }
                break;
            } else {
                const data_received = buffer[0..bytes_read];

                // Write to stdout
                _ = stdout.write(data_received) catch |err| {
                    if (cfg.verbose) {
                        logging.logVerbose(cfg, "Stdout write error: {}\n", .{err});
                    }
                    break;
                };

                // Log to output file if enabled
                try output_logger.write(data_received);

                // Log to hex dump if enabled
                try hex_dumper.dump(data_received);

                if (cfg.verbose) {
                    logging.logVerbose(cfg, "Received {} bytes from network\n", .{bytes_read});
                }
            }
        }

        // Check for error conditions
        if (poll_fds[0].revents & (std.posix.POLL.ERR | std.posix.POLL.HUP | std.posix.POLL.NVAL) != 0) {
            if (cfg.verbose) {
                logging.logVerbose(cfg, "Stdin error condition\n", .{});
            }
            break;
        }

        if (poll_fds[1].revents & (std.posix.POLL.ERR | std.posix.POLL.HUP | std.posix.POLL.NVAL) != 0) {
            if (cfg.verbose) {
                logging.logVerbose(cfg, "Network error condition\n", .{});
            }
            break;
        }
    }

    if (cfg.verbose) {
        logging.logVerbose(cfg, "Telnet transfer completed\n", .{});
    }
}
</file>

<file path="config.zig">
//! zigcat configuration primitives.
//!
//! This module now acts as a thin facade that re-exports focused
//! configuration domains located under `src/config/`.

const types = @import("config/types.zig");
const config_struct = @import("config/config_struct.zig");
const cli = @import("config/cli.zig");
const network = @import("config/network.zig");
const tls = @import("config/tls.zig");
const security = @import("config/security.zig");
const validator = @import("config/validator.zig");
const timeout = @import("config/timeout.zig");

pub const VerbosityLevel = types.VerbosityLevel;
pub const ProxyType = types.ProxyType;
pub const ProxyDns = types.ProxyDns;

pub const Config = config_struct.Config;
pub const buildExecSessionConfig = config_struct.buildExecSessionConfig;

pub const IOControlError = cli.IOControlError;
pub const validateIOControl = cli.validateIOControl;

pub const UnixSocketSupport = network.UnixSocketSupport;
pub const UnixSocketError = network.UnixSocketError;
pub const validateUnixSocket = network.validateUnixSocket;

pub const TLSConfigError = tls.TLSConfigError;
pub const validateTlsConfiguration = tls.validateTlsConfiguration;

pub const BrokerChatError = security.BrokerChatError;
pub const validateBrokerChat = security.validateBrokerChat;

pub const validate = validator.validate;

// Timeout selection
pub const TimeoutContext = timeout.TimeoutContext;
pub const getConnectionTimeout = timeout.getConnectionTimeout;
</file>

<file path="main.zig">
//! Entry point facade for zigcat.

const app = @import("main/app.zig");

pub fn main() !void {
    try app.run();
}
</file>

</files>
